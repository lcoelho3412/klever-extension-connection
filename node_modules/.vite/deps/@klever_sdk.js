import {
  __commonJS,
  __toESM
} from "./chunk-DSTXS4JB.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code.`);
        }
      }
    }));
  }
});

// browser-external:node:fs/promises
var require_promises = __commonJS({
  "browser-external:node:fs/promises"(exports2, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:fs/promises" has been externalized for browser compatibility. Cannot access "node:fs/promises.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/@klever/sdk/dist/esm/index.js
var nodeCrypto = __toESM(require_crypto());
var fs = __toESM(require_promises());
var TransactionType;
var TriggerType;
var ParameterType;
function __awaiter(e2, t, n, o) {
  return new (n || (n = Promise))(function(r, a) {
    function i(e3) {
      try {
        c(o.next(e3));
      } catch (e4) {
        a(e4);
      }
    }
    function s(e3) {
      try {
        c(o.throw(e3));
      } catch (e4) {
        a(e4);
      }
    }
    function c(e3) {
      var t2;
      e3.done ? r(e3.value) : (t2 = e3.value, t2 instanceof n ? t2 : new n(function(e4) {
        e4(t2);
      })).then(i, s);
    }
    c((o = o.apply(e2, t || [])).next());
  });
}
!function(e2) {
  e2[e2.Transfer = 0] = "Transfer", e2[e2.CreateAsset = 1] = "CreateAsset", e2[e2.CreateValidator = 2] = "CreateValidator", e2[e2.ConfigValidator = 3] = "ConfigValidator", e2[e2.Freeze = 4] = "Freeze", e2[e2.Unfreeze = 5] = "Unfreeze", e2[e2.Delegate = 6] = "Delegate", e2[e2.Undelegate = 7] = "Undelegate", e2[e2.Withdraw = 8] = "Withdraw", e2[e2.Claim = 9] = "Claim", e2[e2.Unjail = 10] = "Unjail", e2[e2.AssetTrigger = 11] = "AssetTrigger", e2[e2.SetAccountName = 12] = "SetAccountName", e2[e2.Proposal = 13] = "Proposal", e2[e2.Votes = 14] = "Votes", e2[e2.ConfigITO = 15] = "ConfigITO", e2[e2.SetITOPrices = 16] = "SetITOPrices", e2[e2.BuyOrder = 17] = "BuyOrder", e2[e2.SellOrder = 18] = "SellOrder", e2[e2.CancelMarketOrder = 19] = "CancelMarketOrder", e2[e2.CreateMarketplace = 20] = "CreateMarketplace", e2[e2.ConfigMarketplace = 21] = "ConfigMarketplace", e2[e2.UpdateAccountPermission = 22] = "UpdateAccountPermission";
}(TransactionType || (TransactionType = {})), function(e2) {
  e2[e2.Mint = 0] = "Mint", e2[e2.Burn = 1] = "Burn", e2[e2.Wipe = 2] = "Wipe", e2[e2.Pause = 3] = "Pause", e2[e2.Resume = 4] = "Resume", e2[e2.ChangeOwner = 5] = "ChangeOwner", e2[e2.AddRole = 6] = "AddRole", e2[e2.RemoveRole = 7] = "RemoveRole", e2[e2.UpdateMetadata = 8] = "UpdateMetadata", e2[e2.StopNFTMint = 9] = "StopNFTMint", e2[e2.UpdateLogo = 10] = "UpdateLogo", e2[e2.UpdateURIs = 11] = "UpdateURIs", e2[e2.ChangeRoyaltiesReceiver = 12] = "ChangeRoyaltiesReceiver", e2[e2.UpdateStaking = 13] = "UpdateStaking";
}(TriggerType || (TriggerType = {})), function(e2) {
  e2[e2.FeePerDataByte = 0] = "FeePerDataByte", e2[e2.KAppFeeCreateValidator = 1] = "KAppFeeCreateValidator", e2[e2.KAppFeeCreateAsset = 2] = "KAppFeeCreateAsset", e2[e2.MaxEpochsUnclaimed = 3] = "MaxEpochsUnclaimed", e2[e2.MinSelfDelegatedAmount = 4] = "MinSelfDelegatedAmount", e2[e2.MinTotalDelegatedAmount = 5] = "MinTotalDelegatedAmount", e2[e2.BlockRewards = 6] = "BlockRewards", e2[e2.StakingRewards = 7] = "StakingRewards", e2[e2.KAppFeeTransfer = 8] = "KAppFeeTransfer", e2[e2.KAppFeeAssetTrigger = 9] = "KAppFeeAssetTrigger", e2[e2.KAppFeeValidatorConfig = 10] = "KAppFeeValidatorConfig", e2[e2.KAppFeeFreeze = 11] = "KAppFeeFreeze", e2[e2.KAppFeeUnfreeze = 12] = "KAppFeeUnfreeze", e2[e2.KAppFeeDelegate = 13] = "KAppFeeDelegate", e2[e2.KAppFeeUndelegate = 14] = "KAppFeeUndelegate", e2[e2.KAppFeeWithdraw = 15] = "KAppFeeWithdraw", e2[e2.KAppFeeClaim = 16] = "KAppFeeClaim", e2[e2.KAppFeeUnjail = 17] = "KAppFeeUnjail", e2[e2.KAppFeeSetAccountName = 18] = "KAppFeeSetAccountName", e2[e2.KAppFeeProposal = 19] = "KAppFeeProposal", e2[e2.KAppFeeVote = 20] = "KAppFeeVote", e2[e2.KAppFeeConfigITO = 21] = "KAppFeeConfigITO", e2[e2.KAppFeeSetITOPrices = 22] = "KAppFeeSetITOPrices", e2[e2.KAppFeeBuy = 23] = "KAppFeeBuy", e2[e2.KAppFeeSell = 24] = "KAppFeeSell", e2[e2.KAppFeeCancelMarketOrder = 25] = "KAppFeeCancelMarketOrder", e2[e2.KAppFeeCreateMarketplace = 26] = "KAppFeeCreateMarketplace", e2[e2.KAppFeeConfigMarketplace = 27] = "KAppFeeConfigMarketplace", e2[e2.KAppFeeUpdateAccountPermission = 28] = "KAppFeeUpdateAccountPermission", e2[e2.MaxNFTMintBatch = 29] = "MaxNFTMintBatch", e2[e2.MinKFIStakedToEnableProposals = 30] = "MinKFIStakedToEnableProposals", e2[e2.MinKLVBucketAmount = 31] = "MinKLVBucketAmount", e2[e2.MaxBucketSize = 32] = "MaxBucketSize", e2[e2.LeaderValidatorRewardsPercentage = 33] = "LeaderValidatorRewardsPercentage", e2[e2.ProposalMaxEpochsDuration = 34] = "ProposalMaxEpochsDuration";
}(ParameterType || (ParameterType = {}));
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
var CURVE = Object.freeze({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), l: CU_O, n: CU_O, h: BigInt(8), Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960") });
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
var SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742"), BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var ExtendedPoint = class {
  constructor(e2, t, n, o) {
    this.x = e2, this.y = t, this.z = n, this.t = o;
  }
  static fromAffine(e2) {
    if (!(e2 instanceof Point))
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    return e2.equals(Point.ZERO) ? ExtendedPoint.ZERO : new ExtendedPoint(e2.x, e2.y, _1n, mod2(e2.x * e2.y));
  }
  static toAffineBatch(e2) {
    const t = invertBatch(e2.map((e3) => e3.z));
    return e2.map((e3, n) => e3.toAffine(t[n]));
  }
  static normalizeZ(e2) {
    return this.toAffineBatch(e2).map(this.fromAffine);
  }
  equals(e2) {
    assertExtPoint(e2);
    const { x: t, y: n, z: o } = this, { x: r, y: a, z: i } = e2, s = mod2(t * i), c = mod2(r * o), d = mod2(n * i), l = mod2(a * o);
    return s === c && d === l;
  }
  negate() {
    return new ExtendedPoint(mod2(-this.x), this.y, this.z, mod2(-this.t));
  }
  double() {
    const { x: e2, y: t, z: n } = this, { a: o } = CURVE, r = mod2(e2 * e2), a = mod2(t * t), i = mod2(_2n * mod2(n * n)), s = mod2(o * r), c = e2 + t, d = mod2(mod2(c * c) - r - a), l = s + a, u = l - i, p = s - a, m2 = mod2(d * u), f = mod2(l * p), y = mod2(d * p), v2 = mod2(u * l);
    return new ExtendedPoint(m2, f, v2, y);
  }
  add(e2) {
    assertExtPoint(e2);
    const { x: t, y: n, z: o, t: r } = this, { x: a, y: i, z: s, t: c } = e2, d = mod2((n - t) * (i + a)), l = mod2((n + t) * (i - a)), u = mod2(l - d);
    if (u === _0n)
      return this.double();
    const p = mod2(o * _2n * c), m2 = mod2(r * _2n * s), f = m2 + p, y = l + d, v2 = m2 - p, g = mod2(f * u), T = mod2(y * v2), C = mod2(f * v2), h = mod2(u * y);
    return new ExtendedPoint(g, T, h, C);
  }
  subtract(e2) {
    return this.add(e2.negate());
  }
  precomputeWindow(e2) {
    const t = 1 + 256 / e2, n = [];
    let o = this, r = o;
    for (let a = 0; a < t; a++) {
      r = o, n.push(r);
      for (let t2 = 1; t2 < 2 ** (e2 - 1); t2++)
        r = r.add(o), n.push(r);
      o = r.double();
    }
    return n;
  }
  wNAF(e2, t) {
    !t && this.equals(ExtendedPoint.BASE) && (t = Point.BASE);
    const n = t && t._WINDOW_SIZE || 1;
    if (256 % n)
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    let o = t && pointPrecomputes.get(t);
    o || (o = this.precomputeWindow(n), t && 1 !== n && (o = ExtendedPoint.normalizeZ(o), pointPrecomputes.set(t, o)));
    let r = ExtendedPoint.ZERO, a = ExtendedPoint.ZERO;
    const i = 1 + 256 / n, s = 2 ** (n - 1), c = BigInt(2 ** n - 1), d = 2 ** n, l = BigInt(n);
    for (let t2 = 0; t2 < i; t2++) {
      const n2 = t2 * s;
      let i2 = Number(e2 & c);
      if (e2 >>= l, i2 > s && (i2 -= d, e2 += _1n), 0 === i2) {
        let e3 = o[n2];
        t2 % 2 && (e3 = e3.negate()), a = a.add(e3);
      } else {
        let e3 = o[n2 + Math.abs(i2) - 1];
        i2 < 0 && (e3 = e3.negate()), r = r.add(e3);
      }
    }
    return ExtendedPoint.normalizeZ([r, a])[0];
  }
  multiply(e2, t) {
    return this.wNAF(normalizeScalar(e2, CURVE.l), t);
  }
  multiplyUnsafe(e2) {
    let t = normalizeScalar(e2, CURVE.l, false);
    const n = ExtendedPoint.BASE, o = ExtendedPoint.ZERO;
    if (t === _0n)
      return o;
    if (this.equals(o) || t === _1n)
      return this;
    if (this.equals(n))
      return this.wNAF(t);
    let r = o, a = this;
    for (; t > _0n; )
      t & _1n && (r = r.add(a)), a = a.double(), t >>= _1n;
    return r;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
  }
  isTorsionFree() {
    return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);
  }
  toAffine(e2 = invert(this.z)) {
    const { x: t, y: n, z: o } = this, r = mod2(t * e2), a = mod2(n * e2);
    if (mod2(o * e2) !== _1n)
      throw new Error("invZ was invalid");
    return new Point(r, a);
  }
  fromRistrettoBytes() {
    legacyRist();
  }
  toRistrettoBytes() {
    legacyRist();
  }
  fromRistrettoHash() {
    legacyRist();
  }
};
function assertExtPoint(e2) {
  if (!(e2 instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod2(CURVE.Gx * CURVE.Gy)), ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var Point = class {
  constructor(e2, t) {
    this.x = e2, this.y = t;
  }
  _setWindowSize(e2) {
    this._WINDOW_SIZE = e2, pointPrecomputes.delete(this);
  }
  static fromHex(e2, t = true) {
    const { d: n, P: o } = CURVE, r = (e2 = ensureBytes(e2, 32)).slice();
    r[31] = -129 & e2[31];
    const a = bytesToNumberLE(r);
    if (t && a >= o)
      throw new Error("Expected 0 < hex < P");
    if (!t && a >= POW_2_256)
      throw new Error("Expected 0 < hex < 2**256");
    const i = mod2(a * a), s = mod2(i - _1n), c = mod2(n * i + _1n);
    let { isValid: d, value: l } = uvRatio(s, c);
    if (!d)
      throw new Error("Point.fromHex: invalid y coordinate");
    const u = (l & _1n) === _1n;
    return 0 != (128 & e2[31]) !== u && (l = mod2(-l)), new Point(l, a);
  }
  static async fromPrivateKey(e2) {
    return (await getExtendedPublicKey(e2)).point;
  }
  toRawBytes() {
    const e2 = numberTo32BytesLE(this.y);
    return e2[31] |= this.x & _1n ? 128 : 0, e2;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toX25519() {
    const { y: e2 } = this;
    return numberTo32BytesLE(mod2((_1n + e2) * invert(_1n - e2)));
  }
  isTorsionFree() {
    return ExtendedPoint.fromAffine(this).isTorsionFree();
  }
  equals(e2) {
    return this.x === e2.x && this.y === e2.y;
  }
  negate() {
    return new Point(mod2(-this.x), this.y);
  }
  add(e2) {
    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(e2)).toAffine();
  }
  subtract(e2) {
    return this.add(e2.negate());
  }
  multiply(e2) {
    return ExtendedPoint.fromAffine(this).multiply(e2, this).toAffine();
  }
};
Point.BASE = new Point(CURVE.Gx, CURVE.Gy), Point.ZERO = new Point(_0n, _1n);
var Signature = class {
  constructor(e2, t) {
    this.r = e2, this.s = t, this.assertValidity();
  }
  static fromHex(e2) {
    const t = ensureBytes(e2, 64), n = Point.fromHex(t.slice(0, 32), false), o = bytesToNumberLE(t.slice(32, 64));
    return new Signature(n, o);
  }
  assertValidity() {
    const { r: e2, s: t } = this;
    if (!(e2 instanceof Point))
      throw new Error("Expected Point instance");
    return normalizeScalar(t, CURVE.l, false), this;
  }
  toRawBytes() {
    const e2 = new Uint8Array(64);
    return e2.set(this.r.toRawBytes()), e2.set(numberTo32BytesLE(this.s), 32), e2;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
};
function concatBytes(...e2) {
  if (!e2.every((e3) => e3 instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (1 === e2.length)
    return e2[0];
  const t = e2.reduce((e3, t2) => e3 + t2.length, 0), n = new Uint8Array(t);
  for (let t2 = 0, o = 0; t2 < e2.length; t2++) {
    const r = e2[t2];
    n.set(r, o), o += r.length;
  }
  return n;
}
var hexes = Array.from({ length: 256 }, (e2, t) => t.toString(16).padStart(2, "0"));
function bytesToHex(e2) {
  if (!(e2 instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let n = 0; n < e2.length; n++)
    t += hexes[e2[n]];
  return t;
}
function hexToBytes(e2) {
  if ("string" != typeof e2)
    throw new TypeError("hexToBytes: expected string, got " + typeof e2);
  if (e2.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const t = new Uint8Array(e2.length / 2);
  for (let n = 0; n < t.length; n++) {
    const o = 2 * n, r = e2.slice(o, o + 2), a = Number.parseInt(r, 16);
    if (Number.isNaN(a) || a < 0)
      throw new Error("Invalid byte sequence");
    t[n] = a;
  }
  return t;
}
function numberTo32BytesBE(e2) {
  return hexToBytes(e2.toString(16).padStart(64, "0"));
}
function numberTo32BytesLE(e2) {
  return numberTo32BytesBE(e2).reverse();
}
function edIsNegative(e2) {
  return (mod2(e2) & _1n) === _1n;
}
function bytesToNumberLE(e2) {
  if (!(e2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex(Uint8Array.from(e2).reverse()));
}
function mod2(e2, t = CURVE.P) {
  const n = e2 % t;
  return n >= _0n ? n : t + n;
}
function invert(e2, t = CURVE.P) {
  if (e2 === _0n || t <= _0n)
    throw new Error(`invert: expected positive integers, got n=${e2} mod=${t}`);
  let n = mod2(e2, t), o = t, r = _0n, a = _1n;
  for (; n !== _0n; ) {
    const e3 = o % n, t2 = r - a * (o / n);
    o = n, n = e3, r = a, a = t2;
  }
  if (o !== _1n)
    throw new Error("invert: does not exist");
  return mod2(r, t);
}
function invertBatch(e2, t = CURVE.P) {
  const n = new Array(e2.length), o = invert(e2.reduce((e3, o2, r) => o2 === _0n ? e3 : (n[r] = e3, mod2(e3 * o2, t)), _1n), t);
  return e2.reduceRight((e3, o2, r) => o2 === _0n ? e3 : (n[r] = mod2(e3 * n[r], t), mod2(e3 * o2, t)), o), n;
}
function pow2(e2, t) {
  const { P: n } = CURVE;
  let o = e2;
  for (; t-- > _0n; )
    o *= o, o %= n;
  return o;
}
function pow_2_252_3(e2) {
  const { P: t } = CURVE, n = BigInt(5), o = BigInt(10), r = BigInt(20), a = BigInt(40), i = BigInt(80), s = e2 * e2 % t * e2 % t, c = pow2(s, _2n) * s % t, d = pow2(c, _1n) * e2 % t, l = pow2(d, n) * d % t, u = pow2(l, o) * l % t, p = pow2(u, r) * u % t, m2 = pow2(p, a) * p % t, f = pow2(m2, i) * m2 % t, y = pow2(f, i) * m2 % t, v2 = pow2(y, o) * l % t;
  return { pow_p_5_8: pow2(v2, _2n) * e2 % t, b2: s };
}
function uvRatio(e2, t) {
  const n = mod2(t * t * t), o = mod2(n * n * t);
  let r = mod2(e2 * n * pow_2_252_3(e2 * o).pow_p_5_8);
  const a = mod2(t * r * r), i = r, s = mod2(r * SQRT_M1), c = a === e2, d = a === mod2(-e2), l = a === mod2(-e2 * SQRT_M1);
  return c && (r = i), (d || l) && (r = s), edIsNegative(r) && (r = mod2(-r)), { isValid: c || d, value: r };
}
function modlLE(e2) {
  return mod2(bytesToNumberLE(e2), CURVE.l);
}
function ensureBytes(e2, t) {
  const n = e2 instanceof Uint8Array ? Uint8Array.from(e2) : hexToBytes(e2);
  if ("number" == typeof t && n.length !== t)
    throw new Error(`Expected ${t} bytes`);
  return n;
}
function normalizeScalar(e2, t, n = true) {
  if (!t)
    throw new TypeError("Specify max value");
  if ("number" == typeof e2 && Number.isSafeInteger(e2) && (e2 = BigInt(e2)), "bigint" == typeof e2 && e2 < t) {
    if (n) {
      if (_0n < e2)
        return e2;
    } else if (_0n <= e2)
      return e2;
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(e2) {
  return e2[0] &= 248, e2[31] &= 127, e2[31] |= 64, e2;
}
function checkPrivateKey(e2) {
  if (32 !== (e2 = "bigint" == typeof e2 || "number" == typeof e2 ? numberTo32BytesBE(normalizeScalar(e2, POW_2_256)) : ensureBytes(e2)).length)
    throw new Error("Expected 32 bytes");
  return e2;
}
function getKeyFromHash(e2) {
  const t = adjustBytes25519(e2.slice(0, 32)), n = e2.slice(32, 64), o = modlLE(t), r = Point.BASE.multiply(o), a = r.toRawBytes();
  return { head: t, prefix: n, scalar: o, point: r, pointBytes: a };
}
var _sha512Sync;
async function getExtendedPublicKey(e2) {
  return getKeyFromHash(await utils$1.sha512(checkPrivateKey(e2)));
}
async function getPublicKey(e2) {
  return (await getExtendedPublicKey(e2)).pointBytes;
}
async function sign(e2, t) {
  e2 = ensureBytes(e2);
  const { prefix: n, scalar: o, pointBytes: r } = await getExtendedPublicKey(t), a = modlLE(await utils$1.sha512(n, e2)), i = Point.BASE.multiply(a), s = mod2(a + modlLE(await utils$1.sha512(i.toRawBytes(), r, e2)) * o, CURVE.l);
  return new Signature(i, s).toRawBytes();
}
function prepareVerification(e2, t, n) {
  t = ensureBytes(t), n instanceof Point || (n = Point.fromHex(n, false));
  const { r: o, s: r } = e2 instanceof Signature ? e2.assertValidity() : Signature.fromHex(e2);
  return { r: o, s: r, SB: ExtendedPoint.BASE.multiplyUnsafe(r), pub: n, msg: t };
}
function finishVerification(e2, t, n, o) {
  const r = modlLE(o), a = ExtendedPoint.fromAffine(e2).multiplyUnsafe(r);
  return ExtendedPoint.fromAffine(t).add(a).subtract(n).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
async function verify(e2, t, n) {
  const { r: o, SB: r, msg: a, pub: i } = prepareVerification(e2, t, n), s = await utils$1.sha512(o.toRawBytes(), i.toRawBytes(), a);
  return finishVerification(i, o, r, s);
}
BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), Point.BASE._setWindowSize(8);
var crypto = { node: nodeCrypto, web: "object" == typeof self && "crypto" in self ? self.crypto : void 0 };
var utils$1 = { bytesToHex, hexToBytes, concatBytes, getExtendedPublicKey, mod: mod2, invert, TORSION_SUBGROUP: ["0100000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a", "0000000000000000000000000000000000000000000000000000000000000080", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05", "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85", "0000000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"], hashToPrivateScalar: (e2) => {
  if ((e2 = ensureBytes(e2)).length < 40 || e2.length > 1024)
    throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
  return mod2(bytesToNumberLE(e2), CURVE.l - _1n) + _1n;
}, randomBytes: (e2 = 32) => {
  if (crypto.web)
    return crypto.web.getRandomValues(new Uint8Array(e2));
  if (crypto.node) {
    const { randomBytes: t } = crypto.node;
    return new Uint8Array(t(e2).buffer);
  }
  throw new Error("The environment doesn't have randomBytes function");
}, randomPrivateKey: () => utils$1.randomBytes(32), sha512: async (...e2) => {
  const t = concatBytes(...e2);
  if (crypto.web) {
    const e3 = await crypto.web.subtle.digest("SHA-512", t.buffer);
    return new Uint8Array(e3);
  }
  if (crypto.node)
    return Uint8Array.from(crypto.node.createHash("sha512").update(t).digest());
  throw new Error("The environment doesn't have sha512 function");
}, precompute(e2 = 8, t = Point.BASE) {
  const n = t.equals(Point.BASE) ? t : new Point(t.x, t.y);
  return n._setWindowSize(e2), n.multiply(_2n), n;
}, sha512Sync: void 0 };
Object.defineProperties(utils$1, { sha512Sync: { configurable: false, get: () => _sha512Sync, set(e2) {
  _sha512Sync || (_sha512Sync = e2);
} } });
var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
var dist$1 = {};
Object.defineProperty(dist$1, "__esModule", { value: true }), dist$1.bech32m = bech32 = dist$1.bech32 = void 0;
var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var ALPHABET_MAP = {};
for (let e2 = 0; e2 < ALPHABET.length; e2++) {
  const t = ALPHABET.charAt(e2);
  ALPHABET_MAP[t] = e2;
}
function polymodStep(e2) {
  const t = e2 >> 25;
  return (33554431 & e2) << 5 ^ 996825010 & -(t >> 0 & 1) ^ 642813549 & -(t >> 1 & 1) ^ 513874426 & -(t >> 2 & 1) ^ 1027748829 & -(t >> 3 & 1) ^ 705979059 & -(t >> 4 & 1);
}
function prefixChk(e2) {
  let t = 1;
  for (let n = 0; n < e2.length; ++n) {
    const o = e2.charCodeAt(n);
    if (o < 33 || o > 126)
      return "Invalid prefix (" + e2 + ")";
    t = polymodStep(t) ^ o >> 5;
  }
  t = polymodStep(t);
  for (let n = 0; n < e2.length; ++n) {
    const o = e2.charCodeAt(n);
    t = polymodStep(t) ^ 31 & o;
  }
  return t;
}
function convert(e2, t, n, o) {
  let r = 0, a = 0;
  const i = (1 << n) - 1, s = [];
  for (let o2 = 0; o2 < e2.length; ++o2)
    for (r = r << t | e2[o2], a += t; a >= n; )
      a -= n, s.push(r >> a & i);
  if (o)
    a > 0 && s.push(r << n - a & i);
  else {
    if (a >= t)
      return "Excess padding";
    if (r << n - a & i)
      return "Non-zero padding";
  }
  return s;
}
function toWords(e2) {
  return convert(e2, 8, 5, true);
}
function fromWordsUnsafe(e2) {
  const t = convert(e2, 5, 8, false);
  if (Array.isArray(t))
    return t;
}
function fromWords(e2) {
  const t = convert(e2, 5, 8, false);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
function getLibraryFromEncoding(e2) {
  let t;
  function n(e3, n2) {
    if (n2 = n2 || 90, e3.length < 8)
      return e3 + " too short";
    if (e3.length > n2)
      return "Exceeds length limit";
    const o = e3.toLowerCase(), r = e3.toUpperCase();
    if (e3 !== o && e3 !== r)
      return "Mixed-case string " + e3;
    const a = (e3 = o).lastIndexOf("1");
    if (-1 === a)
      return "No separator character for " + e3;
    if (0 === a)
      return "Missing prefix for " + e3;
    const i = e3.slice(0, a), s = e3.slice(a + 1);
    if (s.length < 6)
      return "Data too short";
    let c = prefixChk(i);
    if ("string" == typeof c)
      return c;
    const d = [];
    for (let e4 = 0; e4 < s.length; ++e4) {
      const t2 = s.charAt(e4), n3 = ALPHABET_MAP[t2];
      if (void 0 === n3)
        return "Unknown character " + t2;
      c = polymodStep(c) ^ n3, e4 + 6 >= s.length || d.push(n3);
    }
    return c !== t ? "Invalid checksum for " + e3 : { prefix: i, words: d };
  }
  return t = "bech32" === e2 ? 1 : 734539939, { decodeUnsafe: function(e3, t2) {
    const o = n(e3, t2);
    if ("object" == typeof o)
      return o;
  }, decode: function(e3, t2) {
    const o = n(e3, t2);
    if ("object" == typeof o)
      return o;
    throw new Error(o);
  }, encode: function(e3, n2, o) {
    if (o = o || 90, e3.length + 7 + n2.length > o)
      throw new TypeError("Exceeds length limit");
    let r = prefixChk(e3 = e3.toLowerCase());
    if ("string" == typeof r)
      throw new Error(r);
    let a = e3 + "1";
    for (let e4 = 0; e4 < n2.length; ++e4) {
      const t2 = n2[e4];
      if (t2 >> 5 != 0)
        throw new Error("Non 5-bit word");
      r = polymodStep(r) ^ t2, a += ALPHABET.charAt(t2);
    }
    for (let e4 = 0; e4 < 6; ++e4)
      r = polymodStep(r);
    r ^= t;
    for (let e4 = 0; e4 < 6; ++e4) {
      const t2 = r >> 5 * (5 - e4) & 31;
      a += ALPHABET.charAt(t2);
    }
    return a;
  }, toWords, fromWordsUnsafe, fromWords };
}
var bech32 = dist$1.bech32 = getLibraryFromEncoding("bech32");
dist$1.bech32m = getLibraryFromEncoding("bech32m");
var decodeAddress = (e2) => __awaiter(void 0, void 0, void 0, function* () {
  const t = bech32.decode(e2);
  return Uint8Array.from(bech32.fromWords(t.words));
});
var encodeAddress = (e2) => bech32.encode("klv", bech32.toWords(e2));
var toHex$1 = (e2) => Buffer.from(e2).toString("hex");
var getAddressFromPrivateKey = (e2) => __awaiter(void 0, void 0, void 0, function* () {
  const t = yield getPublicKey(e2);
  return bech32.encode("klv", bech32.toWords(t));
});
var generateKeyPair = () => __awaiter(void 0, void 0, void 0, function* () {
  const e2 = Buffer.from(utils$1.randomPrivateKey()).toString("hex"), t = yield getPublicKey(e2);
  return { privateKey: e2, address: bech32.encode("klv", bech32.toWords(t)) };
});
var getProviders = () => globalThis.kleverProviders || { node: "https://node.mainnet.klever.finance", api: "https://api.mainnet.klever.finance" };
var setProviders = (e2) => {
  globalThis.kleverProviders = e2;
};
var broadcastTransactions$1 = (e2) => __awaiter(void 0, void 0, void 0, function* () {
  const t = yield fetch(`${getProviders().node}/transaction/broadcast`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ txs: e2 }) });
  return yield t.json();
});
var decodeTransaction = (e2) => __awaiter(void 0, void 0, void 0, function* () {
  const t = yield fetch(`${getProviders().node}/transaction/decode`, { method: "POST", body: JSON.stringify(e2) }), n = yield t.json();
  if (null == n ? void 0 : n.error)
    throw null == n ? void 0 : n.error;
  return n.data;
});
var transactionsProcessed = (e2, t = 10) => __awaiter(void 0, void 0, void 0, function* () {
  const n = yield Promise.all(e2), o = [];
  n.forEach((e3) => {
    o.push(...e3.data.txsHashes);
  });
  const r = o.map((e3) => __awaiter(void 0, void 0, void 0, function* () {
    const n2 = Array.from({ length: t }, (e4, t2) => t2);
    let o2 = "";
    for (const t2 of n2) {
      const t3 = fetch(`${getProviders().api}/transaction/${e3}`), n3 = yield t3, r2 = yield n3.json();
      if (r2 && !r2.error)
        return r2.data;
      r2.error && (o2 = r2), yield new Promise((e4) => setTimeout(e4, 1e3));
    }
    throw o2;
  }));
  return yield Promise.all(r);
});
var accountsReady = (e2) => __awaiter(void 0, void 0, void 0, function* () {
  const t = [];
  e2.forEach((e3) => {
    t.push(e3.ready);
  }), yield Promise.all(t);
});
var validateSignature$1 = (e2, t, n) => __awaiter(void 0, void 0, void 0, function* () {
  const o = yield decodeAddress(n);
  return yield verify(t, e2, o);
});
var utils = { getAddressFromPrivateKey, generateKeyPair, getProviders, setProviders, broadcastTransactions: broadcastTransactions$1, decodeTransaction, transactionsProcessed, accountsReady, decodeAddress, encodeAddress, toHex: toHex$1, validateSignature: validateSignature$1 };
var Account = class {
  constructor(e2) {
    this.buildTransaction = (e3, t, n) => __awaiter(this, void 0, void 0, function* () {
      var o, r;
      if (0 === (null == e3 ? void 0 : e3.length))
        throw "empty contracts";
      const a = null === (o = e3[0]) || void 0 === o ? void 0 : o.type, i = e3.map((e4) => {
        if (e4.type != a)
          throw "Multiple contracts of different types are not supported yet";
        return e4.payload;
      }), s = (null == n ? void 0 : n.nonce) ? n.nonce : this.nonce, c = (null == n ? void 0 : n.permID) || 0, d = { type: a, nonce: s, sender: this.address, data: t || [], permID: c, contracts: i };
      try {
        const e4 = yield fetch(`${utils.getProviders().node}/transaction/send`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(d) }), t2 = yield e4.json();
        if (null == t2 ? void 0 : t2.error)
          throw null == t2 ? void 0 : t2.error;
        if (!(null == t2 ? void 0 : t2.data) && !(null === (r = null == t2 ? void 0 : t2.data) || void 0 === r ? void 0 : r.result))
          throw "failed to generate transaction";
        return t2.data.result;
      } catch (e4) {
        throw e4;
      }
    }), this.signMessage = (e3) => __awaiter(this, void 0, void 0, function* () {
      const t = yield sign(e3, this.privateKey);
      return Buffer.from(t).toString("base64");
    }), this.signTransaction = (e3) => __awaiter(this, void 0, void 0, function* () {
      let t;
      try {
        const n2 = yield fetch(`${utils.getProviders().node}/transaction/decode`, { method: "POST", body: JSON.stringify(e3) });
        t = (yield n2.json()).data.tx.hash;
      } catch (e4) {
        console.log(e4);
      }
      const n = yield this.signMessage(t);
      return Object.assign(Object.assign({}, e3), { Signature: [n] });
    }), this.quickSend = (e3, t, n) => __awaiter(this, void 0, void 0, function* () {
      const o = yield this.buildTransaction(e3, t, n), r = yield this.signTransaction(o), a = yield utils.broadcastTransactions([r]);
      if (null == a ? void 0 : a.error)
        throw null == a ? void 0 : a.error;
      return (null == n ? void 0 : n.nonce) || (this.nonce = this.nonce + 1), a;
    }), this.downloadAsPem = (e3) => __awaiter(this, void 0, void 0, function* () {
      e3 = e3 || `./${this.address.slice(-5)}.pem`;
      const t = yield getPublicKey(this.privateKey), n = Buffer.from(Buffer.from(this.privateKey).toString() + Buffer.from(t).toString("hex")).toString("base64"), o = n.slice(0, 64) + "\n" + n.slice(64, 128) + "\n" + n.slice(128), r = `-----BEGIN PRIVATE KEY for ${this.address}-----
${o}
-----END PRIVATE KEY for ${this.address}-----`;
      fs.writeFile(`${e3}`, r);
    }), this.validateSignature = (e3, t) => utils.validateSignature(e3, t, this.address), this.broadcastTransactions = utils.broadcastTransactions, e2 ? (this.privateKey = e2, this.ready = this.init(e2)) : this.ready = this.init();
  }
  init(e2) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (e2)
          this.address = yield utils.getAddressFromPrivateKey(this.privateKey);
        else {
          const e3 = yield utils.generateKeyPair();
          this.privateKey = e3.privateKey, this.address = e3.address;
        }
        yield this.sync();
      } catch (e3) {
        throw this.address = "", this.balance = 0, this.nonce = 0, console.log(e3), e3;
      }
    });
  }
  getBalance() {
    return this.balance;
  }
  getNonce() {
    return this.nonce;
  }
  getAddress() {
    return this.address;
  }
  sync() {
    var e2, t;
    return __awaiter(this, void 0, void 0, function* () {
      const n = yield fetch(`${utils.getProviders().node}/address/${this.address}`, { method: "GET" }), o = yield n.json();
      this.balance = null !== (e2 = o.data.account.Balance) && void 0 !== e2 ? e2 : 0, this.nonce = null !== (t = o.data.account.Nonce) && void 0 !== t ? t : 0;
    });
  }
  getInfo() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const e2 = yield fetch(`${utils.getProviders().node}/address/${this.address}`, { method: "GET" });
        return (yield e2.json()).data.account;
      } catch (e2) {
        throw e2;
      }
    });
  }
};
var ErrLoadKleverWeb = new Error("No kleverWeb instance found");
var isKleverWebLoaded = () => !!(null === globalThis || void 0 === globalThis ? void 0 : globalThis.kleverWeb);
var isKleverWebActive = () => {
  var e2;
  return !!(null === (e2 = null === globalThis || void 0 === globalThis ? void 0 : globalThis.kleverWeb) || void 0 === e2 ? void 0 : e2.address);
};
var initialize = () => __awaiter(void 0, void 0, void 0, function* () {
  var e2;
  yield null === (e2 = null === globalThis || void 0 === globalThis ? void 0 : globalThis.kleverWeb) || void 0 === e2 ? void 0 : e2.initialize();
});
var getWalletAddress = () => {
  var e2;
  return null === (e2 = null === globalThis || void 0 === globalThis ? void 0 : globalThis.kleverWeb) || void 0 === e2 ? void 0 : e2.getWalletAddress();
};
var getProvider = () => {
  var e2;
  return null === (e2 = null === globalThis || void 0 === globalThis ? void 0 : globalThis.kleverWeb) || void 0 === e2 ? void 0 : e2.getProvider();
};
var setProvider = (e2) => {
  var t;
  null === (t = null === globalThis || void 0 === globalThis ? void 0 : globalThis.kleverWeb) || void 0 === t || t.setProvider(e2);
};
var broadcastTransactions = (e2) => __awaiter(void 0, void 0, void 0, function* () {
  if (!isKleverWebActive())
    throw ErrLoadKleverWeb;
  return yield globalThis.kleverWeb.broadcastTransactions(e2);
});
var signMessage = (e2, t) => __awaiter(void 0, void 0, void 0, function* () {
  var n;
  if (!isKleverWebActive())
    throw ErrLoadKleverWeb;
  const o = JSON.stringify({ message: e2, privateKey: t });
  return yield null === (n = null === globalThis || void 0 === globalThis ? void 0 : globalThis.kleverWeb) || void 0 === n ? void 0 : n.signMessage(o);
});
var signTransaction = (e2) => __awaiter(void 0, void 0, void 0, function* () {
  var t;
  if (!isKleverWebActive())
    throw ErrLoadKleverWeb;
  return yield null === (t = null === globalThis || void 0 === globalThis ? void 0 : globalThis.kleverWeb) || void 0 === t ? void 0 : t.signTransaction(e2);
});
var validateSignature = (e2, t, n) => __awaiter(void 0, void 0, void 0, function* () {
  var o;
  if (!isKleverWebActive())
    throw ErrLoadKleverWeb;
  let r;
  if ("undefined" != typeof window) {
    const a = JSON.stringify({ message: e2, signature: t, publicKey: n });
    r = yield null === (o = null === globalThis || void 0 === globalThis ? void 0 : globalThis.kleverWeb) || void 0 === o ? void 0 : o.validateSignature(a);
  } else {
    if ("undefined" == typeof global)
      throw new Error("neither global nor window is defined");
    r = yield verify(t, e2, n);
  }
  return r;
});
var buildTransaction = (e2, t, n) => __awaiter(void 0, void 0, void 0, function* () {
  var o;
  return null === (o = null === globalThis || void 0 === globalThis ? void 0 : globalThis.kleverWeb) || void 0 === o ? void 0 : o.buildTransaction(e2, t, n);
});
var web = { isKleverWebLoaded, isKleverWebActive, broadcastTransactions, signMessage, signTransaction, validateSignature, buildTransaction, initialize, getWalletAddress, getProvider, setProvider };
var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
function normalizeInput(e2) {
  let t;
  if (e2 instanceof Uint8Array)
    t = e2;
  else {
    if ("string" != typeof e2)
      throw new Error(ERROR_MSG_INPUT);
    t = new TextEncoder().encode(e2);
  }
  return t;
}
function toHex(e2) {
  return Array.prototype.map.call(e2, function(e3) {
    return (e3 < 16 ? "0" : "") + e3.toString(16);
  }).join("");
}
function uint32ToHex(e2) {
  return (4294967296 + e2).toString(16).substring(1);
}
function debugPrint(e2, t, n) {
  let o = "\n" + e2 + " = ";
  for (let r = 0; r < t.length; r += 2) {
    if (32 === n)
      o += uint32ToHex(t[r]).toUpperCase(), o += " ", o += uint32ToHex(t[r + 1]).toUpperCase();
    else {
      if (64 !== n)
        throw new Error("Invalid size " + n);
      o += uint32ToHex(t[r + 1]).toUpperCase(), o += uint32ToHex(t[r]).toUpperCase();
    }
    r % 6 == 4 ? o += "\n" + new Array(e2.length + 4).join(" ") : r < t.length - 2 && (o += " ");
  }
  console.log(o);
}
function testSpeed(e2, t, n) {
  let o = new Date().getTime();
  const r = new Uint8Array(t);
  for (let e3 = 0; e3 < t; e3++)
    r[e3] = e3 % 256;
  const a = new Date().getTime();
  console.log("Generated random input in " + (a - o) + "ms"), o = a;
  for (let a2 = 0; a2 < n; a2++) {
    const n2 = e2(r), a3 = new Date().getTime(), i = a3 - o;
    o = a3, console.log("Hashed in " + i + "ms: " + n2.substring(0, 20) + "..."), console.log(Math.round(t / (1 << 20) / (i / 1e3) * 100) / 100 + " MB PER SECOND");
  }
}
var util$8 = { normalizeInput, toHex, debugPrint, testSpeed };
var util$7 = util$8;
function ADD64AA(e2, t, n) {
  const o = e2[t] + e2[n];
  let r = e2[t + 1] + e2[n + 1];
  o >= 4294967296 && r++, e2[t] = o, e2[t + 1] = r;
}
function ADD64AC(e2, t, n, o) {
  let r = e2[t] + n;
  n < 0 && (r += 4294967296);
  let a = e2[t + 1] + o;
  r >= 4294967296 && a++, e2[t] = r, e2[t + 1] = a;
}
function B2B_GET32(e2, t) {
  return e2[t] ^ e2[t + 1] << 8 ^ e2[t + 2] << 16 ^ e2[t + 3] << 24;
}
function B2B_G(e2, t, n, o, r, a) {
  const i = m$1[r], s = m$1[r + 1], c = m$1[a], d = m$1[a + 1];
  ADD64AA(v$1, e2, t), ADD64AC(v$1, e2, i, s);
  let l = v$1[o] ^ v$1[e2], u = v$1[o + 1] ^ v$1[e2 + 1];
  v$1[o] = u, v$1[o + 1] = l, ADD64AA(v$1, n, o), l = v$1[t] ^ v$1[n], u = v$1[t + 1] ^ v$1[n + 1], v$1[t] = l >>> 24 ^ u << 8, v$1[t + 1] = u >>> 24 ^ l << 8, ADD64AA(v$1, e2, t), ADD64AC(v$1, e2, c, d), l = v$1[o] ^ v$1[e2], u = v$1[o + 1] ^ v$1[e2 + 1], v$1[o] = l >>> 16 ^ u << 16, v$1[o + 1] = u >>> 16 ^ l << 16, ADD64AA(v$1, n, o), l = v$1[t] ^ v$1[n], u = v$1[t + 1] ^ v$1[n + 1], v$1[t] = u >>> 31 ^ l << 1, v$1[t + 1] = l >>> 31 ^ u << 1;
}
var BLAKE2B_IV32 = new Uint32Array([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var SIGMA8 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3];
var SIGMA82 = new Uint8Array(SIGMA8.map(function(e2) {
  return 2 * e2;
}));
var v$1 = new Uint32Array(32);
var m$1 = new Uint32Array(32);
function blake2bCompress(e2, t) {
  let n = 0;
  for (n = 0; n < 16; n++)
    v$1[n] = e2.h[n], v$1[n + 16] = BLAKE2B_IV32[n];
  for (v$1[24] = v$1[24] ^ e2.t, v$1[25] = v$1[25] ^ e2.t / 4294967296, t && (v$1[28] = ~v$1[28], v$1[29] = ~v$1[29]), n = 0; n < 32; n++)
    m$1[n] = B2B_GET32(e2.b, 4 * n);
  for (n = 0; n < 12; n++)
    B2B_G(0, 8, 16, 24, SIGMA82[16 * n + 0], SIGMA82[16 * n + 1]), B2B_G(2, 10, 18, 26, SIGMA82[16 * n + 2], SIGMA82[16 * n + 3]), B2B_G(4, 12, 20, 28, SIGMA82[16 * n + 4], SIGMA82[16 * n + 5]), B2B_G(6, 14, 22, 30, SIGMA82[16 * n + 6], SIGMA82[16 * n + 7]), B2B_G(0, 10, 20, 30, SIGMA82[16 * n + 8], SIGMA82[16 * n + 9]), B2B_G(2, 12, 22, 24, SIGMA82[16 * n + 10], SIGMA82[16 * n + 11]), B2B_G(4, 14, 16, 26, SIGMA82[16 * n + 12], SIGMA82[16 * n + 13]), B2B_G(6, 8, 18, 28, SIGMA82[16 * n + 14], SIGMA82[16 * n + 15]);
  for (n = 0; n < 16; n++)
    e2.h[n] = e2.h[n] ^ v$1[n] ^ v$1[n + 16];
}
var parameterBlock = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
function blake2bInit(e2, t, n, o) {
  if (0 === e2 || e2 > 64)
    throw new Error("Illegal output length, expected 0 < length <= 64");
  if (t && t.length > 64)
    throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
  if (n && 16 !== n.length)
    throw new Error("Illegal salt, expected Uint8Array with length is 16");
  if (o && 16 !== o.length)
    throw new Error("Illegal personal, expected Uint8Array with length is 16");
  const r = { b: new Uint8Array(128), h: new Uint32Array(16), t: 0, c: 0, outlen: e2 };
  parameterBlock.fill(0), parameterBlock[0] = e2, t && (parameterBlock[1] = t.length), parameterBlock[2] = 1, parameterBlock[3] = 1, n && parameterBlock.set(n, 32), o && parameterBlock.set(o, 48);
  for (let e3 = 0; e3 < 16; e3++)
    r.h[e3] = BLAKE2B_IV32[e3] ^ B2B_GET32(parameterBlock, 4 * e3);
  return t && (blake2bUpdate(r, t), r.c = 128), r;
}
function blake2bUpdate(e2, t) {
  for (let n = 0; n < t.length; n++)
    128 === e2.c && (e2.t += e2.c, blake2bCompress(e2, false), e2.c = 0), e2.b[e2.c++] = t[n];
}
function blake2bFinal(e2) {
  for (e2.t += e2.c; e2.c < 128; )
    e2.b[e2.c++] = 0;
  blake2bCompress(e2, true);
  const t = new Uint8Array(e2.outlen);
  for (let n = 0; n < e2.outlen; n++)
    t[n] = e2.h[n >> 2] >> 8 * (3 & n);
  return t;
}
function blake2b(e2, t, n, o, r) {
  n = n || 64, e2 = util$7.normalizeInput(e2), o && (o = util$7.normalizeInput(o)), r && (r = util$7.normalizeInput(r));
  const a = blake2bInit(n, t, o, r);
  return blake2bUpdate(a, e2), blake2bFinal(a);
}
function blake2bHex(e2, t, n, o, r) {
  const a = blake2b(e2, t, n, o, r);
  return util$7.toHex(a);
}
var blake2b_1 = { blake2b, blake2bHex, blake2bInit, blake2bUpdate, blake2bFinal };
var util$6 = util$8;
function B2S_GET32(e2, t) {
  return e2[t] ^ e2[t + 1] << 8 ^ e2[t + 2] << 16 ^ e2[t + 3] << 24;
}
function B2S_G(e2, t, n, o, r, a) {
  v[e2] = v[e2] + v[t] + r, v[o] = ROTR32(v[o] ^ v[e2], 16), v[n] = v[n] + v[o], v[t] = ROTR32(v[t] ^ v[n], 12), v[e2] = v[e2] + v[t] + a, v[o] = ROTR32(v[o] ^ v[e2], 8), v[n] = v[n] + v[o], v[t] = ROTR32(v[t] ^ v[n], 7);
}
function ROTR32(e2, t) {
  return e2 >>> t ^ e2 << 32 - t;
}
var BLAKE2S_IV = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var SIGMA = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0]);
var v = new Uint32Array(16);
var m = new Uint32Array(16);
function blake2sCompress(e2, t) {
  let n = 0;
  for (n = 0; n < 8; n++)
    v[n] = e2.h[n], v[n + 8] = BLAKE2S_IV[n];
  for (v[12] ^= e2.t, v[13] ^= e2.t / 4294967296, t && (v[14] = ~v[14]), n = 0; n < 16; n++)
    m[n] = B2S_GET32(e2.b, 4 * n);
  for (n = 0; n < 10; n++)
    B2S_G(0, 4, 8, 12, m[SIGMA[16 * n + 0]], m[SIGMA[16 * n + 1]]), B2S_G(1, 5, 9, 13, m[SIGMA[16 * n + 2]], m[SIGMA[16 * n + 3]]), B2S_G(2, 6, 10, 14, m[SIGMA[16 * n + 4]], m[SIGMA[16 * n + 5]]), B2S_G(3, 7, 11, 15, m[SIGMA[16 * n + 6]], m[SIGMA[16 * n + 7]]), B2S_G(0, 5, 10, 15, m[SIGMA[16 * n + 8]], m[SIGMA[16 * n + 9]]), B2S_G(1, 6, 11, 12, m[SIGMA[16 * n + 10]], m[SIGMA[16 * n + 11]]), B2S_G(2, 7, 8, 13, m[SIGMA[16 * n + 12]], m[SIGMA[16 * n + 13]]), B2S_G(3, 4, 9, 14, m[SIGMA[16 * n + 14]], m[SIGMA[16 * n + 15]]);
  for (n = 0; n < 8; n++)
    e2.h[n] ^= v[n] ^ v[n + 8];
}
function blake2sInit(e2, t) {
  if (!(e2 > 0 && e2 <= 32))
    throw new Error("Incorrect output length, should be in [1, 32]");
  const n = t ? t.length : 0;
  if (t && !(n > 0 && n <= 32))
    throw new Error("Incorrect key length, should be in [1, 32]");
  const o = { h: new Uint32Array(BLAKE2S_IV), b: new Uint8Array(64), c: 0, t: 0, outlen: e2 };
  return o.h[0] ^= 16842752 ^ n << 8 ^ e2, n > 0 && (blake2sUpdate(o, t), o.c = 64), o;
}
function blake2sUpdate(e2, t) {
  for (let n = 0; n < t.length; n++)
    64 === e2.c && (e2.t += e2.c, blake2sCompress(e2, false), e2.c = 0), e2.b[e2.c++] = t[n];
}
function blake2sFinal(e2) {
  for (e2.t += e2.c; e2.c < 64; )
    e2.b[e2.c++] = 0;
  blake2sCompress(e2, true);
  const t = new Uint8Array(e2.outlen);
  for (let n = 0; n < e2.outlen; n++)
    t[n] = e2.h[n >> 2] >> 8 * (3 & n) & 255;
  return t;
}
function blake2s(e2, t, n) {
  n = n || 32, e2 = util$6.normalizeInput(e2);
  const o = blake2sInit(n, t);
  return blake2sUpdate(o, e2), blake2sFinal(o);
}
function blake2sHex(e2, t, n) {
  const o = blake2s(e2, t, n);
  return util$6.toHex(o);
}
var blake2s_1 = { blake2s, blake2sHex, blake2sInit, blake2sUpdate, blake2sFinal };
var b2b = blake2b_1;
var b2s = blake2s_1;
var blakejs = { blake2b: b2b.blake2b, blake2bHex: b2b.blake2bHex, blake2bInit: b2b.blake2bInit, blake2bUpdate: b2b.blake2bUpdate, blake2bFinal: b2b.blake2bFinal, blake2s: b2s.blake2s, blake2sHex: b2s.blake2sHex, blake2sInit: b2s.blake2sInit, blake2sUpdate: b2s.blake2sUpdate, blake2sFinal: b2s.blake2sFinal };
var long = Long;
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch (e2) {
}
function Long(e2, t, n) {
  this.low = 0 | e2, this.high = 0 | t, this.unsigned = !!n;
}
function isLong(e2) {
  return true === (e2 && e2.__isLong__);
}
Long.prototype.__isLong__, Object.defineProperty(Long.prototype, "__isLong__", { value: true }), Long.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(e2, t) {
  var n, o, r;
  return t ? (r = 0 <= (e2 >>>= 0) && e2 < 256) && (o = UINT_CACHE[e2]) ? o : (n = fromBits(e2, (0 | e2) < 0 ? -1 : 0, true), r && (UINT_CACHE[e2] = n), n) : (r = -128 <= (e2 |= 0) && e2 < 128) && (o = INT_CACHE[e2]) ? o : (n = fromBits(e2, e2 < 0 ? -1 : 0, false), r && (INT_CACHE[e2] = n), n);
}
function fromNumber(e2, t) {
  if (isNaN(e2))
    return t ? UZERO : ZERO;
  if (t) {
    if (e2 < 0)
      return UZERO;
    if (e2 >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (e2 <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (e2 + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  return e2 < 0 ? fromNumber(-e2, t).neg() : fromBits(e2 % TWO_PWR_32_DBL | 0, e2 / TWO_PWR_32_DBL | 0, t);
}
function fromBits(e2, t, n) {
  return new Long(e2, t, n);
}
Long.fromInt = fromInt, Long.fromNumber = fromNumber, Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(e2, t, n) {
  if (0 === e2.length)
    throw Error("empty string");
  if ("NaN" === e2 || "Infinity" === e2 || "+Infinity" === e2 || "-Infinity" === e2)
    return ZERO;
  if ("number" == typeof t ? (n = t, t = false) : t = !!t, (n = n || 10) < 2 || 36 < n)
    throw RangeError("radix");
  var o;
  if ((o = e2.indexOf("-")) > 0)
    throw Error("interior hyphen");
  if (0 === o)
    return fromString(e2.substring(1), t, n).neg();
  for (var r = fromNumber(pow_dbl(n, 8)), a = ZERO, i = 0; i < e2.length; i += 8) {
    var s = Math.min(8, e2.length - i), c = parseInt(e2.substring(i, i + s), n);
    if (s < 8) {
      var d = fromNumber(pow_dbl(n, s));
      a = a.mul(d).add(fromNumber(c));
    } else
      a = (a = a.mul(r)).add(fromNumber(c));
  }
  return a.unsigned = t, a;
}
function fromValue(e2, t) {
  return "number" == typeof e2 ? fromNumber(e2, t) : "string" == typeof e2 ? fromString(e2, t) : fromBits(e2.low, e2.high, "boolean" == typeof t ? t : e2.unsigned);
}
Long.fromString = fromString, Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 65536;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, true);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, true);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(-1, 2147483647, false);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(-1, -1, true);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, -2147483648, false);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
}, LongPrototype.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0) : this.high * TWO_PWR_32_DBL + (this.low >>> 0);
}, LongPrototype.toString = function(e2) {
  if ((e2 = e2 || 10) < 2 || 36 < e2)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var t = fromNumber(e2), n = this.div(t), o = n.mul(t).sub(this);
      return n.toString(e2) + o.toInt().toString(e2);
    }
    return "-" + this.neg().toString(e2);
  }
  for (var r = fromNumber(pow_dbl(e2, 6), this.unsigned), a = this, i = ""; ; ) {
    var s = a.div(r), c = (a.sub(s.mul(r)).toInt() >>> 0).toString(e2);
    if ((a = s).isZero())
      return c + i;
    for (; c.length < 6; )
      c = "0" + c;
    i = "" + c + i;
  }
}, LongPrototype.getHighBits = function() {
  return this.high;
}, LongPrototype.getHighBitsUnsigned = function() {
  return this.high >>> 0;
}, LongPrototype.getLowBits = function() {
  return this.low;
}, LongPrototype.getLowBitsUnsigned = function() {
  return this.low >>> 0;
}, LongPrototype.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  for (var e2 = 0 != this.high ? this.high : this.low, t = 31; t > 0 && 0 == (e2 & 1 << t); t--)
    ;
  return 0 != this.high ? t + 33 : t + 1;
}, LongPrototype.isZero = function() {
  return 0 === this.high && 0 === this.low;
}, LongPrototype.eqz = LongPrototype.isZero, LongPrototype.isNegative = function() {
  return !this.unsigned && this.high < 0;
}, LongPrototype.isPositive = function() {
  return this.unsigned || this.high >= 0;
}, LongPrototype.isOdd = function() {
  return 1 == (1 & this.low);
}, LongPrototype.isEven = function() {
  return 0 == (1 & this.low);
}, LongPrototype.equals = function(e2) {
  return isLong(e2) || (e2 = fromValue(e2)), (this.unsigned === e2.unsigned || this.high >>> 31 != 1 || e2.high >>> 31 != 1) && (this.high === e2.high && this.low === e2.low);
}, LongPrototype.eq = LongPrototype.equals, LongPrototype.notEquals = function(e2) {
  return !this.eq(e2);
}, LongPrototype.neq = LongPrototype.notEquals, LongPrototype.ne = LongPrototype.notEquals, LongPrototype.lessThan = function(e2) {
  return this.comp(e2) < 0;
}, LongPrototype.lt = LongPrototype.lessThan, LongPrototype.lessThanOrEqual = function(e2) {
  return this.comp(e2) <= 0;
}, LongPrototype.lte = LongPrototype.lessThanOrEqual, LongPrototype.le = LongPrototype.lessThanOrEqual, LongPrototype.greaterThan = function(e2) {
  return this.comp(e2) > 0;
}, LongPrototype.gt = LongPrototype.greaterThan, LongPrototype.greaterThanOrEqual = function(e2) {
  return this.comp(e2) >= 0;
}, LongPrototype.gte = LongPrototype.greaterThanOrEqual, LongPrototype.ge = LongPrototype.greaterThanOrEqual, LongPrototype.compare = function(e2) {
  if (isLong(e2) || (e2 = fromValue(e2)), this.eq(e2))
    return 0;
  var t = this.isNegative(), n = e2.isNegative();
  return t && !n ? -1 : !t && n ? 1 : this.unsigned ? e2.high >>> 0 > this.high >>> 0 || e2.high === this.high && e2.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e2).isNegative() ? -1 : 1;
}, LongPrototype.comp = LongPrototype.compare, LongPrototype.negate = function() {
  return !this.unsigned && this.eq(MIN_VALUE) ? MIN_VALUE : this.not().add(ONE);
}, LongPrototype.neg = LongPrototype.negate, LongPrototype.add = function(e2) {
  isLong(e2) || (e2 = fromValue(e2));
  var t = this.high >>> 16, n = 65535 & this.high, o = this.low >>> 16, r = 65535 & this.low, a = e2.high >>> 16, i = 65535 & e2.high, s = e2.low >>> 16, c = 0, d = 0, l = 0, u = 0;
  return l += (u += r + (65535 & e2.low)) >>> 16, d += (l += o + s) >>> 16, c += (d += n + i) >>> 16, c += t + a, fromBits((l &= 65535) << 16 | (u &= 65535), (c &= 65535) << 16 | (d &= 65535), this.unsigned);
}, LongPrototype.subtract = function(e2) {
  return isLong(e2) || (e2 = fromValue(e2)), this.add(e2.neg());
}, LongPrototype.sub = LongPrototype.subtract, LongPrototype.multiply = function(e2) {
  if (this.isZero())
    return ZERO;
  if (isLong(e2) || (e2 = fromValue(e2)), wasm)
    return fromBits(wasm.mul(this.low, this.high, e2.low, e2.high), wasm.get_high(), this.unsigned);
  if (e2.isZero())
    return ZERO;
  if (this.eq(MIN_VALUE))
    return e2.isOdd() ? MIN_VALUE : ZERO;
  if (e2.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative())
    return e2.isNegative() ? this.neg().mul(e2.neg()) : this.neg().mul(e2).neg();
  if (e2.isNegative())
    return this.mul(e2.neg()).neg();
  if (this.lt(TWO_PWR_24) && e2.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * e2.toNumber(), this.unsigned);
  var t = this.high >>> 16, n = 65535 & this.high, o = this.low >>> 16, r = 65535 & this.low, a = e2.high >>> 16, i = 65535 & e2.high, s = e2.low >>> 16, c = 65535 & e2.low, d = 0, l = 0, u = 0, p = 0;
  return u += (p += r * c) >>> 16, l += (u += o * c) >>> 16, u &= 65535, l += (u += r * s) >>> 16, d += (l += n * c) >>> 16, l &= 65535, d += (l += o * s) >>> 16, l &= 65535, d += (l += r * i) >>> 16, d += t * c + n * s + o * i + r * a, fromBits((u &= 65535) << 16 | (p &= 65535), (d &= 65535) << 16 | (l &= 65535), this.unsigned);
}, LongPrototype.mul = LongPrototype.multiply, LongPrototype.divide = function(e2) {
  if (isLong(e2) || (e2 = fromValue(e2)), e2.isZero())
    throw Error("division by zero");
  var t, n, o;
  if (wasm)
    return this.unsigned || -2147483648 !== this.high || -1 !== e2.low || -1 !== e2.high ? fromBits((this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, e2.low, e2.high), wasm.get_high(), this.unsigned) : this;
  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  if (this.unsigned) {
    if (e2.unsigned || (e2 = e2.toUnsigned()), e2.gt(this))
      return UZERO;
    if (e2.gt(this.shru(1)))
      return UONE;
    o = UZERO;
  } else {
    if (this.eq(MIN_VALUE))
      return e2.eq(ONE) || e2.eq(NEG_ONE) ? MIN_VALUE : e2.eq(MIN_VALUE) ? ONE : (t = this.shr(1).div(e2).shl(1)).eq(ZERO) ? e2.isNegative() ? ONE : NEG_ONE : (n = this.sub(e2.mul(t)), o = t.add(n.div(e2)));
    if (e2.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative())
      return e2.isNegative() ? this.neg().div(e2.neg()) : this.neg().div(e2).neg();
    if (e2.isNegative())
      return this.div(e2.neg()).neg();
    o = ZERO;
  }
  for (n = this; n.gte(e2); ) {
    t = Math.max(1, Math.floor(n.toNumber() / e2.toNumber()));
    for (var r = Math.ceil(Math.log(t) / Math.LN2), a = r <= 48 ? 1 : pow_dbl(2, r - 48), i = fromNumber(t), s = i.mul(e2); s.isNegative() || s.gt(n); )
      s = (i = fromNumber(t -= a, this.unsigned)).mul(e2);
    i.isZero() && (i = ONE), o = o.add(i), n = n.sub(s);
  }
  return o;
}, LongPrototype.div = LongPrototype.divide, LongPrototype.modulo = function(e2) {
  return isLong(e2) || (e2 = fromValue(e2)), wasm ? fromBits((this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, e2.low, e2.high), wasm.get_high(), this.unsigned) : this.sub(this.div(e2).mul(e2));
}, LongPrototype.mod = LongPrototype.modulo, LongPrototype.rem = LongPrototype.modulo, LongPrototype.not = function() {
  return fromBits(~this.low, ~this.high, this.unsigned);
}, LongPrototype.and = function(e2) {
  return isLong(e2) || (e2 = fromValue(e2)), fromBits(this.low & e2.low, this.high & e2.high, this.unsigned);
}, LongPrototype.or = function(e2) {
  return isLong(e2) || (e2 = fromValue(e2)), fromBits(this.low | e2.low, this.high | e2.high, this.unsigned);
}, LongPrototype.xor = function(e2) {
  return isLong(e2) || (e2 = fromValue(e2)), fromBits(this.low ^ e2.low, this.high ^ e2.high, this.unsigned);
}, LongPrototype.shiftLeft = function(e2) {
  return isLong(e2) && (e2 = e2.toInt()), 0 == (e2 &= 63) ? this : e2 < 32 ? fromBits(this.low << e2, this.high << e2 | this.low >>> 32 - e2, this.unsigned) : fromBits(0, this.low << e2 - 32, this.unsigned);
}, LongPrototype.shl = LongPrototype.shiftLeft, LongPrototype.shiftRight = function(e2) {
  return isLong(e2) && (e2 = e2.toInt()), 0 == (e2 &= 63) ? this : e2 < 32 ? fromBits(this.low >>> e2 | this.high << 32 - e2, this.high >> e2, this.unsigned) : fromBits(this.high >> e2 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
}, LongPrototype.shr = LongPrototype.shiftRight, LongPrototype.shiftRightUnsigned = function(e2) {
  if (isLong(e2) && (e2 = e2.toInt()), 0 === (e2 &= 63))
    return this;
  var t = this.high;
  return e2 < 32 ? fromBits(this.low >>> e2 | t << 32 - e2, t >>> e2, this.unsigned) : fromBits(32 === e2 ? t : t >>> e2 - 32, 0, this.unsigned);
}, LongPrototype.shru = LongPrototype.shiftRightUnsigned, LongPrototype.shr_u = LongPrototype.shiftRightUnsigned, LongPrototype.toSigned = function() {
  return this.unsigned ? fromBits(this.low, this.high, false) : this;
}, LongPrototype.toUnsigned = function() {
  return this.unsigned ? this : fromBits(this.low, this.high, true);
}, LongPrototype.toBytes = function(e2) {
  return e2 ? this.toBytesLE() : this.toBytesBE();
}, LongPrototype.toBytesLE = function() {
  var e2 = this.high, t = this.low;
  return [255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, 255 & e2, e2 >>> 8 & 255, e2 >>> 16 & 255, e2 >>> 24];
}, LongPrototype.toBytesBE = function() {
  var e2 = this.high, t = this.low;
  return [e2 >>> 24, e2 >>> 16 & 255, e2 >>> 8 & 255, 255 & e2, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, 255 & t];
}, Long.fromBytes = function(e2, t, n) {
  return n ? Long.fromBytesLE(e2, t) : Long.fromBytesBE(e2, t);
}, Long.fromBytesLE = function(e2, t) {
  return new Long(e2[0] | e2[1] << 8 | e2[2] << 16 | e2[3] << 24, e2[4] | e2[5] << 8 | e2[6] << 16 | e2[7] << 24, t);
}, Long.fromBytesBE = function(e2, t) {
  return new Long(e2[4] << 24 | e2[5] << 16 | e2[6] << 8 | e2[7], e2[0] << 24 | e2[1] << 16 | e2[2] << 8 | e2[3], t);
};
var indexMinimal = {};
var minimal$1 = {};
var aspromise = asPromise;
function asPromise(e2, t) {
  for (var n = new Array(arguments.length - 1), o = 0, r = 2, a = true; r < arguments.length; )
    n[o++] = arguments[r++];
  return new Promise(function(r2, i) {
    n[o] = function(e3) {
      if (a)
        if (a = false, e3)
          i(e3);
        else {
          for (var t2 = new Array(arguments.length - 1), n2 = 0; n2 < t2.length; )
            t2[n2++] = arguments[n2];
          r2.apply(null, t2);
        }
    };
    try {
      e2.apply(t || null, n);
    } catch (e3) {
      a && (a = false, i(e3));
    }
  });
}
var base64$1 = {};
!function(e2) {
  var t = base64$1;
  t.length = function(e3) {
    var t2 = e3.length;
    if (!t2)
      return 0;
    for (var n2 = 0; --t2 % 4 > 1 && "=" === e3.charAt(t2); )
      ++n2;
    return Math.ceil(3 * e3.length) / 4 - n2;
  };
  for (var n = new Array(64), o = new Array(123), r = 0; r < 64; )
    o[n[r] = r < 26 ? r + 65 : r < 52 ? r + 71 : r < 62 ? r - 4 : r - 59 | 43] = r++;
  t.encode = function(e3, t2, o2) {
    for (var r2, a2 = null, i = [], s = 0, c = 0; t2 < o2; ) {
      var d = e3[t2++];
      switch (c) {
        case 0:
          i[s++] = n[d >> 2], r2 = (3 & d) << 4, c = 1;
          break;
        case 1:
          i[s++] = n[r2 | d >> 4], r2 = (15 & d) << 2, c = 2;
          break;
        case 2:
          i[s++] = n[r2 | d >> 6], i[s++] = n[63 & d], c = 0;
      }
      s > 8191 && ((a2 || (a2 = [])).push(String.fromCharCode.apply(String, i)), s = 0);
    }
    return c && (i[s++] = n[r2], i[s++] = 61, 1 === c && (i[s++] = 61)), a2 ? (s && a2.push(String.fromCharCode.apply(String, i.slice(0, s))), a2.join("")) : String.fromCharCode.apply(String, i.slice(0, s));
  };
  var a = "invalid encoding";
  t.decode = function(e3, t2, n2) {
    for (var r2, i = n2, s = 0, c = 0; c < e3.length; ) {
      var d = e3.charCodeAt(c++);
      if (61 === d && s > 1)
        break;
      if (void 0 === (d = o[d]))
        throw Error(a);
      switch (s) {
        case 0:
          r2 = d, s = 1;
          break;
        case 1:
          t2[n2++] = r2 << 2 | (48 & d) >> 4, r2 = d, s = 2;
          break;
        case 2:
          t2[n2++] = (15 & r2) << 4 | (60 & d) >> 2, r2 = d, s = 3;
          break;
        case 3:
          t2[n2++] = (3 & r2) << 6 | d, s = 0;
      }
    }
    if (1 === s)
      throw Error(a);
    return n2 - i;
  }, t.test = function(e3) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e3);
  };
}();
var eventemitter = EventEmitter;
function EventEmitter() {
  this._listeners = {};
}
EventEmitter.prototype.on = function(e2, t, n) {
  return (this._listeners[e2] || (this._listeners[e2] = [])).push({ fn: t, ctx: n || this }), this;
}, EventEmitter.prototype.off = function(e2, t) {
  if (void 0 === e2)
    this._listeners = {};
  else if (void 0 === t)
    this._listeners[e2] = [];
  else
    for (var n = this._listeners[e2], o = 0; o < n.length; )
      n[o].fn === t ? n.splice(o, 1) : ++o;
  return this;
}, EventEmitter.prototype.emit = function(e2) {
  var t = this._listeners[e2];
  if (t) {
    for (var n = [], o = 1; o < arguments.length; )
      n.push(arguments[o++]);
    for (o = 0; o < t.length; )
      t[o].fn.apply(t[o++].ctx, n);
  }
  return this;
};
var float = factory(factory);
function factory(e2) {
  return "undefined" != typeof Float32Array ? function() {
    var t = new Float32Array([-0]), n = new Uint8Array(t.buffer), o = 128 === n[3];
    function r(e3, o2, r2) {
      t[0] = e3, o2[r2] = n[0], o2[r2 + 1] = n[1], o2[r2 + 2] = n[2], o2[r2 + 3] = n[3];
    }
    function a(e3, o2, r2) {
      t[0] = e3, o2[r2] = n[3], o2[r2 + 1] = n[2], o2[r2 + 2] = n[1], o2[r2 + 3] = n[0];
    }
    function i(e3, o2) {
      return n[0] = e3[o2], n[1] = e3[o2 + 1], n[2] = e3[o2 + 2], n[3] = e3[o2 + 3], t[0];
    }
    function s(e3, o2) {
      return n[3] = e3[o2], n[2] = e3[o2 + 1], n[1] = e3[o2 + 2], n[0] = e3[o2 + 3], t[0];
    }
    e2.writeFloatLE = o ? r : a, e2.writeFloatBE = o ? a : r, e2.readFloatLE = o ? i : s, e2.readFloatBE = o ? s : i;
  }() : function() {
    function t(e3, t2, n2, o) {
      var r = t2 < 0 ? 1 : 0;
      if (r && (t2 = -t2), 0 === t2)
        e3(1 / t2 > 0 ? 0 : 2147483648, n2, o);
      else if (isNaN(t2))
        e3(2143289344, n2, o);
      else if (t2 > 34028234663852886e22)
        e3((r << 31 | 2139095040) >>> 0, n2, o);
      else if (t2 < 11754943508222875e-54)
        e3((r << 31 | Math.round(t2 / 1401298464324817e-60)) >>> 0, n2, o);
      else {
        var a = Math.floor(Math.log(t2) / Math.LN2);
        e3((r << 31 | a + 127 << 23 | 8388607 & Math.round(t2 * Math.pow(2, -a) * 8388608)) >>> 0, n2, o);
      }
    }
    function n(e3, t2, n2) {
      var o = e3(t2, n2), r = 2 * (o >> 31) + 1, a = o >>> 23 & 255, i = 8388607 & o;
      return 255 === a ? i ? NaN : r * (1 / 0) : 0 === a ? 1401298464324817e-60 * r * i : r * Math.pow(2, a - 150) * (i + 8388608);
    }
    e2.writeFloatLE = t.bind(null, writeUintLE), e2.writeFloatBE = t.bind(null, writeUintBE), e2.readFloatLE = n.bind(null, readUintLE), e2.readFloatBE = n.bind(null, readUintBE);
  }(), "undefined" != typeof Float64Array ? function() {
    var t = new Float64Array([-0]), n = new Uint8Array(t.buffer), o = 128 === n[7];
    function r(e3, o2, r2) {
      t[0] = e3, o2[r2] = n[0], o2[r2 + 1] = n[1], o2[r2 + 2] = n[2], o2[r2 + 3] = n[3], o2[r2 + 4] = n[4], o2[r2 + 5] = n[5], o2[r2 + 6] = n[6], o2[r2 + 7] = n[7];
    }
    function a(e3, o2, r2) {
      t[0] = e3, o2[r2] = n[7], o2[r2 + 1] = n[6], o2[r2 + 2] = n[5], o2[r2 + 3] = n[4], o2[r2 + 4] = n[3], o2[r2 + 5] = n[2], o2[r2 + 6] = n[1], o2[r2 + 7] = n[0];
    }
    function i(e3, o2) {
      return n[0] = e3[o2], n[1] = e3[o2 + 1], n[2] = e3[o2 + 2], n[3] = e3[o2 + 3], n[4] = e3[o2 + 4], n[5] = e3[o2 + 5], n[6] = e3[o2 + 6], n[7] = e3[o2 + 7], t[0];
    }
    function s(e3, o2) {
      return n[7] = e3[o2], n[6] = e3[o2 + 1], n[5] = e3[o2 + 2], n[4] = e3[o2 + 3], n[3] = e3[o2 + 4], n[2] = e3[o2 + 5], n[1] = e3[o2 + 6], n[0] = e3[o2 + 7], t[0];
    }
    e2.writeDoubleLE = o ? r : a, e2.writeDoubleBE = o ? a : r, e2.readDoubleLE = o ? i : s, e2.readDoubleBE = o ? s : i;
  }() : function() {
    function t(e3, t2, n2, o, r, a) {
      var i = o < 0 ? 1 : 0;
      if (i && (o = -o), 0 === o)
        e3(0, r, a + t2), e3(1 / o > 0 ? 0 : 2147483648, r, a + n2);
      else if (isNaN(o))
        e3(0, r, a + t2), e3(2146959360, r, a + n2);
      else if (o > 17976931348623157e292)
        e3(0, r, a + t2), e3((i << 31 | 2146435072) >>> 0, r, a + n2);
      else {
        var s;
        if (o < 22250738585072014e-324)
          e3((s = o / 5e-324) >>> 0, r, a + t2), e3((i << 31 | s / 4294967296) >>> 0, r, a + n2);
        else {
          var c = Math.floor(Math.log(o) / Math.LN2);
          1024 === c && (c = 1023), e3(4503599627370496 * (s = o * Math.pow(2, -c)) >>> 0, r, a + t2), e3((i << 31 | c + 1023 << 20 | 1048576 * s & 1048575) >>> 0, r, a + n2);
        }
      }
    }
    function n(e3, t2, n2, o, r) {
      var a = e3(o, r + t2), i = e3(o, r + n2), s = 2 * (i >> 31) + 1, c = i >>> 20 & 2047, d = 4294967296 * (1048575 & i) + a;
      return 2047 === c ? d ? NaN : s * (1 / 0) : 0 === c ? 5e-324 * s * d : s * Math.pow(2, c - 1075) * (d + 4503599627370496);
    }
    e2.writeDoubleLE = t.bind(null, writeUintLE, 0, 4), e2.writeDoubleBE = t.bind(null, writeUintBE, 4, 0), e2.readDoubleLE = n.bind(null, readUintLE, 0, 4), e2.readDoubleBE = n.bind(null, readUintBE, 4, 0);
  }(), e2;
}
function writeUintLE(e2, t, n) {
  t[n] = 255 & e2, t[n + 1] = e2 >>> 8 & 255, t[n + 2] = e2 >>> 16 & 255, t[n + 3] = e2 >>> 24;
}
function writeUintBE(e2, t, n) {
  t[n] = e2 >>> 24, t[n + 1] = e2 >>> 16 & 255, t[n + 2] = e2 >>> 8 & 255, t[n + 3] = 255 & e2;
}
function readUintLE(e2, t) {
  return (e2[t] | e2[t + 1] << 8 | e2[t + 2] << 16 | e2[t + 3] << 24) >>> 0;
}
function readUintBE(e2, t) {
  return (e2[t] << 24 | e2[t + 1] << 16 | e2[t + 2] << 8 | e2[t + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (e2) {
  }
  return null;
}
var utf8$2 = {};
!function(e2) {
  var t = utf8$2;
  t.length = function(e3) {
    for (var t2 = 0, n = 0, o = 0; o < e3.length; ++o)
      (n = e3.charCodeAt(o)) < 128 ? t2 += 1 : n < 2048 ? t2 += 2 : 55296 == (64512 & n) && 56320 == (64512 & e3.charCodeAt(o + 1)) ? (++o, t2 += 4) : t2 += 3;
    return t2;
  }, t.read = function(e3, t2, n) {
    if (n - t2 < 1)
      return "";
    for (var o, r = null, a = [], i = 0; t2 < n; )
      (o = e3[t2++]) < 128 ? a[i++] = o : o > 191 && o < 224 ? a[i++] = (31 & o) << 6 | 63 & e3[t2++] : o > 239 && o < 365 ? (o = ((7 & o) << 18 | (63 & e3[t2++]) << 12 | (63 & e3[t2++]) << 6 | 63 & e3[t2++]) - 65536, a[i++] = 55296 + (o >> 10), a[i++] = 56320 + (1023 & o)) : a[i++] = (15 & o) << 12 | (63 & e3[t2++]) << 6 | 63 & e3[t2++], i > 8191 && ((r || (r = [])).push(String.fromCharCode.apply(String, a)), i = 0);
    return r ? (i && r.push(String.fromCharCode.apply(String, a.slice(0, i))), r.join("")) : String.fromCharCode.apply(String, a.slice(0, i));
  }, t.write = function(e3, t2, n) {
    for (var o, r, a = n, i = 0; i < e3.length; ++i)
      (o = e3.charCodeAt(i)) < 128 ? t2[n++] = o : o < 2048 ? (t2[n++] = o >> 6 | 192, t2[n++] = 63 & o | 128) : 55296 == (64512 & o) && 56320 == (64512 & (r = e3.charCodeAt(i + 1))) ? (o = 65536 + ((1023 & o) << 10) + (1023 & r), ++i, t2[n++] = o >> 18 | 240, t2[n++] = o >> 12 & 63 | 128, t2[n++] = o >> 6 & 63 | 128, t2[n++] = 63 & o | 128) : (t2[n++] = o >> 12 | 224, t2[n++] = o >> 6 & 63 | 128, t2[n++] = 63 & o | 128);
    return n - a;
  };
}();
var pool_1 = pool;
function pool(e2, t, n) {
  var o = n || 8192, r = o >>> 1, a = null, i = o;
  return function(n2) {
    if (n2 < 1 || n2 > r)
      return e2(n2);
    i + n2 > o && (a = e2(o), i = 0);
    var s = t.call(a, i, i += n2);
    return 7 & i && (i = 1 + (7 | i)), s;
  };
}
var longbits = LongBits$2;
var util$5 = minimal$1;
function LongBits$2(e2, t) {
  this.lo = e2 >>> 0, this.hi = t >>> 0;
}
var zero = LongBits$2.zero = new LongBits$2(0, 0);
zero.toNumber = function() {
  return 0;
}, zero.zzEncode = zero.zzDecode = function() {
  return this;
}, zero.length = function() {
  return 1;
};
var zeroHash = LongBits$2.zeroHash = "\0\0\0\0\0\0\0\0";
LongBits$2.fromNumber = function(e2) {
  if (0 === e2)
    return zero;
  var t = e2 < 0;
  t && (e2 = -e2);
  var n = e2 >>> 0, o = (e2 - n) / 4294967296 >>> 0;
  return t && (o = ~o >>> 0, n = ~n >>> 0, ++n > 4294967295 && (n = 0, ++o > 4294967295 && (o = 0))), new LongBits$2(n, o);
}, LongBits$2.from = function(e2) {
  if ("number" == typeof e2)
    return LongBits$2.fromNumber(e2);
  if (util$5.isString(e2)) {
    if (!util$5.Long)
      return LongBits$2.fromNumber(parseInt(e2, 10));
    e2 = util$5.Long.fromString(e2);
  }
  return e2.low || e2.high ? new LongBits$2(e2.low >>> 0, e2.high >>> 0) : zero;
}, LongBits$2.prototype.toNumber = function(e2) {
  if (!e2 && this.hi >>> 31) {
    var t = 1 + ~this.lo >>> 0, n = ~this.hi >>> 0;
    return t || (n = n + 1 >>> 0), -(t + 4294967296 * n);
  }
  return this.lo + 4294967296 * this.hi;
}, LongBits$2.prototype.toLong = function(e2) {
  return util$5.Long ? new util$5.Long(0 | this.lo, 0 | this.hi, Boolean(e2)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e2) };
};
var charCodeAt = String.prototype.charCodeAt;
LongBits$2.fromHash = function(e2) {
  return e2 === zeroHash ? zero : new LongBits$2((charCodeAt.call(e2, 0) | charCodeAt.call(e2, 1) << 8 | charCodeAt.call(e2, 2) << 16 | charCodeAt.call(e2, 3) << 24) >>> 0, (charCodeAt.call(e2, 4) | charCodeAt.call(e2, 5) << 8 | charCodeAt.call(e2, 6) << 16 | charCodeAt.call(e2, 7) << 24) >>> 0);
}, LongBits$2.prototype.toHash = function() {
  return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
}, LongBits$2.prototype.zzEncode = function() {
  var e2 = this.hi >> 31;
  return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e2) >>> 0, this.lo = (this.lo << 1 ^ e2) >>> 0, this;
}, LongBits$2.prototype.zzDecode = function() {
  var e2 = -(1 & this.lo);
  return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e2) >>> 0, this.hi = (this.hi >>> 1 ^ e2) >>> 0, this;
}, LongBits$2.prototype.length = function() {
  var e2 = this.lo, t = (this.lo >>> 28 | this.hi << 4) >>> 0, n = this.hi >>> 24;
  return 0 === n ? 0 === t ? e2 < 16384 ? e2 < 128 ? 1 : 2 : e2 < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : n < 128 ? 9 : 10;
}, function(e2) {
  var t = minimal$1;
  function n(e3, t2, n2) {
    for (var o2 = Object.keys(t2), r = 0; r < o2.length; ++r)
      void 0 !== e3[o2[r]] && n2 || (e3[o2[r]] = t2[o2[r]]);
    return e3;
  }
  function o(e3) {
    function t2(e4, o2) {
      if (!(this instanceof t2))
        return new t2(e4, o2);
      Object.defineProperty(this, "message", { get: function() {
        return e4;
      } }), Error.captureStackTrace ? Error.captureStackTrace(this, t2) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), o2 && n(this, o2);
    }
    return (t2.prototype = Object.create(Error.prototype)).constructor = t2, Object.defineProperty(t2.prototype, "name", { get: function() {
      return e3;
    } }), t2.prototype.toString = function() {
      return this.name + ": " + this.message;
    }, t2;
  }
  t.asPromise = aspromise, t.base64 = base64$1, t.EventEmitter = eventemitter, t.float = float, t.inquire = inquire_1, t.utf8 = utf8$2, t.pool = pool_1, t.LongBits = longbits, t.isNode = Boolean(void 0 !== commonjsGlobal && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), t.global = t.isNode && commonjsGlobal || "undefined" != typeof window && window || "undefined" != typeof self && self || commonjsGlobal, t.emptyArray = Object.freeze ? Object.freeze([]) : [], t.emptyObject = Object.freeze ? Object.freeze({}) : {}, t.isInteger = Number.isInteger || function(e3) {
    return "number" == typeof e3 && isFinite(e3) && Math.floor(e3) === e3;
  }, t.isString = function(e3) {
    return "string" == typeof e3 || e3 instanceof String;
  }, t.isObject = function(e3) {
    return e3 && "object" == typeof e3;
  }, t.isset = t.isSet = function(e3, t2) {
    var n2 = e3[t2];
    return !(null == n2 || !e3.hasOwnProperty(t2)) && ("object" != typeof n2 || (Array.isArray(n2) ? n2.length : Object.keys(n2).length) > 0);
  }, t.Buffer = function() {
    try {
      var e3 = t.inquire("buffer").Buffer;
      return e3.prototype.utf8Write ? e3 : null;
    } catch (e4) {
      return null;
    }
  }(), t._Buffer_from = null, t._Buffer_allocUnsafe = null, t.newBuffer = function(e3) {
    return "number" == typeof e3 ? t.Buffer ? t._Buffer_allocUnsafe(e3) : new t.Array(e3) : t.Buffer ? t._Buffer_from(e3) : "undefined" == typeof Uint8Array ? e3 : new Uint8Array(e3);
  }, t.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, t.Long = t.global.dcodeIO && t.global.dcodeIO.Long || t.global.Long || t.inquire("long"), t.key2Re = /^true|false|0|1$/, t.key32Re = /^-?(?:0|[1-9][0-9]*)$/, t.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, t.longToHash = function(e3) {
    return e3 ? t.LongBits.from(e3).toHash() : t.LongBits.zeroHash;
  }, t.longFromHash = function(e3, n2) {
    var o2 = t.LongBits.fromHash(e3);
    return t.Long ? t.Long.fromBits(o2.lo, o2.hi, n2) : o2.toNumber(Boolean(n2));
  }, t.merge = n, t.lcFirst = function(e3) {
    return e3.charAt(0).toLowerCase() + e3.substring(1);
  }, t.newError = o, t.ProtocolError = o("ProtocolError"), t.oneOfGetter = function(e3) {
    for (var t2 = {}, n2 = 0; n2 < e3.length; ++n2)
      t2[e3[n2]] = 1;
    return function() {
      for (var e4 = Object.keys(this), n3 = e4.length - 1; n3 > -1; --n3)
        if (1 === t2[e4[n3]] && void 0 !== this[e4[n3]] && null !== this[e4[n3]])
          return e4[n3];
    };
  }, t.oneOfSetter = function(e3) {
    return function(t2) {
      for (var n2 = 0; n2 < e3.length; ++n2)
        e3[n2] !== t2 && delete this[e3[n2]];
    };
  }, t.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, t._configure = function() {
    var e3 = t.Buffer;
    e3 ? (t._Buffer_from = e3.from !== Uint8Array.from && e3.from || function(t2, n2) {
      return new e3(t2, n2);
    }, t._Buffer_allocUnsafe = e3.allocUnsafe || function(t2) {
      return new e3(t2);
    }) : t._Buffer_from = t._Buffer_allocUnsafe = null;
  };
}();
var writer = Writer$1;
var util$4 = minimal$1;
var BufferWriter$1;
var LongBits$1 = util$4.LongBits;
var base64 = util$4.base64;
var utf8$1 = util$4.utf8;
function Op(e2, t, n) {
  this.fn = e2, this.len = t, this.next = void 0, this.val = n;
}
function noop() {
}
function State(e2) {
  this.head = e2.head, this.tail = e2.tail, this.len = e2.len, this.next = e2.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop, 0, 0), this.tail = this.head, this.states = null;
}
var create$1 = function() {
  return util$4.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
function writeByte(e2, t, n) {
  t[n] = 255 & e2;
}
function writeVarint32(e2, t, n) {
  for (; e2 > 127; )
    t[n++] = 127 & e2 | 128, e2 >>>= 7;
  t[n] = e2;
}
function VarintOp(e2, t) {
  this.len = e2, this.next = void 0, this.val = t;
}
function writeVarint64(e2, t, n) {
  for (; e2.hi; )
    t[n++] = 127 & e2.lo | 128, e2.lo = (e2.lo >>> 7 | e2.hi << 25) >>> 0, e2.hi >>>= 7;
  for (; e2.lo > 127; )
    t[n++] = 127 & e2.lo | 128, e2.lo = e2.lo >>> 7;
  t[n++] = e2.lo;
}
function writeFixed32(e2, t, n) {
  t[n] = 255 & e2, t[n + 1] = e2 >>> 8 & 255, t[n + 2] = e2 >>> 16 & 255, t[n + 3] = e2 >>> 24;
}
Writer$1.create = create$1(), Writer$1.alloc = function(e2) {
  return new util$4.Array(e2);
}, util$4.Array !== Array && (Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray)), Writer$1.prototype._push = function(e2, t, n) {
  return this.tail = this.tail.next = new Op(e2, t, n), this.len += t, this;
}, VarintOp.prototype = Object.create(Op.prototype), VarintOp.prototype.fn = writeVarint32, Writer$1.prototype.uint32 = function(e2) {
  return this.len += (this.tail = this.tail.next = new VarintOp((e2 >>>= 0) < 128 ? 1 : e2 < 16384 ? 2 : e2 < 2097152 ? 3 : e2 < 268435456 ? 4 : 5, e2)).len, this;
}, Writer$1.prototype.int32 = function(e2) {
  return e2 < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(e2)) : this.uint32(e2);
}, Writer$1.prototype.sint32 = function(e2) {
  return this.uint32((e2 << 1 ^ e2 >> 31) >>> 0);
}, Writer$1.prototype.uint64 = function(e2) {
  var t = LongBits$1.from(e2);
  return this._push(writeVarint64, t.length(), t);
}, Writer$1.prototype.int64 = Writer$1.prototype.uint64, Writer$1.prototype.sint64 = function(e2) {
  var t = LongBits$1.from(e2).zzEncode();
  return this._push(writeVarint64, t.length(), t);
}, Writer$1.prototype.bool = function(e2) {
  return this._push(writeByte, 1, e2 ? 1 : 0);
}, Writer$1.prototype.fixed32 = function(e2) {
  return this._push(writeFixed32, 4, e2 >>> 0);
}, Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32, Writer$1.prototype.fixed64 = function(e2) {
  var t = LongBits$1.from(e2);
  return this._push(writeFixed32, 4, t.lo)._push(writeFixed32, 4, t.hi);
}, Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64, Writer$1.prototype.float = function(e2) {
  return this._push(util$4.float.writeFloatLE, 4, e2);
}, Writer$1.prototype.double = function(e2) {
  return this._push(util$4.float.writeDoubleLE, 8, e2);
};
var writeBytes = util$4.Array.prototype.set ? function(e2, t, n) {
  t.set(e2, n);
} : function(e2, t, n) {
  for (var o = 0; o < e2.length; ++o)
    t[n + o] = e2[o];
};
Writer$1.prototype.bytes = function(e2) {
  var t = e2.length >>> 0;
  if (!t)
    return this._push(writeByte, 1, 0);
  if (util$4.isString(e2)) {
    var n = Writer$1.alloc(t = base64.length(e2));
    base64.decode(e2, n, 0), e2 = n;
  }
  return this.uint32(t)._push(writeBytes, t, e2);
}, Writer$1.prototype.string = function(e2) {
  var t = utf8$1.length(e2);
  return t ? this.uint32(t)._push(utf8$1.write, t, e2) : this._push(writeByte, 1, 0);
}, Writer$1.prototype.fork = function() {
  return this.states = new State(this), this.head = this.tail = new Op(noop, 0, 0), this.len = 0, this;
}, Writer$1.prototype.reset = function() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop, 0, 0), this.len = 0), this;
}, Writer$1.prototype.ldelim = function() {
  var e2 = this.head, t = this.tail, n = this.len;
  return this.reset().uint32(n), n && (this.tail.next = e2.next, this.tail = t, this.len += n), this;
}, Writer$1.prototype.finish = function() {
  for (var e2 = this.head.next, t = this.constructor.alloc(this.len), n = 0; e2; )
    e2.fn(e2.val, t, n), n += e2.len, e2 = e2.next;
  return t;
}, Writer$1._configure = function(e2) {
  BufferWriter$1 = e2, Writer$1.create = create$1(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter;
var Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$3 = minimal$1;
function BufferWriter() {
  Writer.call(this);
}
function writeStringBuffer(e2, t, n) {
  e2.length < 40 ? util$3.utf8.write(e2, t, n) : t.utf8Write ? t.utf8Write(e2, n) : t.write(e2, n);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$3._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && "set" === util$3.Buffer.prototype.set.name ? function(e2, t, n) {
    t.set(e2, n);
  } : function(e2, t, n) {
    if (e2.copy)
      e2.copy(t, n, 0, e2.length);
    else
      for (var o = 0; o < e2.length; )
        t[n++] = e2[o++];
  };
}, BufferWriter.prototype.bytes = function(e2) {
  util$3.isString(e2) && (e2 = util$3._Buffer_from(e2, "base64"));
  var t = e2.length >>> 0;
  return this.uint32(t), t && this._push(BufferWriter.writeBytesBuffer, t, e2), this;
}, BufferWriter.prototype.string = function(e2) {
  var t = util$3.Buffer.byteLength(e2);
  return this.uint32(t), t && this._push(writeStringBuffer, t, e2), this;
}, BufferWriter._configure();
var reader = Reader$1;
var util$2 = minimal$1;
var BufferReader$1;
var LongBits = util$2.LongBits;
var utf8 = util$2.utf8;
function indexOutOfRange(e2, t) {
  return RangeError("index out of range: " + e2.pos + " + " + (t || 1) + " > " + e2.len);
}
function Reader$1(e2) {
  this.buf = e2, this.pos = 0, this.len = e2.length;
}
var create_array = "undefined" != typeof Uint8Array ? function(e2) {
  if (e2 instanceof Uint8Array || Array.isArray(e2))
    return new Reader$1(e2);
  throw Error("illegal buffer");
} : function(e2) {
  if (Array.isArray(e2))
    return new Reader$1(e2);
  throw Error("illegal buffer");
};
var create = function() {
  return util$2.Buffer ? function(e2) {
    return (Reader$1.create = function(e3) {
      return util$2.Buffer.isBuffer(e3) ? new BufferReader$1(e3) : create_array(e3);
    })(e2);
  } : create_array;
};
var value;
function readLongVarint() {
  var e2 = new LongBits(0, 0), t = 0;
  if (!(this.len - this.pos > 4)) {
    for (; t < 3; ++t) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128)
        return e2;
    }
    return e2.lo = (e2.lo | (127 & this.buf[this.pos++]) << 7 * t) >>> 0, e2;
  }
  for (; t < 4; ++t)
    if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128)
      return e2;
  if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e2.hi = (e2.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128)
    return e2;
  if (t = 0, this.len - this.pos > 4) {
    for (; t < 5; ++t)
      if (e2.hi = (e2.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128)
        return e2;
  } else
    for (; t < 5; ++t) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (e2.hi = (e2.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128)
        return e2;
    }
  throw Error("invalid varint encoding");
}
function readFixed32_end(e2, t) {
  return (e2[t - 4] | e2[t - 3] << 8 | e2[t - 2] << 16 | e2[t - 1] << 24) >>> 0;
}
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.create = create(), Reader$1.prototype._slice = util$2.Array.prototype.subarray || util$2.Array.prototype.slice, Reader$1.prototype.uint32 = (value = 4294967295, function() {
  if (value = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128)
    return value;
  if (value = (value | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128)
    return value;
  if (value = (value | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128)
    return value;
  if (value = (value | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128)
    return value;
  if (value = (value | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128)
    return value;
  if ((this.pos += 5) > this.len)
    throw this.pos = this.len, indexOutOfRange(this, 10);
  return value;
}), Reader$1.prototype.int32 = function() {
  return 0 | this.uint32();
}, Reader$1.prototype.sint32 = function() {
  var e2 = this.uint32();
  return e2 >>> 1 ^ -(1 & e2) | 0;
}, Reader$1.prototype.bool = function() {
  return 0 !== this.uint32();
}, Reader$1.prototype.fixed32 = function() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
}, Reader$1.prototype.sfixed32 = function() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return 0 | readFixed32_end(this.buf, this.pos += 4);
}, Reader$1.prototype.float = function() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var e2 = util$2.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, e2;
}, Reader$1.prototype.double = function() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var e2 = util$2.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, e2;
}, Reader$1.prototype.bytes = function() {
  var e2 = this.uint32(), t = this.pos, n = this.pos + e2;
  if (n > this.len)
    throw indexOutOfRange(this, e2);
  return this.pos += e2, Array.isArray(this.buf) ? this.buf.slice(t, n) : t === n ? new this.buf.constructor(0) : this._slice.call(this.buf, t, n);
}, Reader$1.prototype.string = function() {
  var e2 = this.bytes();
  return utf8.read(e2, 0, e2.length);
}, Reader$1.prototype.skip = function(e2) {
  if ("number" == typeof e2) {
    if (this.pos + e2 > this.len)
      throw indexOutOfRange(this, e2);
    this.pos += e2;
  } else
    do {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    } while (128 & this.buf[this.pos++]);
  return this;
}, Reader$1.prototype.skipType = function(e2) {
  switch (e2) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; 4 != (e2 = 7 & this.uint32()); )
        this.skipType(e2);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + e2 + " at offset " + this.pos);
  }
  return this;
}, Reader$1._configure = function(e2) {
  BufferReader$1 = e2, Reader$1.create = create(), BufferReader$1._configure();
  var t = util$2.Long ? "toLong" : "toNumber";
  util$2.merge(Reader$1.prototype, { int64: function() {
    return readLongVarint.call(this)[t](false);
  }, uint64: function() {
    return readLongVarint.call(this)[t](true);
  }, sint64: function() {
    return readLongVarint.call(this).zzDecode()[t](false);
  }, fixed64: function() {
    return readFixed64.call(this)[t](true);
  }, sfixed64: function() {
    return readFixed64.call(this)[t](false);
  } });
};
var reader_buffer = BufferReader;
var Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$1 = minimal$1;
function BufferReader(e2) {
  Reader.call(this, e2);
}
BufferReader._configure = function() {
  util$1.Buffer && (BufferReader.prototype._slice = util$1.Buffer.prototype.slice);
}, BufferReader.prototype.string = function() {
  var e2 = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e2, this.len));
}, BufferReader._configure();
var rpc = {};
var service = Service;
var util = minimal$1;
var exports;
function Service(e2, t, n) {
  if ("function" != typeof e2)
    throw TypeError("rpcImpl must be a function");
  util.EventEmitter.call(this), this.rpcImpl = e2, this.requestDelimited = Boolean(t), this.responseDelimited = Boolean(n);
}
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service, Service.prototype.rpcCall = function e(t, n, o, r, a) {
  if (!r)
    throw TypeError("request must be specified");
  var i = this;
  if (!a)
    return util.asPromise(e, i, t, n, o, r);
  if (i.rpcImpl)
    try {
      return i.rpcImpl(t, n[i.requestDelimited ? "encodeDelimited" : "encode"](r).finish(), function(e2, n2) {
        if (e2)
          return i.emit("error", e2, t), a(e2);
        if (null !== n2) {
          if (!(n2 instanceof o))
            try {
              n2 = o[i.responseDelimited ? "decodeDelimited" : "decode"](n2);
            } catch (e3) {
              return i.emit("error", e3, t), a(e3);
            }
          return i.emit("data", n2, t), a(null, n2);
        }
        i.end(true);
      });
    } catch (e2) {
      return i.emit("error", e2, t), void setTimeout(function() {
        a(e2);
      }, 0);
    }
  else
    setTimeout(function() {
      a(Error("already ended"));
    }, 0);
}, Service.prototype.end = function(e2) {
  return this.rpcImpl && (e2 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
}, exports = rpc, exports.Service = service;
var roots = {};
!function(e2) {
  var t = indexMinimal;
  function n() {
    t.util._configure(), t.Writer._configure(t.BufferWriter), t.Reader._configure(t.BufferReader);
  }
  t.build = "minimal", t.Writer = writer, t.BufferWriter = writer_buffer, t.Reader = reader, t.BufferReader = reader_buffer, t.util = minimal$1, t.rpc = rpc, t.roots = roots, t.configure = n, n();
}();
var minimal = indexMinimal;
var dist = {};
var descriptor = {};
!function(e2) {
  Object.defineProperty(e2, "__esModule", { value: true }), e2.GeneratedCodeInfo_Annotation = e2.GeneratedCodeInfo = e2.SourceCodeInfo_Location = e2.SourceCodeInfo = e2.UninterpretedOption_NamePart = e2.UninterpretedOption = e2.MethodOptions = e2.ServiceOptions = e2.EnumValueOptions = e2.EnumOptions = e2.OneofOptions = e2.FieldOptions = e2.MessageOptions = e2.FileOptions = e2.MethodDescriptorProto = e2.ServiceDescriptorProto = e2.EnumValueDescriptorProto = e2.EnumDescriptorProto_EnumReservedRange = e2.EnumDescriptorProto = e2.OneofDescriptorProto = e2.FieldDescriptorProto = e2.ExtensionRangeOptions = e2.DescriptorProto_ReservedRange = e2.DescriptorProto_ExtensionRange = e2.DescriptorProto = e2.FileDescriptorProto = e2.FileDescriptorSet = e2.methodOptions_IdempotencyLevelToJSON = e2.methodOptions_IdempotencyLevelFromJSON = e2.MethodOptions_IdempotencyLevel = e2.fieldOptions_JSTypeToJSON = e2.fieldOptions_JSTypeFromJSON = e2.FieldOptions_JSType = e2.fieldOptions_CTypeToJSON = e2.fieldOptions_CTypeFromJSON = e2.FieldOptions_CType = e2.fileOptions_OptimizeModeToJSON = e2.fileOptions_OptimizeModeFromJSON = e2.FileOptions_OptimizeMode = e2.fieldDescriptorProto_LabelToJSON = e2.fieldDescriptorProto_LabelFromJSON = e2.FieldDescriptorProto_Label = e2.fieldDescriptorProto_TypeToJSON = e2.fieldDescriptorProto_TypeFromJSON = e2.FieldDescriptorProto_Type = void 0;
  const t = long, n = minimal;
  var o, r, a, i, s, c;
  function d(e3) {
    switch (e3) {
      case 1:
      case "TYPE_DOUBLE":
        return o.TYPE_DOUBLE;
      case 2:
      case "TYPE_FLOAT":
        return o.TYPE_FLOAT;
      case 3:
      case "TYPE_INT64":
        return o.TYPE_INT64;
      case 4:
      case "TYPE_UINT64":
        return o.TYPE_UINT64;
      case 5:
      case "TYPE_INT32":
        return o.TYPE_INT32;
      case 6:
      case "TYPE_FIXED64":
        return o.TYPE_FIXED64;
      case 7:
      case "TYPE_FIXED32":
        return o.TYPE_FIXED32;
      case 8:
      case "TYPE_BOOL":
        return o.TYPE_BOOL;
      case 9:
      case "TYPE_STRING":
        return o.TYPE_STRING;
      case 10:
      case "TYPE_GROUP":
        return o.TYPE_GROUP;
      case 11:
      case "TYPE_MESSAGE":
        return o.TYPE_MESSAGE;
      case 12:
      case "TYPE_BYTES":
        return o.TYPE_BYTES;
      case 13:
      case "TYPE_UINT32":
        return o.TYPE_UINT32;
      case 14:
      case "TYPE_ENUM":
        return o.TYPE_ENUM;
      case 15:
      case "TYPE_SFIXED32":
        return o.TYPE_SFIXED32;
      case 16:
      case "TYPE_SFIXED64":
        return o.TYPE_SFIXED64;
      case 17:
      case "TYPE_SINT32":
        return o.TYPE_SINT32;
      case 18:
      case "TYPE_SINT64":
        return o.TYPE_SINT64;
      default:
        return o.UNRECOGNIZED;
    }
  }
  function l(e3) {
    switch (e3) {
      case o.TYPE_DOUBLE:
        return "TYPE_DOUBLE";
      case o.TYPE_FLOAT:
        return "TYPE_FLOAT";
      case o.TYPE_INT64:
        return "TYPE_INT64";
      case o.TYPE_UINT64:
        return "TYPE_UINT64";
      case o.TYPE_INT32:
        return "TYPE_INT32";
      case o.TYPE_FIXED64:
        return "TYPE_FIXED64";
      case o.TYPE_FIXED32:
        return "TYPE_FIXED32";
      case o.TYPE_BOOL:
        return "TYPE_BOOL";
      case o.TYPE_STRING:
        return "TYPE_STRING";
      case o.TYPE_GROUP:
        return "TYPE_GROUP";
      case o.TYPE_MESSAGE:
        return "TYPE_MESSAGE";
      case o.TYPE_BYTES:
        return "TYPE_BYTES";
      case o.TYPE_UINT32:
        return "TYPE_UINT32";
      case o.TYPE_ENUM:
        return "TYPE_ENUM";
      case o.TYPE_SFIXED32:
        return "TYPE_SFIXED32";
      case o.TYPE_SFIXED64:
        return "TYPE_SFIXED64";
      case o.TYPE_SINT32:
        return "TYPE_SINT32";
      case o.TYPE_SINT64:
        return "TYPE_SINT64";
      case o.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  function u(e3) {
    switch (e3) {
      case 1:
      case "LABEL_OPTIONAL":
        return r.LABEL_OPTIONAL;
      case 2:
      case "LABEL_REQUIRED":
        return r.LABEL_REQUIRED;
      case 3:
      case "LABEL_REPEATED":
        return r.LABEL_REPEATED;
      default:
        return r.UNRECOGNIZED;
    }
  }
  function p(e3) {
    switch (e3) {
      case r.LABEL_OPTIONAL:
        return "LABEL_OPTIONAL";
      case r.LABEL_REQUIRED:
        return "LABEL_REQUIRED";
      case r.LABEL_REPEATED:
        return "LABEL_REPEATED";
      case r.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  function m2(e3) {
    switch (e3) {
      case 1:
      case "SPEED":
        return a.SPEED;
      case 2:
      case "CODE_SIZE":
        return a.CODE_SIZE;
      case 3:
      case "LITE_RUNTIME":
        return a.LITE_RUNTIME;
      default:
        return a.UNRECOGNIZED;
    }
  }
  function f(e3) {
    switch (e3) {
      case a.SPEED:
        return "SPEED";
      case a.CODE_SIZE:
        return "CODE_SIZE";
      case a.LITE_RUNTIME:
        return "LITE_RUNTIME";
      case a.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  function y(e3) {
    switch (e3) {
      case 0:
      case "STRING":
        return i.STRING;
      case 1:
      case "CORD":
        return i.CORD;
      case 2:
      case "STRING_PIECE":
        return i.STRING_PIECE;
      default:
        return i.UNRECOGNIZED;
    }
  }
  function v2(e3) {
    switch (e3) {
      case i.STRING:
        return "STRING";
      case i.CORD:
        return "CORD";
      case i.STRING_PIECE:
        return "STRING_PIECE";
      case i.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  function g(e3) {
    switch (e3) {
      case 0:
      case "JS_NORMAL":
        return s.JS_NORMAL;
      case 1:
      case "JS_STRING":
        return s.JS_STRING;
      case 2:
      case "JS_NUMBER":
        return s.JS_NUMBER;
      default:
        return s.UNRECOGNIZED;
    }
  }
  function T(e3) {
    switch (e3) {
      case s.JS_NORMAL:
        return "JS_NORMAL";
      case s.JS_STRING:
        return "JS_STRING";
      case s.JS_NUMBER:
        return "JS_NUMBER";
      case s.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  function C(e3) {
    switch (e3) {
      case 0:
      case "IDEMPOTENCY_UNKNOWN":
        return c.IDEMPOTENCY_UNKNOWN;
      case 1:
      case "NO_SIDE_EFFECTS":
        return c.NO_SIDE_EFFECTS;
      case 2:
      case "IDEMPOTENT":
        return c.IDEMPOTENT;
      default:
        return c.UNRECOGNIZED;
    }
  }
  function h(e3) {
    switch (e3) {
      case c.IDEMPOTENCY_UNKNOWN:
        return "IDEMPOTENCY_UNKNOWN";
      case c.NO_SIDE_EFFECTS:
        return "NO_SIDE_EFFECTS";
      case c.IDEMPOTENT:
        return "IDEMPOTENT";
      case c.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  function b() {
    return { name: [], identifierValue: "", positiveIntValue: 0, negativeIntValue: 0, doubleValue: 0, stringValue: new Uint8Array(), aggregateValue: "" };
  }
  !function(e3) {
    e3[e3.TYPE_DOUBLE = 1] = "TYPE_DOUBLE", e3[e3.TYPE_FLOAT = 2] = "TYPE_FLOAT", e3[e3.TYPE_INT64 = 3] = "TYPE_INT64", e3[e3.TYPE_UINT64 = 4] = "TYPE_UINT64", e3[e3.TYPE_INT32 = 5] = "TYPE_INT32", e3[e3.TYPE_FIXED64 = 6] = "TYPE_FIXED64", e3[e3.TYPE_FIXED32 = 7] = "TYPE_FIXED32", e3[e3.TYPE_BOOL = 8] = "TYPE_BOOL", e3[e3.TYPE_STRING = 9] = "TYPE_STRING", e3[e3.TYPE_GROUP = 10] = "TYPE_GROUP", e3[e3.TYPE_MESSAGE = 11] = "TYPE_MESSAGE", e3[e3.TYPE_BYTES = 12] = "TYPE_BYTES", e3[e3.TYPE_UINT32 = 13] = "TYPE_UINT32", e3[e3.TYPE_ENUM = 14] = "TYPE_ENUM", e3[e3.TYPE_SFIXED32 = 15] = "TYPE_SFIXED32", e3[e3.TYPE_SFIXED64 = 16] = "TYPE_SFIXED64", e3[e3.TYPE_SINT32 = 17] = "TYPE_SINT32", e3[e3.TYPE_SINT64 = 18] = "TYPE_SINT64", e3[e3.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  }(o = e2.FieldDescriptorProto_Type || (e2.FieldDescriptorProto_Type = {})), e2.fieldDescriptorProto_TypeFromJSON = d, e2.fieldDescriptorProto_TypeToJSON = l, function(e3) {
    e3[e3.LABEL_OPTIONAL = 1] = "LABEL_OPTIONAL", e3[e3.LABEL_REQUIRED = 2] = "LABEL_REQUIRED", e3[e3.LABEL_REPEATED = 3] = "LABEL_REPEATED", e3[e3.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  }(r = e2.FieldDescriptorProto_Label || (e2.FieldDescriptorProto_Label = {})), e2.fieldDescriptorProto_LabelFromJSON = u, e2.fieldDescriptorProto_LabelToJSON = p, function(e3) {
    e3[e3.SPEED = 1] = "SPEED", e3[e3.CODE_SIZE = 2] = "CODE_SIZE", e3[e3.LITE_RUNTIME = 3] = "LITE_RUNTIME", e3[e3.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  }(a = e2.FileOptions_OptimizeMode || (e2.FileOptions_OptimizeMode = {})), e2.fileOptions_OptimizeModeFromJSON = m2, e2.fileOptions_OptimizeModeToJSON = f, function(e3) {
    e3[e3.STRING = 0] = "STRING", e3[e3.CORD = 1] = "CORD", e3[e3.STRING_PIECE = 2] = "STRING_PIECE", e3[e3.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  }(i = e2.FieldOptions_CType || (e2.FieldOptions_CType = {})), e2.fieldOptions_CTypeFromJSON = y, e2.fieldOptions_CTypeToJSON = v2, function(e3) {
    e3[e3.JS_NORMAL = 0] = "JS_NORMAL", e3[e3.JS_STRING = 1] = "JS_STRING", e3[e3.JS_NUMBER = 2] = "JS_NUMBER", e3[e3.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  }(s = e2.FieldOptions_JSType || (e2.FieldOptions_JSType = {})), e2.fieldOptions_JSTypeFromJSON = g, e2.fieldOptions_JSTypeToJSON = T, function(e3) {
    e3[e3.IDEMPOTENCY_UNKNOWN = 0] = "IDEMPOTENCY_UNKNOWN", e3[e3.NO_SIDE_EFFECTS = 1] = "NO_SIDE_EFFECTS", e3[e3.IDEMPOTENT = 2] = "IDEMPOTENT", e3[e3.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  }(c = e2.MethodOptions_IdempotencyLevel || (e2.MethodOptions_IdempotencyLevel = {})), e2.methodOptions_IdempotencyLevelFromJSON = C, e2.methodOptions_IdempotencyLevelToJSON = h, e2.FileDescriptorSet = { encode(t2, o2 = n.Writer.create()) {
    for (const n2 of t2.file)
      e2.FileDescriptorProto.encode(n2, o2.uint32(10).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ file: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      if (t3 >>> 3 == 1)
        i2.file.push(e2.FileDescriptorProto.decode(r2, r2.uint32()));
      else {
        const e3 = r2.pos;
        r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(e3, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ file: Array.isArray(null == t2 ? void 0 : t2.file) ? t2.file.map((t3) => e2.FileDescriptorProto.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return t2.file ? n2.file = t2.file.map((t3) => t3 ? e2.FileDescriptorProto.toJSON(t3) : void 0) : n2.file = [], n2;
  }, fromPartial(t2) {
    var n2;
    const o2 = /* @__PURE__ */ Object.create({ file: [] });
    return o2.file = (null === (n2 = t2.file) || void 0 === n2 ? void 0 : n2.map((t3) => e2.FileDescriptorProto.fromPartial(t3))) || [], o2;
  } }, e2.FileDescriptorProto = { encode(t2, o2 = n.Writer.create()) {
    "" !== t2.name && o2.uint32(10).string(t2.name), "" !== t2.package && o2.uint32(18).string(t2.package);
    for (const e3 of t2.dependency)
      o2.uint32(26).string(e3);
    o2.uint32(82).fork();
    for (const e3 of t2.publicDependency)
      o2.int32(e3);
    o2.ldelim(), o2.uint32(90).fork();
    for (const e3 of t2.weakDependency)
      o2.int32(e3);
    o2.ldelim();
    for (const n2 of t2.messageType)
      e2.DescriptorProto.encode(n2, o2.uint32(34).fork()).ldelim();
    for (const n2 of t2.enumType)
      e2.EnumDescriptorProto.encode(n2, o2.uint32(42).fork()).ldelim();
    for (const n2 of t2.service)
      e2.ServiceDescriptorProto.encode(n2, o2.uint32(50).fork()).ldelim();
    for (const n2 of t2.extension)
      e2.FieldDescriptorProto.encode(n2, o2.uint32(58).fork()).ldelim();
    if (void 0 !== t2.options && e2.FileOptions.encode(t2.options, o2.uint32(66).fork()).ldelim(), void 0 !== t2.sourceCodeInfo && e2.SourceCodeInfo.encode(t2.sourceCodeInfo, o2.uint32(74).fork()).ldelim(), "" !== t2.syntax && o2.uint32(98).string(t2.syntax), "_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ name: "", package: "", dependency: [], publicDependency: [], weakDependency: [], messageType: [], enumType: [], service: [], extension: [], options: void 0, sourceCodeInfo: void 0, syntax: "" });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.name = r2.string();
          break;
        case 2:
          i2.package = r2.string();
          break;
        case 3:
          i2.dependency.push(r2.string());
          break;
        case 10:
          if (2 == (7 & t3)) {
            const e3 = r2.uint32() + r2.pos;
            for (; r2.pos < e3; )
              i2.publicDependency.push(r2.int32());
          } else
            i2.publicDependency.push(r2.int32());
          break;
        case 11:
          if (2 == (7 & t3)) {
            const e3 = r2.uint32() + r2.pos;
            for (; r2.pos < e3; )
              i2.weakDependency.push(r2.int32());
          } else
            i2.weakDependency.push(r2.int32());
          break;
        case 4:
          i2.messageType.push(e2.DescriptorProto.decode(r2, r2.uint32()));
          break;
        case 5:
          i2.enumType.push(e2.EnumDescriptorProto.decode(r2, r2.uint32()));
          break;
        case 6:
          i2.service.push(e2.ServiceDescriptorProto.decode(r2, r2.uint32()));
          break;
        case 7:
          i2.extension.push(e2.FieldDescriptorProto.decode(r2, r2.uint32()));
          break;
        case 8:
          i2.options = e2.FileOptions.decode(r2, r2.uint32());
          break;
        case 9:
          i2.sourceCodeInfo = e2.SourceCodeInfo.decode(r2, r2.uint32());
          break;
        case 12:
          i2.syntax = r2.string();
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ name: P(t2.name) ? String(t2.name) : "", package: P(t2.package) ? String(t2.package) : "", dependency: Array.isArray(null == t2 ? void 0 : t2.dependency) ? t2.dependency.map((e3) => String(e3)) : [], publicDependency: Array.isArray(null == t2 ? void 0 : t2.publicDependency) ? t2.publicDependency.map((e3) => Number(e3)) : [], weakDependency: Array.isArray(null == t2 ? void 0 : t2.weakDependency) ? t2.weakDependency.map((e3) => Number(e3)) : [], messageType: Array.isArray(null == t2 ? void 0 : t2.messageType) ? t2.messageType.map((t3) => e2.DescriptorProto.fromJSON(t3)) : [], enumType: Array.isArray(null == t2 ? void 0 : t2.enumType) ? t2.enumType.map((t3) => e2.EnumDescriptorProto.fromJSON(t3)) : [], service: Array.isArray(null == t2 ? void 0 : t2.service) ? t2.service.map((t3) => e2.ServiceDescriptorProto.fromJSON(t3)) : [], extension: Array.isArray(null == t2 ? void 0 : t2.extension) ? t2.extension.map((t3) => e2.FieldDescriptorProto.fromJSON(t3)) : [], options: P(t2.options) ? e2.FileOptions.fromJSON(t2.options) : void 0, sourceCodeInfo: P(t2.sourceCodeInfo) ? e2.SourceCodeInfo.fromJSON(t2.sourceCodeInfo) : void 0, syntax: P(t2.syntax) ? String(t2.syntax) : "" }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.name && (n2.name = t2.name), void 0 !== t2.package && (n2.package = t2.package), t2.dependency ? n2.dependency = t2.dependency.map((e3) => e3) : n2.dependency = [], t2.publicDependency ? n2.publicDependency = t2.publicDependency.map((e3) => Math.round(e3)) : n2.publicDependency = [], t2.weakDependency ? n2.weakDependency = t2.weakDependency.map((e3) => Math.round(e3)) : n2.weakDependency = [], t2.messageType ? n2.messageType = t2.messageType.map((t3) => t3 ? e2.DescriptorProto.toJSON(t3) : void 0) : n2.messageType = [], t2.enumType ? n2.enumType = t2.enumType.map((t3) => t3 ? e2.EnumDescriptorProto.toJSON(t3) : void 0) : n2.enumType = [], t2.service ? n2.service = t2.service.map((t3) => t3 ? e2.ServiceDescriptorProto.toJSON(t3) : void 0) : n2.service = [], t2.extension ? n2.extension = t2.extension.map((t3) => t3 ? e2.FieldDescriptorProto.toJSON(t3) : void 0) : n2.extension = [], void 0 !== t2.options && (n2.options = t2.options ? e2.FileOptions.toJSON(t2.options) : void 0), void 0 !== t2.sourceCodeInfo && (n2.sourceCodeInfo = t2.sourceCodeInfo ? e2.SourceCodeInfo.toJSON(t2.sourceCodeInfo) : void 0), void 0 !== t2.syntax && (n2.syntax = t2.syntax), n2;
  }, fromPartial(t2) {
    var n2, o2, r2, a2, i2, s2, c2, d2, l2, u2;
    const p2 = /* @__PURE__ */ Object.create({ name: "", package: "", dependency: [], publicDependency: [], weakDependency: [], messageType: [], enumType: [], service: [], extension: [], options: void 0, sourceCodeInfo: void 0, syntax: "" });
    return p2.name = null !== (n2 = t2.name) && void 0 !== n2 ? n2 : "", p2.package = null !== (o2 = t2.package) && void 0 !== o2 ? o2 : "", p2.dependency = (null === (r2 = t2.dependency) || void 0 === r2 ? void 0 : r2.map((e3) => e3)) || [], p2.publicDependency = (null === (a2 = t2.publicDependency) || void 0 === a2 ? void 0 : a2.map((e3) => e3)) || [], p2.weakDependency = (null === (i2 = t2.weakDependency) || void 0 === i2 ? void 0 : i2.map((e3) => e3)) || [], p2.messageType = (null === (s2 = t2.messageType) || void 0 === s2 ? void 0 : s2.map((t3) => e2.DescriptorProto.fromPartial(t3))) || [], p2.enumType = (null === (c2 = t2.enumType) || void 0 === c2 ? void 0 : c2.map((t3) => e2.EnumDescriptorProto.fromPartial(t3))) || [], p2.service = (null === (d2 = t2.service) || void 0 === d2 ? void 0 : d2.map((t3) => e2.ServiceDescriptorProto.fromPartial(t3))) || [], p2.extension = (null === (l2 = t2.extension) || void 0 === l2 ? void 0 : l2.map((t3) => e2.FieldDescriptorProto.fromPartial(t3))) || [], p2.options = void 0 !== t2.options && null !== t2.options ? e2.FileOptions.fromPartial(t2.options) : void 0, p2.sourceCodeInfo = void 0 !== t2.sourceCodeInfo && null !== t2.sourceCodeInfo ? e2.SourceCodeInfo.fromPartial(t2.sourceCodeInfo) : void 0, p2.syntax = null !== (u2 = t2.syntax) && void 0 !== u2 ? u2 : "", p2;
  } }, e2.DescriptorProto = { encode(t2, o2 = n.Writer.create()) {
    "" !== t2.name && o2.uint32(10).string(t2.name);
    for (const n2 of t2.field)
      e2.FieldDescriptorProto.encode(n2, o2.uint32(18).fork()).ldelim();
    for (const n2 of t2.extension)
      e2.FieldDescriptorProto.encode(n2, o2.uint32(50).fork()).ldelim();
    for (const n2 of t2.nestedType)
      e2.DescriptorProto.encode(n2, o2.uint32(26).fork()).ldelim();
    for (const n2 of t2.enumType)
      e2.EnumDescriptorProto.encode(n2, o2.uint32(34).fork()).ldelim();
    for (const n2 of t2.extensionRange)
      e2.DescriptorProto_ExtensionRange.encode(n2, o2.uint32(42).fork()).ldelim();
    for (const n2 of t2.oneofDecl)
      e2.OneofDescriptorProto.encode(n2, o2.uint32(66).fork()).ldelim();
    void 0 !== t2.options && e2.MessageOptions.encode(t2.options, o2.uint32(58).fork()).ldelim();
    for (const n2 of t2.reservedRange)
      e2.DescriptorProto_ReservedRange.encode(n2, o2.uint32(74).fork()).ldelim();
    for (const e3 of t2.reservedName)
      o2.uint32(82).string(e3);
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ name: "", field: [], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.name = r2.string();
          break;
        case 2:
          i2.field.push(e2.FieldDescriptorProto.decode(r2, r2.uint32()));
          break;
        case 6:
          i2.extension.push(e2.FieldDescriptorProto.decode(r2, r2.uint32()));
          break;
        case 3:
          i2.nestedType.push(e2.DescriptorProto.decode(r2, r2.uint32()));
          break;
        case 4:
          i2.enumType.push(e2.EnumDescriptorProto.decode(r2, r2.uint32()));
          break;
        case 5:
          i2.extensionRange.push(e2.DescriptorProto_ExtensionRange.decode(r2, r2.uint32()));
          break;
        case 8:
          i2.oneofDecl.push(e2.OneofDescriptorProto.decode(r2, r2.uint32()));
          break;
        case 7:
          i2.options = e2.MessageOptions.decode(r2, r2.uint32());
          break;
        case 9:
          i2.reservedRange.push(e2.DescriptorProto_ReservedRange.decode(r2, r2.uint32()));
          break;
        case 10:
          i2.reservedName.push(r2.string());
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ name: P(t2.name) ? String(t2.name) : "", field: Array.isArray(null == t2 ? void 0 : t2.field) ? t2.field.map((t3) => e2.FieldDescriptorProto.fromJSON(t3)) : [], extension: Array.isArray(null == t2 ? void 0 : t2.extension) ? t2.extension.map((t3) => e2.FieldDescriptorProto.fromJSON(t3)) : [], nestedType: Array.isArray(null == t2 ? void 0 : t2.nestedType) ? t2.nestedType.map((t3) => e2.DescriptorProto.fromJSON(t3)) : [], enumType: Array.isArray(null == t2 ? void 0 : t2.enumType) ? t2.enumType.map((t3) => e2.EnumDescriptorProto.fromJSON(t3)) : [], extensionRange: Array.isArray(null == t2 ? void 0 : t2.extensionRange) ? t2.extensionRange.map((t3) => e2.DescriptorProto_ExtensionRange.fromJSON(t3)) : [], oneofDecl: Array.isArray(null == t2 ? void 0 : t2.oneofDecl) ? t2.oneofDecl.map((t3) => e2.OneofDescriptorProto.fromJSON(t3)) : [], options: P(t2.options) ? e2.MessageOptions.fromJSON(t2.options) : void 0, reservedRange: Array.isArray(null == t2 ? void 0 : t2.reservedRange) ? t2.reservedRange.map((t3) => e2.DescriptorProto_ReservedRange.fromJSON(t3)) : [], reservedName: Array.isArray(null == t2 ? void 0 : t2.reservedName) ? t2.reservedName.map((e3) => String(e3)) : [] }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.name && (n2.name = t2.name), t2.field ? n2.field = t2.field.map((t3) => t3 ? e2.FieldDescriptorProto.toJSON(t3) : void 0) : n2.field = [], t2.extension ? n2.extension = t2.extension.map((t3) => t3 ? e2.FieldDescriptorProto.toJSON(t3) : void 0) : n2.extension = [], t2.nestedType ? n2.nestedType = t2.nestedType.map((t3) => t3 ? e2.DescriptorProto.toJSON(t3) : void 0) : n2.nestedType = [], t2.enumType ? n2.enumType = t2.enumType.map((t3) => t3 ? e2.EnumDescriptorProto.toJSON(t3) : void 0) : n2.enumType = [], t2.extensionRange ? n2.extensionRange = t2.extensionRange.map((t3) => t3 ? e2.DescriptorProto_ExtensionRange.toJSON(t3) : void 0) : n2.extensionRange = [], t2.oneofDecl ? n2.oneofDecl = t2.oneofDecl.map((t3) => t3 ? e2.OneofDescriptorProto.toJSON(t3) : void 0) : n2.oneofDecl = [], void 0 !== t2.options && (n2.options = t2.options ? e2.MessageOptions.toJSON(t2.options) : void 0), t2.reservedRange ? n2.reservedRange = t2.reservedRange.map((t3) => t3 ? e2.DescriptorProto_ReservedRange.toJSON(t3) : void 0) : n2.reservedRange = [], t2.reservedName ? n2.reservedName = t2.reservedName.map((e3) => e3) : n2.reservedName = [], n2;
  }, fromPartial(t2) {
    var n2, o2, r2, a2, i2, s2, c2, d2, l2;
    const u2 = /* @__PURE__ */ Object.create({ name: "", field: [], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] });
    return u2.name = null !== (n2 = t2.name) && void 0 !== n2 ? n2 : "", u2.field = (null === (o2 = t2.field) || void 0 === o2 ? void 0 : o2.map((t3) => e2.FieldDescriptorProto.fromPartial(t3))) || [], u2.extension = (null === (r2 = t2.extension) || void 0 === r2 ? void 0 : r2.map((t3) => e2.FieldDescriptorProto.fromPartial(t3))) || [], u2.nestedType = (null === (a2 = t2.nestedType) || void 0 === a2 ? void 0 : a2.map((t3) => e2.DescriptorProto.fromPartial(t3))) || [], u2.enumType = (null === (i2 = t2.enumType) || void 0 === i2 ? void 0 : i2.map((t3) => e2.EnumDescriptorProto.fromPartial(t3))) || [], u2.extensionRange = (null === (s2 = t2.extensionRange) || void 0 === s2 ? void 0 : s2.map((t3) => e2.DescriptorProto_ExtensionRange.fromPartial(t3))) || [], u2.oneofDecl = (null === (c2 = t2.oneofDecl) || void 0 === c2 ? void 0 : c2.map((t3) => e2.OneofDescriptorProto.fromPartial(t3))) || [], u2.options = void 0 !== t2.options && null !== t2.options ? e2.MessageOptions.fromPartial(t2.options) : void 0, u2.reservedRange = (null === (d2 = t2.reservedRange) || void 0 === d2 ? void 0 : d2.map((t3) => e2.DescriptorProto_ReservedRange.fromPartial(t3))) || [], u2.reservedName = (null === (l2 = t2.reservedName) || void 0 === l2 ? void 0 : l2.map((e3) => e3)) || [], u2;
  } }, e2.DescriptorProto_ExtensionRange = { encode(t2, o2 = n.Writer.create()) {
    if (0 !== t2.start && o2.uint32(8).int32(t2.start), 0 !== t2.end && o2.uint32(16).int32(t2.end), void 0 !== t2.options && e2.ExtensionRangeOptions.encode(t2.options, o2.uint32(26).fork()).ldelim(), "_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ start: 0, end: 0, options: void 0 });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.start = r2.int32();
          break;
        case 2:
          i2.end = r2.int32();
          break;
        case 3:
          i2.options = e2.ExtensionRangeOptions.decode(r2, r2.uint32());
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ start: P(t2.start) ? Number(t2.start) : 0, end: P(t2.end) ? Number(t2.end) : 0, options: P(t2.options) ? e2.ExtensionRangeOptions.fromJSON(t2.options) : void 0 }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.start && (n2.start = Math.round(t2.start)), void 0 !== t2.end && (n2.end = Math.round(t2.end)), void 0 !== t2.options && (n2.options = t2.options ? e2.ExtensionRangeOptions.toJSON(t2.options) : void 0), n2;
  }, fromPartial(t2) {
    var n2, o2;
    const r2 = /* @__PURE__ */ Object.create({ start: 0, end: 0, options: void 0 });
    return r2.start = null !== (n2 = t2.start) && void 0 !== n2 ? n2 : 0, r2.end = null !== (o2 = t2.end) && void 0 !== o2 ? o2 : 0, r2.options = void 0 !== t2.options && null !== t2.options ? e2.ExtensionRangeOptions.fromPartial(t2.options) : void 0, r2;
  } }, e2.DescriptorProto_ReservedRange = { encode(e3, t2 = n.Writer.create()) {
    if (0 !== e3.start && t2.uint32(8).int32(e3.start), 0 !== e3.end && t2.uint32(16).int32(e3.end), "_unknownFields" in e3) {
      const n2 = e3._unknownFields;
      for (const e4 of Object.keys(n2)) {
        const o2 = n2[e4];
        for (const n3 of o2)
          t2.uint32(parseInt(e4, 10)), t2._push((e5, t3, n4) => t3.set(e5, n4), n3.length, n3);
      }
    }
    return t2;
  }, decode(e3, t2) {
    const o2 = e3 instanceof n.Reader ? e3 : new n.Reader(e3);
    let r2 = void 0 === t2 ? o2.len : o2.pos + t2;
    const a2 = /* @__PURE__ */ Object.create({ start: 0, end: 0 });
    for (a2._unknownFields = {}; o2.pos < r2; ) {
      const e4 = o2.uint32();
      switch (e4 >>> 3) {
        case 1:
          a2.start = o2.int32();
          break;
        case 2:
          a2.end = o2.int32();
          break;
        default:
          const t3 = o2.pos;
          o2.skipType(7 & e4), a2._unknownFields[e4] = [...a2._unknownFields[e4] || [], o2.buf.slice(t3, o2.pos)];
      }
    }
    return a2;
  }, fromJSON: (e3) => ({ start: P(e3.start) ? Number(e3.start) : 0, end: P(e3.end) ? Number(e3.end) : 0 }), toJSON(e3) {
    const t2 = {};
    return void 0 !== e3.start && (t2.start = Math.round(e3.start)), void 0 !== e3.end && (t2.end = Math.round(e3.end)), t2;
  }, fromPartial(e3) {
    var t2, n2;
    const o2 = /* @__PURE__ */ Object.create({ start: 0, end: 0 });
    return o2.start = null !== (t2 = e3.start) && void 0 !== t2 ? t2 : 0, o2.end = null !== (n2 = e3.end) && void 0 !== n2 ? n2 : 0, o2;
  } }, e2.ExtensionRangeOptions = { encode(t2, o2 = n.Writer.create()) {
    for (const n2 of t2.uninterpretedOption)
      e2.UninterpretedOption.encode(n2, o2.uint32(7994).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ uninterpretedOption: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      if (t3 >>> 3 == 999)
        i2.uninterpretedOption.push(e2.UninterpretedOption.decode(r2, r2.uint32()));
      else {
        const e3 = r2.pos;
        r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(e3, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ uninterpretedOption: Array.isArray(null == t2 ? void 0 : t2.uninterpretedOption) ? t2.uninterpretedOption.map((t3) => e2.UninterpretedOption.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return t2.uninterpretedOption ? n2.uninterpretedOption = t2.uninterpretedOption.map((t3) => t3 ? e2.UninterpretedOption.toJSON(t3) : void 0) : n2.uninterpretedOption = [], n2;
  }, fromPartial(t2) {
    var n2;
    const o2 = /* @__PURE__ */ Object.create({ uninterpretedOption: [] });
    return o2.uninterpretedOption = (null === (n2 = t2.uninterpretedOption) || void 0 === n2 ? void 0 : n2.map((t3) => e2.UninterpretedOption.fromPartial(t3))) || [], o2;
  } }, e2.FieldDescriptorProto = { encode(t2, o2 = n.Writer.create()) {
    if ("" !== t2.name && o2.uint32(10).string(t2.name), 0 !== t2.number && o2.uint32(24).int32(t2.number), 1 !== t2.label && o2.uint32(32).int32(t2.label), 1 !== t2.type && o2.uint32(40).int32(t2.type), "" !== t2.typeName && o2.uint32(50).string(t2.typeName), "" !== t2.extendee && o2.uint32(18).string(t2.extendee), "" !== t2.defaultValue && o2.uint32(58).string(t2.defaultValue), 0 !== t2.oneofIndex && o2.uint32(72).int32(t2.oneofIndex), "" !== t2.jsonName && o2.uint32(82).string(t2.jsonName), void 0 !== t2.options && e2.FieldOptions.encode(t2.options, o2.uint32(66).fork()).ldelim(), true === t2.proto3Optional && o2.uint32(136).bool(t2.proto3Optional), "_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ name: "", number: 0, label: 1, type: 1, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "", options: void 0, proto3Optional: false });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.name = r2.string();
          break;
        case 3:
          i2.number = r2.int32();
          break;
        case 4:
          i2.label = r2.int32();
          break;
        case 5:
          i2.type = r2.int32();
          break;
        case 6:
          i2.typeName = r2.string();
          break;
        case 2:
          i2.extendee = r2.string();
          break;
        case 7:
          i2.defaultValue = r2.string();
          break;
        case 9:
          i2.oneofIndex = r2.int32();
          break;
        case 10:
          i2.jsonName = r2.string();
          break;
        case 8:
          i2.options = e2.FieldOptions.decode(r2, r2.uint32());
          break;
        case 17:
          i2.proto3Optional = r2.bool();
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ name: P(t2.name) ? String(t2.name) : "", number: P(t2.number) ? Number(t2.number) : 0, label: P(t2.label) ? u(t2.label) : 1, type: P(t2.type) ? d(t2.type) : 1, typeName: P(t2.typeName) ? String(t2.typeName) : "", extendee: P(t2.extendee) ? String(t2.extendee) : "", defaultValue: P(t2.defaultValue) ? String(t2.defaultValue) : "", oneofIndex: P(t2.oneofIndex) ? Number(t2.oneofIndex) : 0, jsonName: P(t2.jsonName) ? String(t2.jsonName) : "", options: P(t2.options) ? e2.FieldOptions.fromJSON(t2.options) : void 0, proto3Optional: !!P(t2.proto3Optional) && Boolean(t2.proto3Optional) }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.name && (n2.name = t2.name), void 0 !== t2.number && (n2.number = Math.round(t2.number)), void 0 !== t2.label && (n2.label = p(t2.label)), void 0 !== t2.type && (n2.type = l(t2.type)), void 0 !== t2.typeName && (n2.typeName = t2.typeName), void 0 !== t2.extendee && (n2.extendee = t2.extendee), void 0 !== t2.defaultValue && (n2.defaultValue = t2.defaultValue), void 0 !== t2.oneofIndex && (n2.oneofIndex = Math.round(t2.oneofIndex)), void 0 !== t2.jsonName && (n2.jsonName = t2.jsonName), void 0 !== t2.options && (n2.options = t2.options ? e2.FieldOptions.toJSON(t2.options) : void 0), void 0 !== t2.proto3Optional && (n2.proto3Optional = t2.proto3Optional), n2;
  }, fromPartial(t2) {
    var n2, o2, r2, a2, i2, s2, c2, d2, l2, u2;
    const p2 = /* @__PURE__ */ Object.create({ name: "", number: 0, label: 1, type: 1, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "", options: void 0, proto3Optional: false });
    return p2.name = null !== (n2 = t2.name) && void 0 !== n2 ? n2 : "", p2.number = null !== (o2 = t2.number) && void 0 !== o2 ? o2 : 0, p2.label = null !== (r2 = t2.label) && void 0 !== r2 ? r2 : 1, p2.type = null !== (a2 = t2.type) && void 0 !== a2 ? a2 : 1, p2.typeName = null !== (i2 = t2.typeName) && void 0 !== i2 ? i2 : "", p2.extendee = null !== (s2 = t2.extendee) && void 0 !== s2 ? s2 : "", p2.defaultValue = null !== (c2 = t2.defaultValue) && void 0 !== c2 ? c2 : "", p2.oneofIndex = null !== (d2 = t2.oneofIndex) && void 0 !== d2 ? d2 : 0, p2.jsonName = null !== (l2 = t2.jsonName) && void 0 !== l2 ? l2 : "", p2.options = void 0 !== t2.options && null !== t2.options ? e2.FieldOptions.fromPartial(t2.options) : void 0, p2.proto3Optional = null !== (u2 = t2.proto3Optional) && void 0 !== u2 && u2, p2;
  } }, e2.OneofDescriptorProto = { encode(t2, o2 = n.Writer.create()) {
    if ("" !== t2.name && o2.uint32(10).string(t2.name), void 0 !== t2.options && e2.OneofOptions.encode(t2.options, o2.uint32(18).fork()).ldelim(), "_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ name: "", options: void 0 });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.name = r2.string();
          break;
        case 2:
          i2.options = e2.OneofOptions.decode(r2, r2.uint32());
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ name: P(t2.name) ? String(t2.name) : "", options: P(t2.options) ? e2.OneofOptions.fromJSON(t2.options) : void 0 }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.name && (n2.name = t2.name), void 0 !== t2.options && (n2.options = t2.options ? e2.OneofOptions.toJSON(t2.options) : void 0), n2;
  }, fromPartial(t2) {
    var n2;
    const o2 = /* @__PURE__ */ Object.create({ name: "", options: void 0 });
    return o2.name = null !== (n2 = t2.name) && void 0 !== n2 ? n2 : "", o2.options = void 0 !== t2.options && null !== t2.options ? e2.OneofOptions.fromPartial(t2.options) : void 0, o2;
  } }, e2.EnumDescriptorProto = { encode(t2, o2 = n.Writer.create()) {
    "" !== t2.name && o2.uint32(10).string(t2.name);
    for (const n2 of t2.value)
      e2.EnumValueDescriptorProto.encode(n2, o2.uint32(18).fork()).ldelim();
    void 0 !== t2.options && e2.EnumOptions.encode(t2.options, o2.uint32(26).fork()).ldelim();
    for (const n2 of t2.reservedRange)
      e2.EnumDescriptorProto_EnumReservedRange.encode(n2, o2.uint32(34).fork()).ldelim();
    for (const e3 of t2.reservedName)
      o2.uint32(42).string(e3);
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ name: "", value: [], options: void 0, reservedRange: [], reservedName: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.name = r2.string();
          break;
        case 2:
          i2.value.push(e2.EnumValueDescriptorProto.decode(r2, r2.uint32()));
          break;
        case 3:
          i2.options = e2.EnumOptions.decode(r2, r2.uint32());
          break;
        case 4:
          i2.reservedRange.push(e2.EnumDescriptorProto_EnumReservedRange.decode(r2, r2.uint32()));
          break;
        case 5:
          i2.reservedName.push(r2.string());
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ name: P(t2.name) ? String(t2.name) : "", value: Array.isArray(null == t2 ? void 0 : t2.value) ? t2.value.map((t3) => e2.EnumValueDescriptorProto.fromJSON(t3)) : [], options: P(t2.options) ? e2.EnumOptions.fromJSON(t2.options) : void 0, reservedRange: Array.isArray(null == t2 ? void 0 : t2.reservedRange) ? t2.reservedRange.map((t3) => e2.EnumDescriptorProto_EnumReservedRange.fromJSON(t3)) : [], reservedName: Array.isArray(null == t2 ? void 0 : t2.reservedName) ? t2.reservedName.map((e3) => String(e3)) : [] }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.name && (n2.name = t2.name), t2.value ? n2.value = t2.value.map((t3) => t3 ? e2.EnumValueDescriptorProto.toJSON(t3) : void 0) : n2.value = [], void 0 !== t2.options && (n2.options = t2.options ? e2.EnumOptions.toJSON(t2.options) : void 0), t2.reservedRange ? n2.reservedRange = t2.reservedRange.map((t3) => t3 ? e2.EnumDescriptorProto_EnumReservedRange.toJSON(t3) : void 0) : n2.reservedRange = [], t2.reservedName ? n2.reservedName = t2.reservedName.map((e3) => e3) : n2.reservedName = [], n2;
  }, fromPartial(t2) {
    var n2, o2, r2, a2;
    const i2 = /* @__PURE__ */ Object.create({ name: "", value: [], options: void 0, reservedRange: [], reservedName: [] });
    return i2.name = null !== (n2 = t2.name) && void 0 !== n2 ? n2 : "", i2.value = (null === (o2 = t2.value) || void 0 === o2 ? void 0 : o2.map((t3) => e2.EnumValueDescriptorProto.fromPartial(t3))) || [], i2.options = void 0 !== t2.options && null !== t2.options ? e2.EnumOptions.fromPartial(t2.options) : void 0, i2.reservedRange = (null === (r2 = t2.reservedRange) || void 0 === r2 ? void 0 : r2.map((t3) => e2.EnumDescriptorProto_EnumReservedRange.fromPartial(t3))) || [], i2.reservedName = (null === (a2 = t2.reservedName) || void 0 === a2 ? void 0 : a2.map((e3) => e3)) || [], i2;
  } }, e2.EnumDescriptorProto_EnumReservedRange = { encode(e3, t2 = n.Writer.create()) {
    if (0 !== e3.start && t2.uint32(8).int32(e3.start), 0 !== e3.end && t2.uint32(16).int32(e3.end), "_unknownFields" in e3) {
      const n2 = e3._unknownFields;
      for (const e4 of Object.keys(n2)) {
        const o2 = n2[e4];
        for (const n3 of o2)
          t2.uint32(parseInt(e4, 10)), t2._push((e5, t3, n4) => t3.set(e5, n4), n3.length, n3);
      }
    }
    return t2;
  }, decode(e3, t2) {
    const o2 = e3 instanceof n.Reader ? e3 : new n.Reader(e3);
    let r2 = void 0 === t2 ? o2.len : o2.pos + t2;
    const a2 = /* @__PURE__ */ Object.create({ start: 0, end: 0 });
    for (a2._unknownFields = {}; o2.pos < r2; ) {
      const e4 = o2.uint32();
      switch (e4 >>> 3) {
        case 1:
          a2.start = o2.int32();
          break;
        case 2:
          a2.end = o2.int32();
          break;
        default:
          const t3 = o2.pos;
          o2.skipType(7 & e4), a2._unknownFields[e4] = [...a2._unknownFields[e4] || [], o2.buf.slice(t3, o2.pos)];
      }
    }
    return a2;
  }, fromJSON: (e3) => ({ start: P(e3.start) ? Number(e3.start) : 0, end: P(e3.end) ? Number(e3.end) : 0 }), toJSON(e3) {
    const t2 = {};
    return void 0 !== e3.start && (t2.start = Math.round(e3.start)), void 0 !== e3.end && (t2.end = Math.round(e3.end)), t2;
  }, fromPartial(e3) {
    var t2, n2;
    const o2 = /* @__PURE__ */ Object.create({ start: 0, end: 0 });
    return o2.start = null !== (t2 = e3.start) && void 0 !== t2 ? t2 : 0, o2.end = null !== (n2 = e3.end) && void 0 !== n2 ? n2 : 0, o2;
  } }, e2.EnumValueDescriptorProto = { encode(t2, o2 = n.Writer.create()) {
    if ("" !== t2.name && o2.uint32(10).string(t2.name), 0 !== t2.number && o2.uint32(16).int32(t2.number), void 0 !== t2.options && e2.EnumValueOptions.encode(t2.options, o2.uint32(26).fork()).ldelim(), "_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ name: "", number: 0, options: void 0 });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.name = r2.string();
          break;
        case 2:
          i2.number = r2.int32();
          break;
        case 3:
          i2.options = e2.EnumValueOptions.decode(r2, r2.uint32());
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ name: P(t2.name) ? String(t2.name) : "", number: P(t2.number) ? Number(t2.number) : 0, options: P(t2.options) ? e2.EnumValueOptions.fromJSON(t2.options) : void 0 }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.name && (n2.name = t2.name), void 0 !== t2.number && (n2.number = Math.round(t2.number)), void 0 !== t2.options && (n2.options = t2.options ? e2.EnumValueOptions.toJSON(t2.options) : void 0), n2;
  }, fromPartial(t2) {
    var n2, o2;
    const r2 = /* @__PURE__ */ Object.create({ name: "", number: 0, options: void 0 });
    return r2.name = null !== (n2 = t2.name) && void 0 !== n2 ? n2 : "", r2.number = null !== (o2 = t2.number) && void 0 !== o2 ? o2 : 0, r2.options = void 0 !== t2.options && null !== t2.options ? e2.EnumValueOptions.fromPartial(t2.options) : void 0, r2;
  } }, e2.ServiceDescriptorProto = { encode(t2, o2 = n.Writer.create()) {
    "" !== t2.name && o2.uint32(10).string(t2.name);
    for (const n2 of t2.method)
      e2.MethodDescriptorProto.encode(n2, o2.uint32(18).fork()).ldelim();
    if (void 0 !== t2.options && e2.ServiceOptions.encode(t2.options, o2.uint32(26).fork()).ldelim(), "_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ name: "", method: [], options: void 0 });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.name = r2.string();
          break;
        case 2:
          i2.method.push(e2.MethodDescriptorProto.decode(r2, r2.uint32()));
          break;
        case 3:
          i2.options = e2.ServiceOptions.decode(r2, r2.uint32());
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ name: P(t2.name) ? String(t2.name) : "", method: Array.isArray(null == t2 ? void 0 : t2.method) ? t2.method.map((t3) => e2.MethodDescriptorProto.fromJSON(t3)) : [], options: P(t2.options) ? e2.ServiceOptions.fromJSON(t2.options) : void 0 }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.name && (n2.name = t2.name), t2.method ? n2.method = t2.method.map((t3) => t3 ? e2.MethodDescriptorProto.toJSON(t3) : void 0) : n2.method = [], void 0 !== t2.options && (n2.options = t2.options ? e2.ServiceOptions.toJSON(t2.options) : void 0), n2;
  }, fromPartial(t2) {
    var n2, o2;
    const r2 = /* @__PURE__ */ Object.create({ name: "", method: [], options: void 0 });
    return r2.name = null !== (n2 = t2.name) && void 0 !== n2 ? n2 : "", r2.method = (null === (o2 = t2.method) || void 0 === o2 ? void 0 : o2.map((t3) => e2.MethodDescriptorProto.fromPartial(t3))) || [], r2.options = void 0 !== t2.options && null !== t2.options ? e2.ServiceOptions.fromPartial(t2.options) : void 0, r2;
  } }, e2.MethodDescriptorProto = { encode(t2, o2 = n.Writer.create()) {
    if ("" !== t2.name && o2.uint32(10).string(t2.name), "" !== t2.inputType && o2.uint32(18).string(t2.inputType), "" !== t2.outputType && o2.uint32(26).string(t2.outputType), void 0 !== t2.options && e2.MethodOptions.encode(t2.options, o2.uint32(34).fork()).ldelim(), true === t2.clientStreaming && o2.uint32(40).bool(t2.clientStreaming), true === t2.serverStreaming && o2.uint32(48).bool(t2.serverStreaming), "_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ name: "", inputType: "", outputType: "", options: void 0, clientStreaming: false, serverStreaming: false });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.name = r2.string();
          break;
        case 2:
          i2.inputType = r2.string();
          break;
        case 3:
          i2.outputType = r2.string();
          break;
        case 4:
          i2.options = e2.MethodOptions.decode(r2, r2.uint32());
          break;
        case 5:
          i2.clientStreaming = r2.bool();
          break;
        case 6:
          i2.serverStreaming = r2.bool();
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ name: P(t2.name) ? String(t2.name) : "", inputType: P(t2.inputType) ? String(t2.inputType) : "", outputType: P(t2.outputType) ? String(t2.outputType) : "", options: P(t2.options) ? e2.MethodOptions.fromJSON(t2.options) : void 0, clientStreaming: !!P(t2.clientStreaming) && Boolean(t2.clientStreaming), serverStreaming: !!P(t2.serverStreaming) && Boolean(t2.serverStreaming) }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.name && (n2.name = t2.name), void 0 !== t2.inputType && (n2.inputType = t2.inputType), void 0 !== t2.outputType && (n2.outputType = t2.outputType), void 0 !== t2.options && (n2.options = t2.options ? e2.MethodOptions.toJSON(t2.options) : void 0), void 0 !== t2.clientStreaming && (n2.clientStreaming = t2.clientStreaming), void 0 !== t2.serverStreaming && (n2.serverStreaming = t2.serverStreaming), n2;
  }, fromPartial(t2) {
    var n2, o2, r2, a2, i2;
    const s2 = /* @__PURE__ */ Object.create({ name: "", inputType: "", outputType: "", options: void 0, clientStreaming: false, serverStreaming: false });
    return s2.name = null !== (n2 = t2.name) && void 0 !== n2 ? n2 : "", s2.inputType = null !== (o2 = t2.inputType) && void 0 !== o2 ? o2 : "", s2.outputType = null !== (r2 = t2.outputType) && void 0 !== r2 ? r2 : "", s2.options = void 0 !== t2.options && null !== t2.options ? e2.MethodOptions.fromPartial(t2.options) : void 0, s2.clientStreaming = null !== (a2 = t2.clientStreaming) && void 0 !== a2 && a2, s2.serverStreaming = null !== (i2 = t2.serverStreaming) && void 0 !== i2 && i2, s2;
  } }, e2.FileOptions = { encode(t2, o2 = n.Writer.create()) {
    "" !== t2.javaPackage && o2.uint32(10).string(t2.javaPackage), "" !== t2.javaOuterClassname && o2.uint32(66).string(t2.javaOuterClassname), true === t2.javaMultipleFiles && o2.uint32(80).bool(t2.javaMultipleFiles), true === t2.javaGenerateEqualsAndHash && o2.uint32(160).bool(t2.javaGenerateEqualsAndHash), true === t2.javaStringCheckUtf8 && o2.uint32(216).bool(t2.javaStringCheckUtf8), 1 !== t2.optimizeFor && o2.uint32(72).int32(t2.optimizeFor), "" !== t2.goPackage && o2.uint32(90).string(t2.goPackage), true === t2.ccGenericServices && o2.uint32(128).bool(t2.ccGenericServices), true === t2.javaGenericServices && o2.uint32(136).bool(t2.javaGenericServices), true === t2.pyGenericServices && o2.uint32(144).bool(t2.pyGenericServices), true === t2.phpGenericServices && o2.uint32(336).bool(t2.phpGenericServices), true === t2.deprecated && o2.uint32(184).bool(t2.deprecated), true === t2.ccEnableArenas && o2.uint32(248).bool(t2.ccEnableArenas), "" !== t2.objcClassPrefix && o2.uint32(290).string(t2.objcClassPrefix), "" !== t2.csharpNamespace && o2.uint32(298).string(t2.csharpNamespace), "" !== t2.swiftPrefix && o2.uint32(314).string(t2.swiftPrefix), "" !== t2.phpClassPrefix && o2.uint32(322).string(t2.phpClassPrefix), "" !== t2.phpNamespace && o2.uint32(330).string(t2.phpNamespace), "" !== t2.phpMetadataNamespace && o2.uint32(354).string(t2.phpMetadataNamespace), "" !== t2.rubyPackage && o2.uint32(362).string(t2.rubyPackage);
    for (const n2 of t2.uninterpretedOption)
      e2.UninterpretedOption.encode(n2, o2.uint32(7994).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ javaPackage: "", javaOuterClassname: "", javaMultipleFiles: false, javaGenerateEqualsAndHash: false, javaStringCheckUtf8: false, optimizeFor: 1, goPackage: "", ccGenericServices: false, javaGenericServices: false, pyGenericServices: false, phpGenericServices: false, deprecated: false, ccEnableArenas: false, objcClassPrefix: "", csharpNamespace: "", swiftPrefix: "", phpClassPrefix: "", phpNamespace: "", phpMetadataNamespace: "", rubyPackage: "", uninterpretedOption: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.javaPackage = r2.string();
          break;
        case 8:
          i2.javaOuterClassname = r2.string();
          break;
        case 10:
          i2.javaMultipleFiles = r2.bool();
          break;
        case 20:
          i2.javaGenerateEqualsAndHash = r2.bool();
          break;
        case 27:
          i2.javaStringCheckUtf8 = r2.bool();
          break;
        case 9:
          i2.optimizeFor = r2.int32();
          break;
        case 11:
          i2.goPackage = r2.string();
          break;
        case 16:
          i2.ccGenericServices = r2.bool();
          break;
        case 17:
          i2.javaGenericServices = r2.bool();
          break;
        case 18:
          i2.pyGenericServices = r2.bool();
          break;
        case 42:
          i2.phpGenericServices = r2.bool();
          break;
        case 23:
          i2.deprecated = r2.bool();
          break;
        case 31:
          i2.ccEnableArenas = r2.bool();
          break;
        case 36:
          i2.objcClassPrefix = r2.string();
          break;
        case 37:
          i2.csharpNamespace = r2.string();
          break;
        case 39:
          i2.swiftPrefix = r2.string();
          break;
        case 40:
          i2.phpClassPrefix = r2.string();
          break;
        case 41:
          i2.phpNamespace = r2.string();
          break;
        case 44:
          i2.phpMetadataNamespace = r2.string();
          break;
        case 45:
          i2.rubyPackage = r2.string();
          break;
        case 999:
          i2.uninterpretedOption.push(e2.UninterpretedOption.decode(r2, r2.uint32()));
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ javaPackage: P(t2.javaPackage) ? String(t2.javaPackage) : "", javaOuterClassname: P(t2.javaOuterClassname) ? String(t2.javaOuterClassname) : "", javaMultipleFiles: !!P(t2.javaMultipleFiles) && Boolean(t2.javaMultipleFiles), javaGenerateEqualsAndHash: !!P(t2.javaGenerateEqualsAndHash) && Boolean(t2.javaGenerateEqualsAndHash), javaStringCheckUtf8: !!P(t2.javaStringCheckUtf8) && Boolean(t2.javaStringCheckUtf8), optimizeFor: P(t2.optimizeFor) ? m2(t2.optimizeFor) : 1, goPackage: P(t2.goPackage) ? String(t2.goPackage) : "", ccGenericServices: !!P(t2.ccGenericServices) && Boolean(t2.ccGenericServices), javaGenericServices: !!P(t2.javaGenericServices) && Boolean(t2.javaGenericServices), pyGenericServices: !!P(t2.pyGenericServices) && Boolean(t2.pyGenericServices), phpGenericServices: !!P(t2.phpGenericServices) && Boolean(t2.phpGenericServices), deprecated: !!P(t2.deprecated) && Boolean(t2.deprecated), ccEnableArenas: !!P(t2.ccEnableArenas) && Boolean(t2.ccEnableArenas), objcClassPrefix: P(t2.objcClassPrefix) ? String(t2.objcClassPrefix) : "", csharpNamespace: P(t2.csharpNamespace) ? String(t2.csharpNamespace) : "", swiftPrefix: P(t2.swiftPrefix) ? String(t2.swiftPrefix) : "", phpClassPrefix: P(t2.phpClassPrefix) ? String(t2.phpClassPrefix) : "", phpNamespace: P(t2.phpNamespace) ? String(t2.phpNamespace) : "", phpMetadataNamespace: P(t2.phpMetadataNamespace) ? String(t2.phpMetadataNamespace) : "", rubyPackage: P(t2.rubyPackage) ? String(t2.rubyPackage) : "", uninterpretedOption: Array.isArray(null == t2 ? void 0 : t2.uninterpretedOption) ? t2.uninterpretedOption.map((t3) => e2.UninterpretedOption.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.javaPackage && (n2.javaPackage = t2.javaPackage), void 0 !== t2.javaOuterClassname && (n2.javaOuterClassname = t2.javaOuterClassname), void 0 !== t2.javaMultipleFiles && (n2.javaMultipleFiles = t2.javaMultipleFiles), void 0 !== t2.javaGenerateEqualsAndHash && (n2.javaGenerateEqualsAndHash = t2.javaGenerateEqualsAndHash), void 0 !== t2.javaStringCheckUtf8 && (n2.javaStringCheckUtf8 = t2.javaStringCheckUtf8), void 0 !== t2.optimizeFor && (n2.optimizeFor = f(t2.optimizeFor)), void 0 !== t2.goPackage && (n2.goPackage = t2.goPackage), void 0 !== t2.ccGenericServices && (n2.ccGenericServices = t2.ccGenericServices), void 0 !== t2.javaGenericServices && (n2.javaGenericServices = t2.javaGenericServices), void 0 !== t2.pyGenericServices && (n2.pyGenericServices = t2.pyGenericServices), void 0 !== t2.phpGenericServices && (n2.phpGenericServices = t2.phpGenericServices), void 0 !== t2.deprecated && (n2.deprecated = t2.deprecated), void 0 !== t2.ccEnableArenas && (n2.ccEnableArenas = t2.ccEnableArenas), void 0 !== t2.objcClassPrefix && (n2.objcClassPrefix = t2.objcClassPrefix), void 0 !== t2.csharpNamespace && (n2.csharpNamespace = t2.csharpNamespace), void 0 !== t2.swiftPrefix && (n2.swiftPrefix = t2.swiftPrefix), void 0 !== t2.phpClassPrefix && (n2.phpClassPrefix = t2.phpClassPrefix), void 0 !== t2.phpNamespace && (n2.phpNamespace = t2.phpNamespace), void 0 !== t2.phpMetadataNamespace && (n2.phpMetadataNamespace = t2.phpMetadataNamespace), void 0 !== t2.rubyPackage && (n2.rubyPackage = t2.rubyPackage), t2.uninterpretedOption ? n2.uninterpretedOption = t2.uninterpretedOption.map((t3) => t3 ? e2.UninterpretedOption.toJSON(t3) : void 0) : n2.uninterpretedOption = [], n2;
  }, fromPartial(t2) {
    var n2, o2, r2, a2, i2, s2, c2, d2, l2, u2, p2, m3, f2, y2, v3, g2, T2, C2, h2, b2, A2;
    const I2 = /* @__PURE__ */ Object.create({ javaPackage: "", javaOuterClassname: "", javaMultipleFiles: false, javaGenerateEqualsAndHash: false, javaStringCheckUtf8: false, optimizeFor: 1, goPackage: "", ccGenericServices: false, javaGenericServices: false, pyGenericServices: false, phpGenericServices: false, deprecated: false, ccEnableArenas: false, objcClassPrefix: "", csharpNamespace: "", swiftPrefix: "", phpClassPrefix: "", phpNamespace: "", phpMetadataNamespace: "", rubyPackage: "", uninterpretedOption: [] });
    return I2.javaPackage = null !== (n2 = t2.javaPackage) && void 0 !== n2 ? n2 : "", I2.javaOuterClassname = null !== (o2 = t2.javaOuterClassname) && void 0 !== o2 ? o2 : "", I2.javaMultipleFiles = null !== (r2 = t2.javaMultipleFiles) && void 0 !== r2 && r2, I2.javaGenerateEqualsAndHash = null !== (a2 = t2.javaGenerateEqualsAndHash) && void 0 !== a2 && a2, I2.javaStringCheckUtf8 = null !== (i2 = t2.javaStringCheckUtf8) && void 0 !== i2 && i2, I2.optimizeFor = null !== (s2 = t2.optimizeFor) && void 0 !== s2 ? s2 : 1, I2.goPackage = null !== (c2 = t2.goPackage) && void 0 !== c2 ? c2 : "", I2.ccGenericServices = null !== (d2 = t2.ccGenericServices) && void 0 !== d2 && d2, I2.javaGenericServices = null !== (l2 = t2.javaGenericServices) && void 0 !== l2 && l2, I2.pyGenericServices = null !== (u2 = t2.pyGenericServices) && void 0 !== u2 && u2, I2.phpGenericServices = null !== (p2 = t2.phpGenericServices) && void 0 !== p2 && p2, I2.deprecated = null !== (m3 = t2.deprecated) && void 0 !== m3 && m3, I2.ccEnableArenas = null !== (f2 = t2.ccEnableArenas) && void 0 !== f2 && f2, I2.objcClassPrefix = null !== (y2 = t2.objcClassPrefix) && void 0 !== y2 ? y2 : "", I2.csharpNamespace = null !== (v3 = t2.csharpNamespace) && void 0 !== v3 ? v3 : "", I2.swiftPrefix = null !== (g2 = t2.swiftPrefix) && void 0 !== g2 ? g2 : "", I2.phpClassPrefix = null !== (T2 = t2.phpClassPrefix) && void 0 !== T2 ? T2 : "", I2.phpNamespace = null !== (C2 = t2.phpNamespace) && void 0 !== C2 ? C2 : "", I2.phpMetadataNamespace = null !== (h2 = t2.phpMetadataNamespace) && void 0 !== h2 ? h2 : "", I2.rubyPackage = null !== (b2 = t2.rubyPackage) && void 0 !== b2 ? b2 : "", I2.uninterpretedOption = (null === (A2 = t2.uninterpretedOption) || void 0 === A2 ? void 0 : A2.map((t3) => e2.UninterpretedOption.fromPartial(t3))) || [], I2;
  } }, e2.MessageOptions = { encode(t2, o2 = n.Writer.create()) {
    true === t2.messageSetWireFormat && o2.uint32(8).bool(t2.messageSetWireFormat), true === t2.noStandardDescriptorAccessor && o2.uint32(16).bool(t2.noStandardDescriptorAccessor), true === t2.deprecated && o2.uint32(24).bool(t2.deprecated), true === t2.mapEntry && o2.uint32(56).bool(t2.mapEntry);
    for (const n2 of t2.uninterpretedOption)
      e2.UninterpretedOption.encode(n2, o2.uint32(7994).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ messageSetWireFormat: false, noStandardDescriptorAccessor: false, deprecated: false, mapEntry: false, uninterpretedOption: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.messageSetWireFormat = r2.bool();
          break;
        case 2:
          i2.noStandardDescriptorAccessor = r2.bool();
          break;
        case 3:
          i2.deprecated = r2.bool();
          break;
        case 7:
          i2.mapEntry = r2.bool();
          break;
        case 999:
          i2.uninterpretedOption.push(e2.UninterpretedOption.decode(r2, r2.uint32()));
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ messageSetWireFormat: !!P(t2.messageSetWireFormat) && Boolean(t2.messageSetWireFormat), noStandardDescriptorAccessor: !!P(t2.noStandardDescriptorAccessor) && Boolean(t2.noStandardDescriptorAccessor), deprecated: !!P(t2.deprecated) && Boolean(t2.deprecated), mapEntry: !!P(t2.mapEntry) && Boolean(t2.mapEntry), uninterpretedOption: Array.isArray(null == t2 ? void 0 : t2.uninterpretedOption) ? t2.uninterpretedOption.map((t3) => e2.UninterpretedOption.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.messageSetWireFormat && (n2.messageSetWireFormat = t2.messageSetWireFormat), void 0 !== t2.noStandardDescriptorAccessor && (n2.noStandardDescriptorAccessor = t2.noStandardDescriptorAccessor), void 0 !== t2.deprecated && (n2.deprecated = t2.deprecated), void 0 !== t2.mapEntry && (n2.mapEntry = t2.mapEntry), t2.uninterpretedOption ? n2.uninterpretedOption = t2.uninterpretedOption.map((t3) => t3 ? e2.UninterpretedOption.toJSON(t3) : void 0) : n2.uninterpretedOption = [], n2;
  }, fromPartial(t2) {
    var n2, o2, r2, a2, i2;
    const s2 = /* @__PURE__ */ Object.create({ messageSetWireFormat: false, noStandardDescriptorAccessor: false, deprecated: false, mapEntry: false, uninterpretedOption: [] });
    return s2.messageSetWireFormat = null !== (n2 = t2.messageSetWireFormat) && void 0 !== n2 && n2, s2.noStandardDescriptorAccessor = null !== (o2 = t2.noStandardDescriptorAccessor) && void 0 !== o2 && o2, s2.deprecated = null !== (r2 = t2.deprecated) && void 0 !== r2 && r2, s2.mapEntry = null !== (a2 = t2.mapEntry) && void 0 !== a2 && a2, s2.uninterpretedOption = (null === (i2 = t2.uninterpretedOption) || void 0 === i2 ? void 0 : i2.map((t3) => e2.UninterpretedOption.fromPartial(t3))) || [], s2;
  } }, e2.FieldOptions = { encode(t2, o2 = n.Writer.create()) {
    0 !== t2.ctype && o2.uint32(8).int32(t2.ctype), true === t2.packed && o2.uint32(16).bool(t2.packed), 0 !== t2.jstype && o2.uint32(48).int32(t2.jstype), true === t2.lazy && o2.uint32(40).bool(t2.lazy), true === t2.deprecated && o2.uint32(24).bool(t2.deprecated), true === t2.weak && o2.uint32(80).bool(t2.weak);
    for (const n2 of t2.uninterpretedOption)
      e2.UninterpretedOption.encode(n2, o2.uint32(7994).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ ctype: 0, packed: false, jstype: 0, lazy: false, deprecated: false, weak: false, uninterpretedOption: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.ctype = r2.int32();
          break;
        case 2:
          i2.packed = r2.bool();
          break;
        case 6:
          i2.jstype = r2.int32();
          break;
        case 5:
          i2.lazy = r2.bool();
          break;
        case 3:
          i2.deprecated = r2.bool();
          break;
        case 10:
          i2.weak = r2.bool();
          break;
        case 999:
          i2.uninterpretedOption.push(e2.UninterpretedOption.decode(r2, r2.uint32()));
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ ctype: P(t2.ctype) ? y(t2.ctype) : 0, packed: !!P(t2.packed) && Boolean(t2.packed), jstype: P(t2.jstype) ? g(t2.jstype) : 0, lazy: !!P(t2.lazy) && Boolean(t2.lazy), deprecated: !!P(t2.deprecated) && Boolean(t2.deprecated), weak: !!P(t2.weak) && Boolean(t2.weak), uninterpretedOption: Array.isArray(null == t2 ? void 0 : t2.uninterpretedOption) ? t2.uninterpretedOption.map((t3) => e2.UninterpretedOption.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.ctype && (n2.ctype = v2(t2.ctype)), void 0 !== t2.packed && (n2.packed = t2.packed), void 0 !== t2.jstype && (n2.jstype = T(t2.jstype)), void 0 !== t2.lazy && (n2.lazy = t2.lazy), void 0 !== t2.deprecated && (n2.deprecated = t2.deprecated), void 0 !== t2.weak && (n2.weak = t2.weak), t2.uninterpretedOption ? n2.uninterpretedOption = t2.uninterpretedOption.map((t3) => t3 ? e2.UninterpretedOption.toJSON(t3) : void 0) : n2.uninterpretedOption = [], n2;
  }, fromPartial(t2) {
    var n2, o2, r2, a2, i2, s2, c2;
    const d2 = /* @__PURE__ */ Object.create({ ctype: 0, packed: false, jstype: 0, lazy: false, deprecated: false, weak: false, uninterpretedOption: [] });
    return d2.ctype = null !== (n2 = t2.ctype) && void 0 !== n2 ? n2 : 0, d2.packed = null !== (o2 = t2.packed) && void 0 !== o2 && o2, d2.jstype = null !== (r2 = t2.jstype) && void 0 !== r2 ? r2 : 0, d2.lazy = null !== (a2 = t2.lazy) && void 0 !== a2 && a2, d2.deprecated = null !== (i2 = t2.deprecated) && void 0 !== i2 && i2, d2.weak = null !== (s2 = t2.weak) && void 0 !== s2 && s2, d2.uninterpretedOption = (null === (c2 = t2.uninterpretedOption) || void 0 === c2 ? void 0 : c2.map((t3) => e2.UninterpretedOption.fromPartial(t3))) || [], d2;
  } }, e2.OneofOptions = { encode(t2, o2 = n.Writer.create()) {
    for (const n2 of t2.uninterpretedOption)
      e2.UninterpretedOption.encode(n2, o2.uint32(7994).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ uninterpretedOption: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      if (t3 >>> 3 == 999)
        i2.uninterpretedOption.push(e2.UninterpretedOption.decode(r2, r2.uint32()));
      else {
        const e3 = r2.pos;
        r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(e3, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ uninterpretedOption: Array.isArray(null == t2 ? void 0 : t2.uninterpretedOption) ? t2.uninterpretedOption.map((t3) => e2.UninterpretedOption.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return t2.uninterpretedOption ? n2.uninterpretedOption = t2.uninterpretedOption.map((t3) => t3 ? e2.UninterpretedOption.toJSON(t3) : void 0) : n2.uninterpretedOption = [], n2;
  }, fromPartial(t2) {
    var n2;
    const o2 = /* @__PURE__ */ Object.create({ uninterpretedOption: [] });
    return o2.uninterpretedOption = (null === (n2 = t2.uninterpretedOption) || void 0 === n2 ? void 0 : n2.map((t3) => e2.UninterpretedOption.fromPartial(t3))) || [], o2;
  } }, e2.EnumOptions = { encode(t2, o2 = n.Writer.create()) {
    true === t2.allowAlias && o2.uint32(16).bool(t2.allowAlias), true === t2.deprecated && o2.uint32(24).bool(t2.deprecated);
    for (const n2 of t2.uninterpretedOption)
      e2.UninterpretedOption.encode(n2, o2.uint32(7994).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ allowAlias: false, deprecated: false, uninterpretedOption: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 2:
          i2.allowAlias = r2.bool();
          break;
        case 3:
          i2.deprecated = r2.bool();
          break;
        case 999:
          i2.uninterpretedOption.push(e2.UninterpretedOption.decode(r2, r2.uint32()));
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ allowAlias: !!P(t2.allowAlias) && Boolean(t2.allowAlias), deprecated: !!P(t2.deprecated) && Boolean(t2.deprecated), uninterpretedOption: Array.isArray(null == t2 ? void 0 : t2.uninterpretedOption) ? t2.uninterpretedOption.map((t3) => e2.UninterpretedOption.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.allowAlias && (n2.allowAlias = t2.allowAlias), void 0 !== t2.deprecated && (n2.deprecated = t2.deprecated), t2.uninterpretedOption ? n2.uninterpretedOption = t2.uninterpretedOption.map((t3) => t3 ? e2.UninterpretedOption.toJSON(t3) : void 0) : n2.uninterpretedOption = [], n2;
  }, fromPartial(t2) {
    var n2, o2, r2;
    const a2 = /* @__PURE__ */ Object.create({ allowAlias: false, deprecated: false, uninterpretedOption: [] });
    return a2.allowAlias = null !== (n2 = t2.allowAlias) && void 0 !== n2 && n2, a2.deprecated = null !== (o2 = t2.deprecated) && void 0 !== o2 && o2, a2.uninterpretedOption = (null === (r2 = t2.uninterpretedOption) || void 0 === r2 ? void 0 : r2.map((t3) => e2.UninterpretedOption.fromPartial(t3))) || [], a2;
  } }, e2.EnumValueOptions = { encode(t2, o2 = n.Writer.create()) {
    true === t2.deprecated && o2.uint32(8).bool(t2.deprecated);
    for (const n2 of t2.uninterpretedOption)
      e2.UninterpretedOption.encode(n2, o2.uint32(7994).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ deprecated: false, uninterpretedOption: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          i2.deprecated = r2.bool();
          break;
        case 999:
          i2.uninterpretedOption.push(e2.UninterpretedOption.decode(r2, r2.uint32()));
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ deprecated: !!P(t2.deprecated) && Boolean(t2.deprecated), uninterpretedOption: Array.isArray(null == t2 ? void 0 : t2.uninterpretedOption) ? t2.uninterpretedOption.map((t3) => e2.UninterpretedOption.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.deprecated && (n2.deprecated = t2.deprecated), t2.uninterpretedOption ? n2.uninterpretedOption = t2.uninterpretedOption.map((t3) => t3 ? e2.UninterpretedOption.toJSON(t3) : void 0) : n2.uninterpretedOption = [], n2;
  }, fromPartial(t2) {
    var n2, o2;
    const r2 = /* @__PURE__ */ Object.create({ deprecated: false, uninterpretedOption: [] });
    return r2.deprecated = null !== (n2 = t2.deprecated) && void 0 !== n2 && n2, r2.uninterpretedOption = (null === (o2 = t2.uninterpretedOption) || void 0 === o2 ? void 0 : o2.map((t3) => e2.UninterpretedOption.fromPartial(t3))) || [], r2;
  } }, e2.ServiceOptions = { encode(t2, o2 = n.Writer.create()) {
    true === t2.deprecated && o2.uint32(264).bool(t2.deprecated);
    for (const n2 of t2.uninterpretedOption)
      e2.UninterpretedOption.encode(n2, o2.uint32(7994).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ deprecated: false, uninterpretedOption: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 33:
          i2.deprecated = r2.bool();
          break;
        case 999:
          i2.uninterpretedOption.push(e2.UninterpretedOption.decode(r2, r2.uint32()));
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ deprecated: !!P(t2.deprecated) && Boolean(t2.deprecated), uninterpretedOption: Array.isArray(null == t2 ? void 0 : t2.uninterpretedOption) ? t2.uninterpretedOption.map((t3) => e2.UninterpretedOption.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.deprecated && (n2.deprecated = t2.deprecated), t2.uninterpretedOption ? n2.uninterpretedOption = t2.uninterpretedOption.map((t3) => t3 ? e2.UninterpretedOption.toJSON(t3) : void 0) : n2.uninterpretedOption = [], n2;
  }, fromPartial(t2) {
    var n2, o2;
    const r2 = /* @__PURE__ */ Object.create({ deprecated: false, uninterpretedOption: [] });
    return r2.deprecated = null !== (n2 = t2.deprecated) && void 0 !== n2 && n2, r2.uninterpretedOption = (null === (o2 = t2.uninterpretedOption) || void 0 === o2 ? void 0 : o2.map((t3) => e2.UninterpretedOption.fromPartial(t3))) || [], r2;
  } }, e2.MethodOptions = { encode(t2, o2 = n.Writer.create()) {
    true === t2.deprecated && o2.uint32(264).bool(t2.deprecated), 0 !== t2.idempotencyLevel && o2.uint32(272).int32(t2.idempotencyLevel);
    for (const n2 of t2.uninterpretedOption)
      e2.UninterpretedOption.encode(n2, o2.uint32(7994).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ deprecated: false, idempotencyLevel: 0, uninterpretedOption: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 33:
          i2.deprecated = r2.bool();
          break;
        case 34:
          i2.idempotencyLevel = r2.int32();
          break;
        case 999:
          i2.uninterpretedOption.push(e2.UninterpretedOption.decode(r2, r2.uint32()));
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ deprecated: !!P(t2.deprecated) && Boolean(t2.deprecated), idempotencyLevel: P(t2.idempotencyLevel) ? C(t2.idempotencyLevel) : 0, uninterpretedOption: Array.isArray(null == t2 ? void 0 : t2.uninterpretedOption) ? t2.uninterpretedOption.map((t3) => e2.UninterpretedOption.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.deprecated && (n2.deprecated = t2.deprecated), void 0 !== t2.idempotencyLevel && (n2.idempotencyLevel = h(t2.idempotencyLevel)), t2.uninterpretedOption ? n2.uninterpretedOption = t2.uninterpretedOption.map((t3) => t3 ? e2.UninterpretedOption.toJSON(t3) : void 0) : n2.uninterpretedOption = [], n2;
  }, fromPartial(t2) {
    var n2, o2, r2;
    const a2 = /* @__PURE__ */ Object.create({ deprecated: false, idempotencyLevel: 0, uninterpretedOption: [] });
    return a2.deprecated = null !== (n2 = t2.deprecated) && void 0 !== n2 && n2, a2.idempotencyLevel = null !== (o2 = t2.idempotencyLevel) && void 0 !== o2 ? o2 : 0, a2.uninterpretedOption = (null === (r2 = t2.uninterpretedOption) || void 0 === r2 ? void 0 : r2.map((t3) => e2.UninterpretedOption.fromPartial(t3))) || [], a2;
  } }, e2.UninterpretedOption = { encode(t2, o2 = n.Writer.create()) {
    for (const n2 of t2.name)
      e2.UninterpretedOption_NamePart.encode(n2, o2.uint32(18).fork()).ldelim();
    if ("" !== t2.identifierValue && o2.uint32(26).string(t2.identifierValue), 0 !== t2.positiveIntValue && o2.uint32(32).uint64(t2.positiveIntValue), 0 !== t2.negativeIntValue && o2.uint32(40).int64(t2.negativeIntValue), 0 !== t2.doubleValue && o2.uint32(49).double(t2.doubleValue), 0 !== t2.stringValue.length && o2.uint32(58).bytes(t2.stringValue), "" !== t2.aggregateValue && o2.uint32(66).string(t2.aggregateValue), "_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = Object.create(b());
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 2:
          i2.name.push(e2.UninterpretedOption_NamePart.decode(r2, r2.uint32()));
          break;
        case 3:
          i2.identifierValue = r2.string();
          break;
        case 4:
          i2.positiveIntValue = k(r2.uint64());
          break;
        case 5:
          i2.negativeIntValue = k(r2.int64());
          break;
        case 6:
          i2.doubleValue = r2.double();
          break;
        case 7:
          i2.stringValue = r2.bytes();
          break;
        case 8:
          i2.aggregateValue = r2.string();
          break;
        default:
          const n2 = r2.pos;
          r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(n2, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ name: Array.isArray(null == t2 ? void 0 : t2.name) ? t2.name.map((t3) => e2.UninterpretedOption_NamePart.fromJSON(t3)) : [], identifierValue: P(t2.identifierValue) ? String(t2.identifierValue) : "", positiveIntValue: P(t2.positiveIntValue) ? Number(t2.positiveIntValue) : 0, negativeIntValue: P(t2.negativeIntValue) ? Number(t2.negativeIntValue) : 0, doubleValue: P(t2.doubleValue) ? Number(t2.doubleValue) : 0, stringValue: P(t2.stringValue) ? O(t2.stringValue) : new Uint8Array(), aggregateValue: P(t2.aggregateValue) ? String(t2.aggregateValue) : "" }), toJSON(t2) {
    const n2 = {};
    return t2.name ? n2.name = t2.name.map((t3) => t3 ? e2.UninterpretedOption_NamePart.toJSON(t3) : void 0) : n2.name = [], void 0 !== t2.identifierValue && (n2.identifierValue = t2.identifierValue), void 0 !== t2.positiveIntValue && (n2.positiveIntValue = Math.round(t2.positiveIntValue)), void 0 !== t2.negativeIntValue && (n2.negativeIntValue = Math.round(t2.negativeIntValue)), void 0 !== t2.doubleValue && (n2.doubleValue = t2.doubleValue), void 0 !== t2.stringValue && (n2.stringValue = function(e3) {
      const t3 = [];
      return e3.forEach((e4) => {
        t3.push(String.fromCharCode(e4));
      }), N(t3.join(""));
    }(void 0 !== t2.stringValue ? t2.stringValue : new Uint8Array())), void 0 !== t2.aggregateValue && (n2.aggregateValue = t2.aggregateValue), n2;
  }, fromPartial(t2) {
    var n2, o2, r2, a2, i2, s2, c2;
    const d2 = Object.create(b());
    return d2.name = (null === (n2 = t2.name) || void 0 === n2 ? void 0 : n2.map((t3) => e2.UninterpretedOption_NamePart.fromPartial(t3))) || [], d2.identifierValue = null !== (o2 = t2.identifierValue) && void 0 !== o2 ? o2 : "", d2.positiveIntValue = null !== (r2 = t2.positiveIntValue) && void 0 !== r2 ? r2 : 0, d2.negativeIntValue = null !== (a2 = t2.negativeIntValue) && void 0 !== a2 ? a2 : 0, d2.doubleValue = null !== (i2 = t2.doubleValue) && void 0 !== i2 ? i2 : 0, d2.stringValue = null !== (s2 = t2.stringValue) && void 0 !== s2 ? s2 : new Uint8Array(), d2.aggregateValue = null !== (c2 = t2.aggregateValue) && void 0 !== c2 ? c2 : "", d2;
  } }, e2.UninterpretedOption_NamePart = { encode(e3, t2 = n.Writer.create()) {
    if ("" !== e3.namePart && t2.uint32(10).string(e3.namePart), true === e3.isExtension && t2.uint32(16).bool(e3.isExtension), "_unknownFields" in e3) {
      const n2 = e3._unknownFields;
      for (const e4 of Object.keys(n2)) {
        const o2 = n2[e4];
        for (const n3 of o2)
          t2.uint32(parseInt(e4, 10)), t2._push((e5, t3, n4) => t3.set(e5, n4), n3.length, n3);
      }
    }
    return t2;
  }, decode(e3, t2) {
    const o2 = e3 instanceof n.Reader ? e3 : new n.Reader(e3);
    let r2 = void 0 === t2 ? o2.len : o2.pos + t2;
    const a2 = /* @__PURE__ */ Object.create({ namePart: "", isExtension: false });
    for (a2._unknownFields = {}; o2.pos < r2; ) {
      const e4 = o2.uint32();
      switch (e4 >>> 3) {
        case 1:
          a2.namePart = o2.string();
          break;
        case 2:
          a2.isExtension = o2.bool();
          break;
        default:
          const t3 = o2.pos;
          o2.skipType(7 & e4), a2._unknownFields[e4] = [...a2._unknownFields[e4] || [], o2.buf.slice(t3, o2.pos)];
      }
    }
    return a2;
  }, fromJSON: (e3) => ({ namePart: P(e3.namePart) ? String(e3.namePart) : "", isExtension: !!P(e3.isExtension) && Boolean(e3.isExtension) }), toJSON(e3) {
    const t2 = {};
    return void 0 !== e3.namePart && (t2.namePart = e3.namePart), void 0 !== e3.isExtension && (t2.isExtension = e3.isExtension), t2;
  }, fromPartial(e3) {
    var t2, n2;
    const o2 = /* @__PURE__ */ Object.create({ namePart: "", isExtension: false });
    return o2.namePart = null !== (t2 = e3.namePart) && void 0 !== t2 ? t2 : "", o2.isExtension = null !== (n2 = e3.isExtension) && void 0 !== n2 && n2, o2;
  } }, e2.SourceCodeInfo = { encode(t2, o2 = n.Writer.create()) {
    for (const n2 of t2.location)
      e2.SourceCodeInfo_Location.encode(n2, o2.uint32(10).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ location: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      if (t3 >>> 3 == 1)
        i2.location.push(e2.SourceCodeInfo_Location.decode(r2, r2.uint32()));
      else {
        const e3 = r2.pos;
        r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(e3, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ location: Array.isArray(null == t2 ? void 0 : t2.location) ? t2.location.map((t3) => e2.SourceCodeInfo_Location.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return t2.location ? n2.location = t2.location.map((t3) => t3 ? e2.SourceCodeInfo_Location.toJSON(t3) : void 0) : n2.location = [], n2;
  }, fromPartial(t2) {
    var n2;
    const o2 = /* @__PURE__ */ Object.create({ location: [] });
    return o2.location = (null === (n2 = t2.location) || void 0 === n2 ? void 0 : n2.map((t3) => e2.SourceCodeInfo_Location.fromPartial(t3))) || [], o2;
  } }, e2.SourceCodeInfo_Location = { encode(e3, t2 = n.Writer.create()) {
    t2.uint32(10).fork();
    for (const n2 of e3.path)
      t2.int32(n2);
    t2.ldelim(), t2.uint32(18).fork();
    for (const n2 of e3.span)
      t2.int32(n2);
    t2.ldelim(), "" !== e3.leadingComments && t2.uint32(26).string(e3.leadingComments), "" !== e3.trailingComments && t2.uint32(34).string(e3.trailingComments);
    for (const n2 of e3.leadingDetachedComments)
      t2.uint32(50).string(n2);
    if ("_unknownFields" in e3) {
      const n2 = e3._unknownFields;
      for (const e4 of Object.keys(n2)) {
        const o2 = n2[e4];
        for (const n3 of o2)
          t2.uint32(parseInt(e4, 10)), t2._push((e5, t3, n4) => t3.set(e5, n4), n3.length, n3);
      }
    }
    return t2;
  }, decode(e3, t2) {
    const o2 = e3 instanceof n.Reader ? e3 : new n.Reader(e3);
    let r2 = void 0 === t2 ? o2.len : o2.pos + t2;
    const a2 = /* @__PURE__ */ Object.create({ path: [], span: [], leadingComments: "", trailingComments: "", leadingDetachedComments: [] });
    for (a2._unknownFields = {}; o2.pos < r2; ) {
      const e4 = o2.uint32();
      switch (e4 >>> 3) {
        case 1:
          if (2 == (7 & e4)) {
            const e5 = o2.uint32() + o2.pos;
            for (; o2.pos < e5; )
              a2.path.push(o2.int32());
          } else
            a2.path.push(o2.int32());
          break;
        case 2:
          if (2 == (7 & e4)) {
            const e5 = o2.uint32() + o2.pos;
            for (; o2.pos < e5; )
              a2.span.push(o2.int32());
          } else
            a2.span.push(o2.int32());
          break;
        case 3:
          a2.leadingComments = o2.string();
          break;
        case 4:
          a2.trailingComments = o2.string();
          break;
        case 6:
          a2.leadingDetachedComments.push(o2.string());
          break;
        default:
          const t3 = o2.pos;
          o2.skipType(7 & e4), a2._unknownFields[e4] = [...a2._unknownFields[e4] || [], o2.buf.slice(t3, o2.pos)];
      }
    }
    return a2;
  }, fromJSON: (e3) => ({ path: Array.isArray(null == e3 ? void 0 : e3.path) ? e3.path.map((e4) => Number(e4)) : [], span: Array.isArray(null == e3 ? void 0 : e3.span) ? e3.span.map((e4) => Number(e4)) : [], leadingComments: P(e3.leadingComments) ? String(e3.leadingComments) : "", trailingComments: P(e3.trailingComments) ? String(e3.trailingComments) : "", leadingDetachedComments: Array.isArray(null == e3 ? void 0 : e3.leadingDetachedComments) ? e3.leadingDetachedComments.map((e4) => String(e4)) : [] }), toJSON(e3) {
    const t2 = {};
    return e3.path ? t2.path = e3.path.map((e4) => Math.round(e4)) : t2.path = [], e3.span ? t2.span = e3.span.map((e4) => Math.round(e4)) : t2.span = [], void 0 !== e3.leadingComments && (t2.leadingComments = e3.leadingComments), void 0 !== e3.trailingComments && (t2.trailingComments = e3.trailingComments), e3.leadingDetachedComments ? t2.leadingDetachedComments = e3.leadingDetachedComments.map((e4) => e4) : t2.leadingDetachedComments = [], t2;
  }, fromPartial(e3) {
    var t2, n2, o2, r2, a2;
    const i2 = /* @__PURE__ */ Object.create({ path: [], span: [], leadingComments: "", trailingComments: "", leadingDetachedComments: [] });
    return i2.path = (null === (t2 = e3.path) || void 0 === t2 ? void 0 : t2.map((e4) => e4)) || [], i2.span = (null === (n2 = e3.span) || void 0 === n2 ? void 0 : n2.map((e4) => e4)) || [], i2.leadingComments = null !== (o2 = e3.leadingComments) && void 0 !== o2 ? o2 : "", i2.trailingComments = null !== (r2 = e3.trailingComments) && void 0 !== r2 ? r2 : "", i2.leadingDetachedComments = (null === (a2 = e3.leadingDetachedComments) || void 0 === a2 ? void 0 : a2.map((e4) => e4)) || [], i2;
  } }, e2.GeneratedCodeInfo = { encode(t2, o2 = n.Writer.create()) {
    for (const n2 of t2.annotation)
      e2.GeneratedCodeInfo_Annotation.encode(n2, o2.uint32(10).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          o2.uint32(parseInt(t3, 10)), o2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return o2;
  }, decode(t2, o2) {
    const r2 = t2 instanceof n.Reader ? t2 : new n.Reader(t2);
    let a2 = void 0 === o2 ? r2.len : r2.pos + o2;
    const i2 = /* @__PURE__ */ Object.create({ annotation: [] });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      if (t3 >>> 3 == 1)
        i2.annotation.push(e2.GeneratedCodeInfo_Annotation.decode(r2, r2.uint32()));
      else {
        const e3 = r2.pos;
        r2.skipType(7 & t3), i2._unknownFields[t3] = [...i2._unknownFields[t3] || [], r2.buf.slice(e3, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (t2) => ({ annotation: Array.isArray(null == t2 ? void 0 : t2.annotation) ? t2.annotation.map((t3) => e2.GeneratedCodeInfo_Annotation.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return t2.annotation ? n2.annotation = t2.annotation.map((t3) => t3 ? e2.GeneratedCodeInfo_Annotation.toJSON(t3) : void 0) : n2.annotation = [], n2;
  }, fromPartial(t2) {
    var n2;
    const o2 = /* @__PURE__ */ Object.create({ annotation: [] });
    return o2.annotation = (null === (n2 = t2.annotation) || void 0 === n2 ? void 0 : n2.map((t3) => e2.GeneratedCodeInfo_Annotation.fromPartial(t3))) || [], o2;
  } }, e2.GeneratedCodeInfo_Annotation = { encode(e3, t2 = n.Writer.create()) {
    t2.uint32(10).fork();
    for (const n2 of e3.path)
      t2.int32(n2);
    if (t2.ldelim(), "" !== e3.sourceFile && t2.uint32(18).string(e3.sourceFile), 0 !== e3.begin && t2.uint32(24).int32(e3.begin), 0 !== e3.end && t2.uint32(32).int32(e3.end), "_unknownFields" in e3) {
      const n2 = e3._unknownFields;
      for (const e4 of Object.keys(n2)) {
        const o2 = n2[e4];
        for (const n3 of o2)
          t2.uint32(parseInt(e4, 10)), t2._push((e5, t3, n4) => t3.set(e5, n4), n3.length, n3);
      }
    }
    return t2;
  }, decode(e3, t2) {
    const o2 = e3 instanceof n.Reader ? e3 : new n.Reader(e3);
    let r2 = void 0 === t2 ? o2.len : o2.pos + t2;
    const a2 = /* @__PURE__ */ Object.create({ path: [], sourceFile: "", begin: 0, end: 0 });
    for (a2._unknownFields = {}; o2.pos < r2; ) {
      const e4 = o2.uint32();
      switch (e4 >>> 3) {
        case 1:
          if (2 == (7 & e4)) {
            const e5 = o2.uint32() + o2.pos;
            for (; o2.pos < e5; )
              a2.path.push(o2.int32());
          } else
            a2.path.push(o2.int32());
          break;
        case 2:
          a2.sourceFile = o2.string();
          break;
        case 3:
          a2.begin = o2.int32();
          break;
        case 4:
          a2.end = o2.int32();
          break;
        default:
          const t3 = o2.pos;
          o2.skipType(7 & e4), a2._unknownFields[e4] = [...a2._unknownFields[e4] || [], o2.buf.slice(t3, o2.pos)];
      }
    }
    return a2;
  }, fromJSON: (e3) => ({ path: Array.isArray(null == e3 ? void 0 : e3.path) ? e3.path.map((e4) => Number(e4)) : [], sourceFile: P(e3.sourceFile) ? String(e3.sourceFile) : "", begin: P(e3.begin) ? Number(e3.begin) : 0, end: P(e3.end) ? Number(e3.end) : 0 }), toJSON(e3) {
    const t2 = {};
    return e3.path ? t2.path = e3.path.map((e4) => Math.round(e4)) : t2.path = [], void 0 !== e3.sourceFile && (t2.sourceFile = e3.sourceFile), void 0 !== e3.begin && (t2.begin = Math.round(e3.begin)), void 0 !== e3.end && (t2.end = Math.round(e3.end)), t2;
  }, fromPartial(e3) {
    var t2, n2, o2, r2;
    const a2 = /* @__PURE__ */ Object.create({ path: [], sourceFile: "", begin: 0, end: 0 });
    return a2.path = (null === (t2 = e3.path) || void 0 === t2 ? void 0 : t2.map((e4) => e4)) || [], a2.sourceFile = null !== (n2 = e3.sourceFile) && void 0 !== n2 ? n2 : "", a2.begin = null !== (o2 = e3.begin) && void 0 !== o2 ? o2 : 0, a2.end = null !== (r2 = e3.end) && void 0 !== r2 ? r2 : 0, a2;
  } };
  var A = (() => {
    if (void 0 !== A)
      return A;
    if ("undefined" != typeof self)
      return self;
    if ("undefined" != typeof window)
      return window;
    if (void 0 !== commonjsGlobal)
      return commonjsGlobal;
    throw "Unable to locate global object";
  })();
  const I = A.atob || ((e3) => A.Buffer.from(e3, "base64").toString("binary"));
  function O(e3) {
    const t2 = I(e3), n2 = new Uint8Array(t2.length);
    for (let e4 = 0; e4 < t2.length; ++e4)
      n2[e4] = t2.charCodeAt(e4);
    return n2;
  }
  const N = A.btoa || ((e3) => A.Buffer.from(e3, "binary").toString("base64"));
  function k(e3) {
    if (e3.gt(Number.MAX_SAFE_INTEGER))
      throw new A.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return e3.toNumber();
  }
  function P(e3) {
    return null != e3;
  }
  n.util.Long !== t && (n.util.Long = t, n.configure());
}(descriptor);
var plugin = {};
!function(e2) {
  Object.defineProperty(e2, "__esModule", { value: true }), e2.CodeGeneratorResponse_File = e2.CodeGeneratorResponse = e2.CodeGeneratorRequest = e2.Version = e2.codeGeneratorResponse_FeatureToJSON = e2.codeGeneratorResponse_FeatureFromJSON = e2.CodeGeneratorResponse_Feature = void 0;
  const t = long, n = descriptor, o = minimal;
  var r;
  !function(e3) {
    e3[e3.FEATURE_NONE = 0] = "FEATURE_NONE", e3[e3.FEATURE_PROTO3_OPTIONAL = 1] = "FEATURE_PROTO3_OPTIONAL", e3[e3.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  }(r = e2.CodeGeneratorResponse_Feature || (e2.CodeGeneratorResponse_Feature = {})), e2.codeGeneratorResponse_FeatureFromJSON = function(e3) {
    switch (e3) {
      case 0:
      case "FEATURE_NONE":
        return r.FEATURE_NONE;
      case 1:
      case "FEATURE_PROTO3_OPTIONAL":
        return r.FEATURE_PROTO3_OPTIONAL;
      default:
        return r.UNRECOGNIZED;
    }
  }, e2.codeGeneratorResponse_FeatureToJSON = function(e3) {
    switch (e3) {
      case r.FEATURE_NONE:
        return "FEATURE_NONE";
      case r.FEATURE_PROTO3_OPTIONAL:
        return "FEATURE_PROTO3_OPTIONAL";
      case r.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }, e2.Version = { encode(e3, t2 = o.Writer.create()) {
    if (0 !== e3.major && t2.uint32(8).int32(e3.major), 0 !== e3.minor && t2.uint32(16).int32(e3.minor), 0 !== e3.patch && t2.uint32(24).int32(e3.patch), "" !== e3.suffix && t2.uint32(34).string(e3.suffix), "_unknownFields" in e3) {
      const n2 = e3._unknownFields;
      for (const e4 of Object.keys(n2)) {
        const o2 = n2[e4];
        for (const n3 of o2)
          t2.uint32(parseInt(e4, 10)), t2._push((e5, t3, n4) => t3.set(e5, n4), n3.length, n3);
      }
    }
    return t2;
  }, decode(e3, t2) {
    const n2 = e3 instanceof o.Reader ? e3 : new o.Reader(e3);
    let r2 = void 0 === t2 ? n2.len : n2.pos + t2;
    const a2 = /* @__PURE__ */ Object.create({ major: 0, minor: 0, patch: 0, suffix: "" });
    for (a2._unknownFields = {}; n2.pos < r2; ) {
      const e4 = n2.uint32();
      switch (e4 >>> 3) {
        case 1:
          a2.major = n2.int32();
          break;
        case 2:
          a2.minor = n2.int32();
          break;
        case 3:
          a2.patch = n2.int32();
          break;
        case 4:
          a2.suffix = n2.string();
          break;
        default:
          const t3 = n2.pos;
          n2.skipType(7 & e4), a2._unknownFields[e4] = [...a2._unknownFields[e4] || [], n2.buf.slice(t3, n2.pos)];
      }
    }
    return a2;
  }, fromJSON: (e3) => ({ major: s(e3.major) ? Number(e3.major) : 0, minor: s(e3.minor) ? Number(e3.minor) : 0, patch: s(e3.patch) ? Number(e3.patch) : 0, suffix: s(e3.suffix) ? String(e3.suffix) : "" }), toJSON(e3) {
    const t2 = {};
    return void 0 !== e3.major && (t2.major = Math.round(e3.major)), void 0 !== e3.minor && (t2.minor = Math.round(e3.minor)), void 0 !== e3.patch && (t2.patch = Math.round(e3.patch)), void 0 !== e3.suffix && (t2.suffix = e3.suffix), t2;
  }, fromPartial(e3) {
    var t2, n2, o2, r2;
    const a2 = /* @__PURE__ */ Object.create({ major: 0, minor: 0, patch: 0, suffix: "" });
    return a2.major = null !== (t2 = e3.major) && void 0 !== t2 ? t2 : 0, a2.minor = null !== (n2 = e3.minor) && void 0 !== n2 ? n2 : 0, a2.patch = null !== (o2 = e3.patch) && void 0 !== o2 ? o2 : 0, a2.suffix = null !== (r2 = e3.suffix) && void 0 !== r2 ? r2 : "", a2;
  } }, e2.CodeGeneratorRequest = { encode(t2, r2 = o.Writer.create()) {
    for (const e3 of t2.fileToGenerate)
      r2.uint32(10).string(e3);
    "" !== t2.parameter && r2.uint32(18).string(t2.parameter);
    for (const e3 of t2.protoFile)
      n.FileDescriptorProto.encode(e3, r2.uint32(122).fork()).ldelim();
    if (void 0 !== t2.compilerVersion && e2.Version.encode(t2.compilerVersion, r2.uint32(26).fork()).ldelim(), "_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const n2 = e3[t3];
        for (const e4 of n2)
          r2.uint32(parseInt(t3, 10)), r2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return r2;
  }, decode(t2, r2) {
    const a2 = t2 instanceof o.Reader ? t2 : new o.Reader(t2);
    let i2 = void 0 === r2 ? a2.len : a2.pos + r2;
    const s2 = /* @__PURE__ */ Object.create({ fileToGenerate: [], parameter: "", protoFile: [], compilerVersion: void 0 });
    for (s2._unknownFields = {}; a2.pos < i2; ) {
      const t3 = a2.uint32();
      switch (t3 >>> 3) {
        case 1:
          s2.fileToGenerate.push(a2.string());
          break;
        case 2:
          s2.parameter = a2.string();
          break;
        case 15:
          s2.protoFile.push(n.FileDescriptorProto.decode(a2, a2.uint32()));
          break;
        case 3:
          s2.compilerVersion = e2.Version.decode(a2, a2.uint32());
          break;
        default:
          const o2 = a2.pos;
          a2.skipType(7 & t3), s2._unknownFields[t3] = [...s2._unknownFields[t3] || [], a2.buf.slice(o2, a2.pos)];
      }
    }
    return s2;
  }, fromJSON: (t2) => ({ fileToGenerate: Array.isArray(null == t2 ? void 0 : t2.fileToGenerate) ? t2.fileToGenerate.map((e3) => String(e3)) : [], parameter: s(t2.parameter) ? String(t2.parameter) : "", protoFile: Array.isArray(null == t2 ? void 0 : t2.protoFile) ? t2.protoFile.map((e3) => n.FileDescriptorProto.fromJSON(e3)) : [], compilerVersion: s(t2.compilerVersion) ? e2.Version.fromJSON(t2.compilerVersion) : void 0 }), toJSON(t2) {
    const o2 = {};
    return t2.fileToGenerate ? o2.fileToGenerate = t2.fileToGenerate.map((e3) => e3) : o2.fileToGenerate = [], void 0 !== t2.parameter && (o2.parameter = t2.parameter), t2.protoFile ? o2.protoFile = t2.protoFile.map((e3) => e3 ? n.FileDescriptorProto.toJSON(e3) : void 0) : o2.protoFile = [], void 0 !== t2.compilerVersion && (o2.compilerVersion = t2.compilerVersion ? e2.Version.toJSON(t2.compilerVersion) : void 0), o2;
  }, fromPartial(t2) {
    var o2, r2, a2;
    const i2 = /* @__PURE__ */ Object.create({ fileToGenerate: [], parameter: "", protoFile: [], compilerVersion: void 0 });
    return i2.fileToGenerate = (null === (o2 = t2.fileToGenerate) || void 0 === o2 ? void 0 : o2.map((e3) => e3)) || [], i2.parameter = null !== (r2 = t2.parameter) && void 0 !== r2 ? r2 : "", i2.protoFile = (null === (a2 = t2.protoFile) || void 0 === a2 ? void 0 : a2.map((e3) => n.FileDescriptorProto.fromPartial(e3))) || [], i2.compilerVersion = void 0 !== t2.compilerVersion && null !== t2.compilerVersion ? e2.Version.fromPartial(t2.compilerVersion) : void 0, i2;
  } }, e2.CodeGeneratorResponse = { encode(t2, n2 = o.Writer.create()) {
    "" !== t2.error && n2.uint32(10).string(t2.error), 0 !== t2.supportedFeatures && n2.uint32(16).uint64(t2.supportedFeatures);
    for (const o2 of t2.file)
      e2.CodeGeneratorResponse_File.encode(o2, n2.uint32(122).fork()).ldelim();
    if ("_unknownFields" in t2) {
      const e3 = t2._unknownFields;
      for (const t3 of Object.keys(e3)) {
        const o2 = e3[t3];
        for (const e4 of o2)
          n2.uint32(parseInt(t3, 10)), n2._push((e5, t4, n3) => t4.set(e5, n3), e4.length, e4);
      }
    }
    return n2;
  }, decode(t2, n2) {
    const r2 = t2 instanceof o.Reader ? t2 : new o.Reader(t2);
    let a2 = void 0 === n2 ? r2.len : r2.pos + n2;
    const s2 = /* @__PURE__ */ Object.create({ error: "", supportedFeatures: 0, file: [] });
    for (s2._unknownFields = {}; r2.pos < a2; ) {
      const t3 = r2.uint32();
      switch (t3 >>> 3) {
        case 1:
          s2.error = r2.string();
          break;
        case 2:
          s2.supportedFeatures = i(r2.uint64());
          break;
        case 15:
          s2.file.push(e2.CodeGeneratorResponse_File.decode(r2, r2.uint32()));
          break;
        default:
          const n3 = r2.pos;
          r2.skipType(7 & t3), s2._unknownFields[t3] = [...s2._unknownFields[t3] || [], r2.buf.slice(n3, r2.pos)];
      }
    }
    return s2;
  }, fromJSON: (t2) => ({ error: s(t2.error) ? String(t2.error) : "", supportedFeatures: s(t2.supportedFeatures) ? Number(t2.supportedFeatures) : 0, file: Array.isArray(null == t2 ? void 0 : t2.file) ? t2.file.map((t3) => e2.CodeGeneratorResponse_File.fromJSON(t3)) : [] }), toJSON(t2) {
    const n2 = {};
    return void 0 !== t2.error && (n2.error = t2.error), void 0 !== t2.supportedFeatures && (n2.supportedFeatures = Math.round(t2.supportedFeatures)), t2.file ? n2.file = t2.file.map((t3) => t3 ? e2.CodeGeneratorResponse_File.toJSON(t3) : void 0) : n2.file = [], n2;
  }, fromPartial(t2) {
    var n2, o2, r2;
    const a2 = /* @__PURE__ */ Object.create({ error: "", supportedFeatures: 0, file: [] });
    return a2.error = null !== (n2 = t2.error) && void 0 !== n2 ? n2 : "", a2.supportedFeatures = null !== (o2 = t2.supportedFeatures) && void 0 !== o2 ? o2 : 0, a2.file = (null === (r2 = t2.file) || void 0 === r2 ? void 0 : r2.map((t3) => e2.CodeGeneratorResponse_File.fromPartial(t3))) || [], a2;
  } }, e2.CodeGeneratorResponse_File = { encode(e3, t2 = o.Writer.create()) {
    if ("" !== e3.name && t2.uint32(10).string(e3.name), "" !== e3.insertionPoint && t2.uint32(18).string(e3.insertionPoint), "" !== e3.content && t2.uint32(122).string(e3.content), void 0 !== e3.generatedCodeInfo && n.GeneratedCodeInfo.encode(e3.generatedCodeInfo, t2.uint32(130).fork()).ldelim(), "_unknownFields" in e3) {
      const n2 = e3._unknownFields;
      for (const e4 of Object.keys(n2)) {
        const o2 = n2[e4];
        for (const n3 of o2)
          t2.uint32(parseInt(e4, 10)), t2._push((e5, t3, n4) => t3.set(e5, n4), n3.length, n3);
      }
    }
    return t2;
  }, decode(e3, t2) {
    const r2 = e3 instanceof o.Reader ? e3 : new o.Reader(e3);
    let a2 = void 0 === t2 ? r2.len : r2.pos + t2;
    const i2 = /* @__PURE__ */ Object.create({ name: "", insertionPoint: "", content: "", generatedCodeInfo: void 0 });
    for (i2._unknownFields = {}; r2.pos < a2; ) {
      const e4 = r2.uint32();
      switch (e4 >>> 3) {
        case 1:
          i2.name = r2.string();
          break;
        case 2:
          i2.insertionPoint = r2.string();
          break;
        case 15:
          i2.content = r2.string();
          break;
        case 16:
          i2.generatedCodeInfo = n.GeneratedCodeInfo.decode(r2, r2.uint32());
          break;
        default:
          const t3 = r2.pos;
          r2.skipType(7 & e4), i2._unknownFields[e4] = [...i2._unknownFields[e4] || [], r2.buf.slice(t3, r2.pos)];
      }
    }
    return i2;
  }, fromJSON: (e3) => ({ name: s(e3.name) ? String(e3.name) : "", insertionPoint: s(e3.insertionPoint) ? String(e3.insertionPoint) : "", content: s(e3.content) ? String(e3.content) : "", generatedCodeInfo: s(e3.generatedCodeInfo) ? n.GeneratedCodeInfo.fromJSON(e3.generatedCodeInfo) : void 0 }), toJSON(e3) {
    const t2 = {};
    return void 0 !== e3.name && (t2.name = e3.name), void 0 !== e3.insertionPoint && (t2.insertionPoint = e3.insertionPoint), void 0 !== e3.content && (t2.content = e3.content), void 0 !== e3.generatedCodeInfo && (t2.generatedCodeInfo = e3.generatedCodeInfo ? n.GeneratedCodeInfo.toJSON(e3.generatedCodeInfo) : void 0), t2;
  }, fromPartial(e3) {
    var t2, o2, r2;
    const a2 = /* @__PURE__ */ Object.create({ name: "", insertionPoint: "", content: "", generatedCodeInfo: void 0 });
    return a2.name = null !== (t2 = e3.name) && void 0 !== t2 ? t2 : "", a2.insertionPoint = null !== (o2 = e3.insertionPoint) && void 0 !== o2 ? o2 : "", a2.content = null !== (r2 = e3.content) && void 0 !== r2 ? r2 : "", a2.generatedCodeInfo = void 0 !== e3.generatedCodeInfo && null !== e3.generatedCodeInfo ? n.GeneratedCodeInfo.fromPartial(e3.generatedCodeInfo) : void 0, a2;
  } };
  var a = (() => {
    if (void 0 !== a)
      return a;
    if ("undefined" != typeof self)
      return self;
    if ("undefined" != typeof window)
      return window;
    if (void 0 !== commonjsGlobal)
      return commonjsGlobal;
    throw "Unable to locate global object";
  })();
  function i(e3) {
    if (e3.gt(Number.MAX_SAFE_INTEGER))
      throw new a.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return e3.toNumber();
  }
  function s(e3) {
    return null != e3;
  }
  o.util.Long !== t && (o.util.Long = t, o.configure());
}(plugin), function(e2) {
  var t = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e3, t2, n2, o) {
    void 0 === o && (o = n2);
    var r = Object.getOwnPropertyDescriptor(t2, n2);
    r && !("get" in r ? !t2.__esModule : r.writable || r.configurable) || (r = { enumerable: true, get: function() {
      return t2[n2];
    } }), Object.defineProperty(e3, o, r);
  } : function(e3, t2, n2, o) {
    void 0 === o && (o = n2), e3[o] = t2[n2];
  }), n = commonjsGlobal && commonjsGlobal.__exportStar || function(e3, n2) {
    for (var o in e3)
      "default" === o || Object.prototype.hasOwnProperty.call(n2, o) || t(n2, e3, o);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), n(descriptor, e2), n(plugin, e2);
}(dist);
var protobufPackage$1 = "proto";
var CreateAssetContract_EnumAssetType;
var StakingInfo_InterestType;
var AssetTriggerContract_EnumTriggerType;
var ClaimContract_EnumClaimType;
var VoteContract_EnumVoteType;
var ConfigITOContract_EnumITOStatus;
var BuyContract_EnumBuyType;
var SellContract_EnumMarketType;
var AccPermission_AccPermissionType;
function createAssetContract_EnumAssetTypeFromJSON(e2) {
  switch (e2) {
    case 0:
    case "Fungible":
      return CreateAssetContract_EnumAssetType.Fungible;
    case 1:
    case "NonFungible":
      return CreateAssetContract_EnumAssetType.NonFungible;
    default:
      return CreateAssetContract_EnumAssetType.UNRECOGNIZED;
  }
}
function createAssetContract_EnumAssetTypeToJSON(e2) {
  switch (e2) {
    case CreateAssetContract_EnumAssetType.Fungible:
      return 0;
    case CreateAssetContract_EnumAssetType.NonFungible:
      return 1;
    case CreateAssetContract_EnumAssetType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function stakingInfo_InterestTypeFromJSON(e2) {
  switch (e2) {
    case 0:
    case "APRI":
      return StakingInfo_InterestType.APRI;
    case 1:
    case "FPRI":
      return StakingInfo_InterestType.FPRI;
    default:
      return StakingInfo_InterestType.UNRECOGNIZED;
  }
}
function stakingInfo_InterestTypeToJSON(e2) {
  switch (e2) {
    case StakingInfo_InterestType.APRI:
      return 0;
    case StakingInfo_InterestType.FPRI:
      return 1;
    case StakingInfo_InterestType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function assetTriggerContract_EnumTriggerTypeFromJSON(e2) {
  switch (e2) {
    case 0:
    case "Mint":
      return AssetTriggerContract_EnumTriggerType.Mint;
    case 1:
    case "Burn":
      return AssetTriggerContract_EnumTriggerType.Burn;
    case 2:
    case "Wipe":
      return AssetTriggerContract_EnumTriggerType.Wipe;
    case 3:
    case "Pause":
      return AssetTriggerContract_EnumTriggerType.Pause;
    case 4:
    case "Resume":
      return AssetTriggerContract_EnumTriggerType.Resume;
    case 5:
    case "ChangeOwner":
      return AssetTriggerContract_EnumTriggerType.ChangeOwner;
    case 6:
    case "AddRole":
      return AssetTriggerContract_EnumTriggerType.AddRole;
    case 7:
    case "RemoveRole":
      return AssetTriggerContract_EnumTriggerType.RemoveRole;
    case 8:
    case "UpdateMetadata":
      return AssetTriggerContract_EnumTriggerType.UpdateMetadata;
    case 9:
    case "StopNFTMint":
      return AssetTriggerContract_EnumTriggerType.StopNFTMint;
    case 10:
    case "UpdateLogo":
      return AssetTriggerContract_EnumTriggerType.UpdateLogo;
    case 11:
    case "UpdateURIs":
      return AssetTriggerContract_EnumTriggerType.UpdateURIs;
    case 12:
    case "ChangeRoyaltiesReceiver":
      return AssetTriggerContract_EnumTriggerType.ChangeRoyaltiesReceiver;
    case 13:
    case "UpdateStaking":
      return AssetTriggerContract_EnumTriggerType.UpdateStaking;
    default:
      return AssetTriggerContract_EnumTriggerType.UNRECOGNIZED;
  }
}
function assetTriggerContract_EnumTriggerTypeToJSON(e2) {
  switch (e2) {
    case AssetTriggerContract_EnumTriggerType.Mint:
      return 0;
    case AssetTriggerContract_EnumTriggerType.Burn:
      return 1;
    case AssetTriggerContract_EnumTriggerType.Wipe:
      return 2;
    case AssetTriggerContract_EnumTriggerType.Pause:
      return 3;
    case AssetTriggerContract_EnumTriggerType.Resume:
      return 4;
    case AssetTriggerContract_EnumTriggerType.ChangeOwner:
      return 5;
    case AssetTriggerContract_EnumTriggerType.AddRole:
      return 6;
    case AssetTriggerContract_EnumTriggerType.RemoveRole:
      return 7;
    case AssetTriggerContract_EnumTriggerType.UpdateMetadata:
      return 8;
    case AssetTriggerContract_EnumTriggerType.StopNFTMint:
      return 9;
    case AssetTriggerContract_EnumTriggerType.UpdateLogo:
      return 10;
    case AssetTriggerContract_EnumTriggerType.UpdateURIs:
      return 11;
    case AssetTriggerContract_EnumTriggerType.ChangeRoyaltiesReceiver:
      return 12;
    case AssetTriggerContract_EnumTriggerType.UpdateStaking:
      return 13;
    case AssetTriggerContract_EnumTriggerType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function claimContract_EnumClaimTypeFromJSON(e2) {
  switch (e2) {
    case 0:
    case "StakingClaim":
      return ClaimContract_EnumClaimType.StakingClaim;
    case 1:
    case "AllowanceClaim":
      return ClaimContract_EnumClaimType.AllowanceClaim;
    case 2:
    case "MarketClaim":
      return ClaimContract_EnumClaimType.MarketClaim;
    default:
      return ClaimContract_EnumClaimType.UNRECOGNIZED;
  }
}
function claimContract_EnumClaimTypeToJSON(e2) {
  switch (e2) {
    case ClaimContract_EnumClaimType.StakingClaim:
      return 0;
    case ClaimContract_EnumClaimType.AllowanceClaim:
      return 1;
    case ClaimContract_EnumClaimType.MarketClaim:
      return 2;
    case ClaimContract_EnumClaimType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function voteContract_EnumVoteTypeFromJSON(e2) {
  switch (e2) {
    case 0:
    case "Yes":
      return VoteContract_EnumVoteType.Yes;
    case 1:
    case "No":
      return VoteContract_EnumVoteType.No;
    default:
      return VoteContract_EnumVoteType.UNRECOGNIZED;
  }
}
function voteContract_EnumVoteTypeToJSON(e2) {
  switch (e2) {
    case VoteContract_EnumVoteType.Yes:
      return 0;
    case VoteContract_EnumVoteType.No:
      return 1;
    case VoteContract_EnumVoteType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function configITOContract_EnumITOStatusFromJSON(e2) {
  switch (e2) {
    case 0:
    case "DefaultITO":
      return ConfigITOContract_EnumITOStatus.DefaultITO;
    case 1:
    case "ActiveITO":
      return ConfigITOContract_EnumITOStatus.ActiveITO;
    case 2:
    case "PausedITO":
      return ConfigITOContract_EnumITOStatus.PausedITO;
    default:
      return ConfigITOContract_EnumITOStatus.UNRECOGNIZED;
  }
}
function configITOContract_EnumITOStatusToJSON(e2) {
  switch (e2) {
    case ConfigITOContract_EnumITOStatus.DefaultITO:
      return 0;
    case ConfigITOContract_EnumITOStatus.ActiveITO:
      return 1;
    case ConfigITOContract_EnumITOStatus.PausedITO:
      return 2;
    case ConfigITOContract_EnumITOStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}
function buyContract_EnumBuyTypeFromJSON(e2) {
  switch (e2) {
    case 0:
    case "ITOBuy":
      return BuyContract_EnumBuyType.ITOBuy;
    case 1:
    case "MarketBuy":
      return BuyContract_EnumBuyType.MarketBuy;
    default:
      return BuyContract_EnumBuyType.UNRECOGNIZED;
  }
}
function buyContract_EnumBuyTypeToJSON(e2) {
  switch (e2) {
    case BuyContract_EnumBuyType.ITOBuy:
      return 0;
    case BuyContract_EnumBuyType.MarketBuy:
      return 1;
    case BuyContract_EnumBuyType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function sellContract_EnumMarketTypeFromJSON(e2) {
  switch (e2) {
    case 0:
    case "BuyItNowMarket":
      return SellContract_EnumMarketType.BuyItNowMarket;
    case 1:
    case "AuctionMarket":
      return SellContract_EnumMarketType.AuctionMarket;
    default:
      return SellContract_EnumMarketType.UNRECOGNIZED;
  }
}
function sellContract_EnumMarketTypeToJSON(e2) {
  switch (e2) {
    case SellContract_EnumMarketType.BuyItNowMarket:
      return 0;
    case SellContract_EnumMarketType.AuctionMarket:
      return 1;
    case SellContract_EnumMarketType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function accPermission_AccPermissionTypeFromJSON(e2) {
  switch (e2) {
    case 0:
    case "Owner":
      return AccPermission_AccPermissionType.Owner;
    case 1:
    case "User":
      return AccPermission_AccPermissionType.User;
    default:
      return AccPermission_AccPermissionType.UNRECOGNIZED;
  }
}
function accPermission_AccPermissionTypeToJSON(e2) {
  switch (e2) {
    case AccPermission_AccPermissionType.Owner:
      return 0;
    case AccPermission_AccPermissionType.User:
      return 1;
    case AccPermission_AccPermissionType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseTransferContract() {
  return { ToAddress: new Uint8Array(), AssetID: new Uint8Array(), Amount: 0 };
}
!function(e2) {
  e2[e2.Fungible = 0] = "Fungible", e2[e2.NonFungible = 1] = "NonFungible", e2[e2.UNRECOGNIZED = -1] = "UNRECOGNIZED";
}(CreateAssetContract_EnumAssetType || (CreateAssetContract_EnumAssetType = {})), function(e2) {
  e2[e2.APRI = 0] = "APRI", e2[e2.FPRI = 1] = "FPRI", e2[e2.UNRECOGNIZED = -1] = "UNRECOGNIZED";
}(StakingInfo_InterestType || (StakingInfo_InterestType = {})), function(e2) {
  e2[e2.Mint = 0] = "Mint", e2[e2.Burn = 1] = "Burn", e2[e2.Wipe = 2] = "Wipe", e2[e2.Pause = 3] = "Pause", e2[e2.Resume = 4] = "Resume", e2[e2.ChangeOwner = 5] = "ChangeOwner", e2[e2.AddRole = 6] = "AddRole", e2[e2.RemoveRole = 7] = "RemoveRole", e2[e2.UpdateMetadata = 8] = "UpdateMetadata", e2[e2.StopNFTMint = 9] = "StopNFTMint", e2[e2.UpdateLogo = 10] = "UpdateLogo", e2[e2.UpdateURIs = 11] = "UpdateURIs", e2[e2.ChangeRoyaltiesReceiver = 12] = "ChangeRoyaltiesReceiver", e2[e2.UpdateStaking = 13] = "UpdateStaking", e2[e2.UNRECOGNIZED = -1] = "UNRECOGNIZED";
}(AssetTriggerContract_EnumTriggerType || (AssetTriggerContract_EnumTriggerType = {})), function(e2) {
  e2[e2.StakingClaim = 0] = "StakingClaim", e2[e2.AllowanceClaim = 1] = "AllowanceClaim", e2[e2.MarketClaim = 2] = "MarketClaim", e2[e2.UNRECOGNIZED = -1] = "UNRECOGNIZED";
}(ClaimContract_EnumClaimType || (ClaimContract_EnumClaimType = {})), function(e2) {
  e2[e2.Yes = 0] = "Yes", e2[e2.No = 1] = "No", e2[e2.UNRECOGNIZED = -1] = "UNRECOGNIZED";
}(VoteContract_EnumVoteType || (VoteContract_EnumVoteType = {})), function(e2) {
  e2[e2.DefaultITO = 0] = "DefaultITO", e2[e2.ActiveITO = 1] = "ActiveITO", e2[e2.PausedITO = 2] = "PausedITO", e2[e2.UNRECOGNIZED = -1] = "UNRECOGNIZED";
}(ConfigITOContract_EnumITOStatus || (ConfigITOContract_EnumITOStatus = {})), function(e2) {
  e2[e2.ITOBuy = 0] = "ITOBuy", e2[e2.MarketBuy = 1] = "MarketBuy", e2[e2.UNRECOGNIZED = -1] = "UNRECOGNIZED";
}(BuyContract_EnumBuyType || (BuyContract_EnumBuyType = {})), function(e2) {
  e2[e2.BuyItNowMarket = 0] = "BuyItNowMarket", e2[e2.AuctionMarket = 1] = "AuctionMarket", e2[e2.UNRECOGNIZED = -1] = "UNRECOGNIZED";
}(SellContract_EnumMarketType || (SellContract_EnumMarketType = {})), function(e2) {
  e2[e2.Owner = 0] = "Owner", e2[e2.User = 1] = "User", e2[e2.UNRECOGNIZED = -1] = "UNRECOGNIZED";
}(AccPermission_AccPermissionType || (AccPermission_AccPermissionType = {}));
var TransferContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.ToAddress && 0 !== e2.ToAddress.length && t.uint32(10).bytes(e2.ToAddress), void 0 !== e2.AssetID && 0 !== e2.AssetID.length && t.uint32(18).bytes(e2.AssetID), void 0 !== e2.Amount && 0 !== e2.Amount && t.uint32(24).int64(e2.Amount), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseTransferContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.ToAddress = n.bytes();
        break;
      case 2:
        r.AssetID = n.bytes();
        break;
      case 3:
        r.Amount = longToNumber$1(n.int64());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ ToAddress: isSet$2(e2.ToAddress) ? bytesFromBase64$2(e2.ToAddress) : new Uint8Array(), AssetID: isSet$2(e2.AssetID) ? bytesFromBase64$2(e2.AssetID) : new Uint8Array(), Amount: isSet$2(e2.Amount) ? Number(e2.Amount) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.ToAddress && (t.ToAddress = base64FromBytes$2(void 0 !== e2.ToAddress ? e2.ToAddress : new Uint8Array())), void 0 !== e2.AssetID && (t.AssetID = base64FromBytes$2(void 0 !== e2.AssetID ? e2.AssetID : new Uint8Array())), void 0 !== e2.Amount && (t.Amount = Math.round(e2.Amount)), t;
}, fromPartial(e2) {
  var t, n, o;
  const r = createBaseTransferContract();
  return r.ToAddress = null !== (t = e2.ToAddress) && void 0 !== t ? t : new Uint8Array(), r.AssetID = null !== (n = e2.AssetID) && void 0 !== n ? n : new Uint8Array(), r.Amount = null !== (o = e2.Amount) && void 0 !== o ? o : 0, r;
} };
function createBaseCreateAssetContract() {
  return { Type: 0, Name: new Uint8Array(), Ticker: new Uint8Array(), OwnerAddress: new Uint8Array(), Logo: "", URIs: {}, Precision: 0, InitialSupply: 0, MaxSupply: 0, Royalties: void 0, Properties: void 0, Attributes: void 0, Staking: void 0, Roles: [] };
}
var CreateAssetContract = { encode(e2, t = minimal.Writer.create()) {
  if (void 0 !== e2.Type && 0 !== e2.Type && t.uint32(8).int32(e2.Type), void 0 !== e2.Name && 0 !== e2.Name.length && t.uint32(18).bytes(e2.Name), void 0 !== e2.Ticker && 0 !== e2.Ticker.length && t.uint32(26).bytes(e2.Ticker), void 0 !== e2.OwnerAddress && 0 !== e2.OwnerAddress.length && t.uint32(34).bytes(e2.OwnerAddress), void 0 !== e2.Logo && "" !== e2.Logo && t.uint32(42).string(e2.Logo), Object.entries(e2.URIs || {}).forEach(([e3, n]) => {
    CreateAssetContract_URIsEntry.encode({ key: e3, value: n }, t.uint32(50).fork()).ldelim();
  }), void 0 !== e2.Precision && 0 !== e2.Precision && t.uint32(56).uint32(e2.Precision), void 0 !== e2.InitialSupply && 0 !== e2.InitialSupply && t.uint32(64).int64(e2.InitialSupply), void 0 !== e2.MaxSupply && 0 !== e2.MaxSupply && t.uint32(72).int64(e2.MaxSupply), void 0 !== e2.Royalties && RoyaltiesInfo.encode(e2.Royalties, t.uint32(82).fork()).ldelim(), void 0 !== e2.Properties && PropertiesInfo.encode(e2.Properties, t.uint32(90).fork()).ldelim(), void 0 !== e2.Attributes && AttributesInfo.encode(e2.Attributes, t.uint32(98).fork()).ldelim(), void 0 !== e2.Staking && StakingInfo.encode(e2.Staking, t.uint32(106).fork()).ldelim(), void 0 !== e2.Roles && 0 !== e2.Roles.length)
    for (const n of e2.Roles)
      RolesInfo.encode(n, t.uint32(114).fork()).ldelim();
  return t;
}, decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseCreateAssetContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.Type = n.int32();
        break;
      case 2:
        r.Name = n.bytes();
        break;
      case 3:
        r.Ticker = n.bytes();
        break;
      case 4:
        r.OwnerAddress = n.bytes();
        break;
      case 5:
        r.Logo = n.string();
        break;
      case 6:
        const t2 = CreateAssetContract_URIsEntry.decode(n, n.uint32());
        void 0 !== t2.value && (r.URIs[t2.key] = t2.value);
        break;
      case 7:
        r.Precision = n.uint32();
        break;
      case 8:
        r.InitialSupply = longToNumber$1(n.int64());
        break;
      case 9:
        r.MaxSupply = longToNumber$1(n.int64());
        break;
      case 10:
        r.Royalties = RoyaltiesInfo.decode(n, n.uint32());
        break;
      case 11:
        r.Properties = PropertiesInfo.decode(n, n.uint32());
        break;
      case 12:
        r.Attributes = AttributesInfo.decode(n, n.uint32());
        break;
      case 13:
        r.Staking = StakingInfo.decode(n, n.uint32());
        break;
      case 14:
        r.Roles.push(RolesInfo.decode(n, n.uint32()));
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ Type: isSet$2(e2.Type) ? createAssetContract_EnumAssetTypeFromJSON(e2.Type) : 0, Name: isSet$2(e2.Name) ? bytesFromBase64$2(e2.Name) : new Uint8Array(), Ticker: isSet$2(e2.Ticker) ? bytesFromBase64$2(e2.Ticker) : new Uint8Array(), OwnerAddress: isSet$2(e2.OwnerAddress) ? bytesFromBase64$2(e2.OwnerAddress) : new Uint8Array(), Logo: isSet$2(e2.Logo) ? String(e2.Logo) : "", URIs: isObject(e2.URIs) ? Object.entries(e2.URIs).reduce((e3, [t, n]) => (e3[t] = String(n), e3), {}) : {}, Precision: isSet$2(e2.Precision) ? Number(e2.Precision) : 0, InitialSupply: isSet$2(e2.InitialSupply) ? Number(e2.InitialSupply) : 0, MaxSupply: isSet$2(e2.MaxSupply) ? Number(e2.MaxSupply) : 0, Royalties: isSet$2(e2.Royalties) ? RoyaltiesInfo.fromJSON(e2.Royalties) : void 0, Properties: isSet$2(e2.Properties) ? PropertiesInfo.fromJSON(e2.Properties) : void 0, Attributes: isSet$2(e2.Attributes) ? AttributesInfo.fromJSON(e2.Attributes) : void 0, Staking: isSet$2(e2.Staking) ? StakingInfo.fromJSON(e2.Staking) : void 0, Roles: Array.isArray(null == e2 ? void 0 : e2.Roles) ? e2.Roles.map((e3) => RolesInfo.fromJSON(e3)) : [] }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.Type && (t.Type = createAssetContract_EnumAssetTypeToJSON(e2.Type)), void 0 !== e2.Name && (t.Name = base64FromBytes$2(void 0 !== e2.Name ? e2.Name : new Uint8Array())), void 0 !== e2.Ticker && (t.Ticker = base64FromBytes$2(void 0 !== e2.Ticker ? e2.Ticker : new Uint8Array())), void 0 !== e2.OwnerAddress && (t.OwnerAddress = base64FromBytes$2(void 0 !== e2.OwnerAddress ? e2.OwnerAddress : new Uint8Array())), void 0 !== e2.Logo && (t.Logo = e2.Logo), t.URIs = {}, e2.URIs && Object.entries(e2.URIs).forEach(([e3, n]) => {
    t.URIs[e3] = n;
  }), void 0 !== e2.Precision && (t.Precision = Math.round(e2.Precision)), void 0 !== e2.InitialSupply && (t.InitialSupply = Math.round(e2.InitialSupply)), void 0 !== e2.MaxSupply && (t.MaxSupply = Math.round(e2.MaxSupply)), void 0 !== e2.Royalties && (t.Royalties = e2.Royalties ? RoyaltiesInfo.toJSON(e2.Royalties) : void 0), void 0 !== e2.Properties && (t.Properties = e2.Properties ? PropertiesInfo.toJSON(e2.Properties) : void 0), void 0 !== e2.Attributes && (t.Attributes = e2.Attributes ? AttributesInfo.toJSON(e2.Attributes) : void 0), void 0 !== e2.Staking && (t.Staking = e2.Staking ? StakingInfo.toJSON(e2.Staking) : void 0), e2.Roles ? t.Roles = e2.Roles.map((e3) => e3 ? RolesInfo.toJSON(e3) : void 0) : t.Roles = [], t;
}, fromPartial(e2) {
  var t, n, o, r, a, i, s, c, d, l;
  const u = createBaseCreateAssetContract();
  return u.Type = null !== (t = e2.Type) && void 0 !== t ? t : 0, u.Name = null !== (n = e2.Name) && void 0 !== n ? n : new Uint8Array(), u.Ticker = null !== (o = e2.Ticker) && void 0 !== o ? o : new Uint8Array(), u.OwnerAddress = null !== (r = e2.OwnerAddress) && void 0 !== r ? r : new Uint8Array(), u.Logo = null !== (a = e2.Logo) && void 0 !== a ? a : "", u.URIs = Object.entries(null !== (i = e2.URIs) && void 0 !== i ? i : {}).reduce((e3, [t2, n2]) => (void 0 !== n2 && (e3[t2] = String(n2)), e3), {}), u.Precision = null !== (s = e2.Precision) && void 0 !== s ? s : 0, u.InitialSupply = null !== (c = e2.InitialSupply) && void 0 !== c ? c : 0, u.MaxSupply = null !== (d = e2.MaxSupply) && void 0 !== d ? d : 0, u.Royalties = void 0 !== e2.Royalties && null !== e2.Royalties ? RoyaltiesInfo.fromPartial(e2.Royalties) : void 0, u.Properties = void 0 !== e2.Properties && null !== e2.Properties ? PropertiesInfo.fromPartial(e2.Properties) : void 0, u.Attributes = void 0 !== e2.Attributes && null !== e2.Attributes ? AttributesInfo.fromPartial(e2.Attributes) : void 0, u.Staking = void 0 !== e2.Staking && null !== e2.Staking ? StakingInfo.fromPartial(e2.Staking) : void 0, u.Roles = (null === (l = e2.Roles) || void 0 === l ? void 0 : l.map((e3) => RolesInfo.fromPartial(e3))) || [], u;
} };
function createBaseCreateAssetContract_URIsEntry() {
  return { key: "", value: "" };
}
var CreateAssetContract_URIsEntry = { encode: (e2, t = minimal.Writer.create()) => ("" !== e2.key && t.uint32(10).string(e2.key), "" !== e2.value && t.uint32(18).string(e2.value), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseCreateAssetContract_URIsEntry();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.key = n.string();
        break;
      case 2:
        r.value = n.string();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ key: isSet$2(e2.key) ? String(e2.key) : "", value: isSet$2(e2.value) ? String(e2.value) : "" }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.key && (t.key = e2.key), void 0 !== e2.value && (t.value = e2.value), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseCreateAssetContract_URIsEntry();
  return o.key = null !== (t = e2.key) && void 0 !== t ? t : "", o.value = null !== (n = e2.value) && void 0 !== n ? n : "", o;
} };
function createBasePropertiesInfo() {
  return { CanFreeze: false, CanWipe: false, CanPause: false, CanMint: false, CanBurn: false, CanChangeOwner: false, CanAddRoles: false };
}
var PropertiesInfo = { encode: (e2, t = minimal.Writer.create()) => (true === e2.CanFreeze && t.uint32(8).bool(e2.CanFreeze), true === e2.CanWipe && t.uint32(16).bool(e2.CanWipe), true === e2.CanPause && t.uint32(24).bool(e2.CanPause), true === e2.CanMint && t.uint32(32).bool(e2.CanMint), true === e2.CanBurn && t.uint32(40).bool(e2.CanBurn), true === e2.CanChangeOwner && t.uint32(48).bool(e2.CanChangeOwner), true === e2.CanAddRoles && t.uint32(56).bool(e2.CanAddRoles), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBasePropertiesInfo();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.CanFreeze = n.bool();
        break;
      case 2:
        r.CanWipe = n.bool();
        break;
      case 3:
        r.CanPause = n.bool();
        break;
      case 4:
        r.CanMint = n.bool();
        break;
      case 5:
        r.CanBurn = n.bool();
        break;
      case 6:
        r.CanChangeOwner = n.bool();
        break;
      case 7:
        r.CanAddRoles = n.bool();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ CanFreeze: !!isSet$2(e2.CanFreeze) && Boolean(e2.CanFreeze), CanWipe: !!isSet$2(e2.CanWipe) && Boolean(e2.CanWipe), CanPause: !!isSet$2(e2.CanPause) && Boolean(e2.CanPause), CanMint: !!isSet$2(e2.CanMint) && Boolean(e2.CanMint), CanBurn: !!isSet$2(e2.CanBurn) && Boolean(e2.CanBurn), CanChangeOwner: !!isSet$2(e2.CanChangeOwner) && Boolean(e2.CanChangeOwner), CanAddRoles: !!isSet$2(e2.CanAddRoles) && Boolean(e2.CanAddRoles) }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.CanFreeze && (t.CanFreeze = e2.CanFreeze), void 0 !== e2.CanWipe && (t.CanWipe = e2.CanWipe), void 0 !== e2.CanPause && (t.CanPause = e2.CanPause), void 0 !== e2.CanMint && (t.CanMint = e2.CanMint), void 0 !== e2.CanBurn && (t.CanBurn = e2.CanBurn), void 0 !== e2.CanChangeOwner && (t.CanChangeOwner = e2.CanChangeOwner), void 0 !== e2.CanAddRoles && (t.CanAddRoles = e2.CanAddRoles), t;
}, fromPartial(e2) {
  var t, n, o, r, a, i, s;
  const c = createBasePropertiesInfo();
  return c.CanFreeze = null !== (t = e2.CanFreeze) && void 0 !== t && t, c.CanWipe = null !== (n = e2.CanWipe) && void 0 !== n && n, c.CanPause = null !== (o = e2.CanPause) && void 0 !== o && o, c.CanMint = null !== (r = e2.CanMint) && void 0 !== r && r, c.CanBurn = null !== (a = e2.CanBurn) && void 0 !== a && a, c.CanChangeOwner = null !== (i = e2.CanChangeOwner) && void 0 !== i && i, c.CanAddRoles = null !== (s = e2.CanAddRoles) && void 0 !== s && s, c;
} };
function createBaseAttributesInfo() {
  return { IsPaused: false, IsNFTMintStopped: false };
}
var AttributesInfo = { encode: (e2, t = minimal.Writer.create()) => (true === e2.IsPaused && t.uint32(8).bool(e2.IsPaused), true === e2.IsNFTMintStopped && t.uint32(16).bool(e2.IsNFTMintStopped), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseAttributesInfo();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.IsPaused = n.bool();
        break;
      case 2:
        r.IsNFTMintStopped = n.bool();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ IsPaused: !!isSet$2(e2.IsPaused) && Boolean(e2.IsPaused), IsNFTMintStopped: !!isSet$2(e2.IsNFTMintStopped) && Boolean(e2.IsNFTMintStopped) }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.IsPaused && (t.IsPaused = e2.IsPaused), void 0 !== e2.IsNFTMintStopped && (t.IsNFTMintStopped = e2.IsNFTMintStopped), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseAttributesInfo();
  return o.IsPaused = null !== (t = e2.IsPaused) && void 0 !== t && t, o.IsNFTMintStopped = null !== (n = e2.IsNFTMintStopped) && void 0 !== n && n, o;
} };
function createBaseStakingInfo() {
  return { Type: 0, APR: 0, MinEpochsToClaim: 0, MinEpochsToUnstake: 0, MinEpochsToWithdraw: 0 };
}
var StakingInfo = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.Type && 0 !== e2.Type && t.uint32(8).int32(e2.Type), void 0 !== e2.APR && 0 !== e2.APR && t.uint32(16).uint32(e2.APR), void 0 !== e2.MinEpochsToClaim && 0 !== e2.MinEpochsToClaim && t.uint32(24).uint32(e2.MinEpochsToClaim), void 0 !== e2.MinEpochsToUnstake && 0 !== e2.MinEpochsToUnstake && t.uint32(32).uint32(e2.MinEpochsToUnstake), void 0 !== e2.MinEpochsToWithdraw && 0 !== e2.MinEpochsToWithdraw && t.uint32(40).uint32(e2.MinEpochsToWithdraw), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseStakingInfo();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.Type = n.int32();
        break;
      case 2:
        r.APR = n.uint32();
        break;
      case 3:
        r.MinEpochsToClaim = n.uint32();
        break;
      case 4:
        r.MinEpochsToUnstake = n.uint32();
        break;
      case 5:
        r.MinEpochsToWithdraw = n.uint32();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ Type: isSet$2(e2.Type) ? stakingInfo_InterestTypeFromJSON(e2.Type) : 0, APR: isSet$2(e2.APR) ? Number(e2.APR) : 0, MinEpochsToClaim: isSet$2(e2.MinEpochsToClaim) ? Number(e2.MinEpochsToClaim) : 0, MinEpochsToUnstake: isSet$2(e2.MinEpochsToUnstake) ? Number(e2.MinEpochsToUnstake) : 0, MinEpochsToWithdraw: isSet$2(e2.MinEpochsToWithdraw) ? Number(e2.MinEpochsToWithdraw) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.Type && (t.Type = stakingInfo_InterestTypeToJSON(e2.Type)), void 0 !== e2.APR && (t.APR = Math.round(e2.APR)), void 0 !== e2.MinEpochsToClaim && (t.MinEpochsToClaim = Math.round(e2.MinEpochsToClaim)), void 0 !== e2.MinEpochsToUnstake && (t.MinEpochsToUnstake = Math.round(e2.MinEpochsToUnstake)), void 0 !== e2.MinEpochsToWithdraw && (t.MinEpochsToWithdraw = Math.round(e2.MinEpochsToWithdraw)), t;
}, fromPartial(e2) {
  var t, n, o, r, a;
  const i = createBaseStakingInfo();
  return i.Type = null !== (t = e2.Type) && void 0 !== t ? t : 0, i.APR = null !== (n = e2.APR) && void 0 !== n ? n : 0, i.MinEpochsToClaim = null !== (o = e2.MinEpochsToClaim) && void 0 !== o ? o : 0, i.MinEpochsToUnstake = null !== (r = e2.MinEpochsToUnstake) && void 0 !== r ? r : 0, i.MinEpochsToWithdraw = null !== (a = e2.MinEpochsToWithdraw) && void 0 !== a ? a : 0, i;
} };
function createBaseRolesInfo() {
  return { Address: new Uint8Array(), HasRoleMint: false, HasRoleSetITOPrices: false };
}
var RolesInfo = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.Address && 0 !== e2.Address.length && t.uint32(10).bytes(e2.Address), true === e2.HasRoleMint && t.uint32(16).bool(e2.HasRoleMint), true === e2.HasRoleSetITOPrices && t.uint32(24).bool(e2.HasRoleSetITOPrices), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseRolesInfo();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.Address = n.bytes();
        break;
      case 2:
        r.HasRoleMint = n.bool();
        break;
      case 3:
        r.HasRoleSetITOPrices = n.bool();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ Address: isSet$2(e2.Address) ? bytesFromBase64$2(e2.Address) : new Uint8Array(), HasRoleMint: !!isSet$2(e2.HasRoleMint) && Boolean(e2.HasRoleMint), HasRoleSetITOPrices: !!isSet$2(e2.HasRoleSetITOPrices) && Boolean(e2.HasRoleSetITOPrices) }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.Address && (t.Address = base64FromBytes$2(void 0 !== e2.Address ? e2.Address : new Uint8Array())), void 0 !== e2.HasRoleMint && (t.HasRoleMint = e2.HasRoleMint), void 0 !== e2.HasRoleSetITOPrices && (t.HasRoleSetITOPrices = e2.HasRoleSetITOPrices), t;
}, fromPartial(e2) {
  var t, n, o;
  const r = createBaseRolesInfo();
  return r.Address = null !== (t = e2.Address) && void 0 !== t ? t : new Uint8Array(), r.HasRoleMint = null !== (n = e2.HasRoleMint) && void 0 !== n && n, r.HasRoleSetITOPrices = null !== (o = e2.HasRoleSetITOPrices) && void 0 !== o && o, r;
} };
function createBaseRoyaltiesInfo() {
  return { Address: new Uint8Array(), TransferPercentage: [], TransferFixed: 0, MarketPercentage: 0, MarketFixed: 0 };
}
var RoyaltiesInfo = { encode(e2, t = minimal.Writer.create()) {
  if (void 0 !== e2.Address && 0 !== e2.Address.length && t.uint32(10).bytes(e2.Address), void 0 !== e2.TransferPercentage && 0 !== e2.TransferPercentage.length)
    for (const n of e2.TransferPercentage)
      RoyaltyInfo.encode(n, t.uint32(18).fork()).ldelim();
  return void 0 !== e2.TransferFixed && 0 !== e2.TransferFixed && t.uint32(24).int64(e2.TransferFixed), void 0 !== e2.MarketPercentage && 0 !== e2.MarketPercentage && t.uint32(32).uint32(e2.MarketPercentage), void 0 !== e2.MarketFixed && 0 !== e2.MarketFixed && t.uint32(40).int64(e2.MarketFixed), t;
}, decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseRoyaltiesInfo();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.Address = n.bytes();
        break;
      case 2:
        r.TransferPercentage.push(RoyaltyInfo.decode(n, n.uint32()));
        break;
      case 3:
        r.TransferFixed = longToNumber$1(n.int64());
        break;
      case 4:
        r.MarketPercentage = n.uint32();
        break;
      case 5:
        r.MarketFixed = longToNumber$1(n.int64());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ Address: isSet$2(e2.Address) ? bytesFromBase64$2(e2.Address) : new Uint8Array(), TransferPercentage: Array.isArray(null == e2 ? void 0 : e2.TransferPercentage) ? e2.TransferPercentage.map((e3) => RoyaltyInfo.fromJSON(e3)) : [], TransferFixed: isSet$2(e2.TransferFixed) ? Number(e2.TransferFixed) : 0, MarketPercentage: isSet$2(e2.MarketPercentage) ? Number(e2.MarketPercentage) : 0, MarketFixed: isSet$2(e2.MarketFixed) ? Number(e2.MarketFixed) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.Address && (t.Address = base64FromBytes$2(void 0 !== e2.Address ? e2.Address : new Uint8Array())), e2.TransferPercentage ? t.TransferPercentage = e2.TransferPercentage.map((e3) => e3 ? RoyaltyInfo.toJSON(e3) : void 0) : t.TransferPercentage = [], void 0 !== e2.TransferFixed && (t.TransferFixed = Math.round(e2.TransferFixed)), void 0 !== e2.MarketPercentage && (t.MarketPercentage = Math.round(e2.MarketPercentage)), void 0 !== e2.MarketFixed && (t.MarketFixed = Math.round(e2.MarketFixed)), t;
}, fromPartial(e2) {
  var t, n, o, r, a;
  const i = createBaseRoyaltiesInfo();
  return i.Address = null !== (t = e2.Address) && void 0 !== t ? t : new Uint8Array(), i.TransferPercentage = (null === (n = e2.TransferPercentage) || void 0 === n ? void 0 : n.map((e3) => RoyaltyInfo.fromPartial(e3))) || [], i.TransferFixed = null !== (o = e2.TransferFixed) && void 0 !== o ? o : 0, i.MarketPercentage = null !== (r = e2.MarketPercentage) && void 0 !== r ? r : 0, i.MarketFixed = null !== (a = e2.MarketFixed) && void 0 !== a ? a : 0, i;
} };
function createBaseRoyaltyInfo() {
  return { Amount: 0, Percentage: 0 };
}
var RoyaltyInfo = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.Amount && 0 !== e2.Amount && t.uint32(8).int64(e2.Amount), void 0 !== e2.Percentage && 0 !== e2.Percentage && t.uint32(16).uint32(e2.Percentage), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseRoyaltyInfo();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.Amount = longToNumber$1(n.int64());
        break;
      case 2:
        r.Percentage = n.uint32();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ Amount: isSet$2(e2.amount) ? Number(e2.amount) : 0, Percentage: isSet$2(e2.percentage) ? Number(e2.percentage) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.Amount && (t.amount = Math.round(e2.Amount)), void 0 !== e2.Percentage && (t.percentage = Math.round(e2.Percentage)), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseRoyaltyInfo();
  return o.Amount = null !== (t = e2.Amount) && void 0 !== t ? t : 0, o.Percentage = null !== (n = e2.Percentage) && void 0 !== n ? n : 0, o;
} };
function createBaseAssetTriggerContract() {
  return { TriggerType: 0, AssetID: new Uint8Array(), ToAddress: new Uint8Array(), Amount: 0, MIME: new Uint8Array(), Logo: "", URIs: {}, Role: void 0, Staking: void 0 };
}
var AssetTriggerContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.TriggerType && 0 !== e2.TriggerType && t.uint32(8).int32(e2.TriggerType), void 0 !== e2.AssetID && 0 !== e2.AssetID.length && t.uint32(18).bytes(e2.AssetID), void 0 !== e2.ToAddress && 0 !== e2.ToAddress.length && t.uint32(26).bytes(e2.ToAddress), void 0 !== e2.Amount && 0 !== e2.Amount && t.uint32(32).int64(e2.Amount), void 0 !== e2.MIME && 0 !== e2.MIME.length && t.uint32(42).bytes(e2.MIME), void 0 !== e2.Logo && "" !== e2.Logo && t.uint32(50).string(e2.Logo), Object.entries(e2.URIs || {}).forEach(([e3, n]) => {
  AssetTriggerContract_URIsEntry.encode({ key: e3, value: n }, t.uint32(58).fork()).ldelim();
}), void 0 !== e2.Role && RolesInfo.encode(e2.Role, t.uint32(66).fork()).ldelim(), void 0 !== e2.Staking && StakingInfo.encode(e2.Staking, t.uint32(74).fork()).ldelim(), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseAssetTriggerContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.TriggerType = n.int32();
        break;
      case 2:
        r.AssetID = n.bytes();
        break;
      case 3:
        r.ToAddress = n.bytes();
        break;
      case 4:
        r.Amount = longToNumber$1(n.int64());
        break;
      case 5:
        r.MIME = n.bytes();
        break;
      case 6:
        r.Logo = n.string();
        break;
      case 7:
        const t2 = AssetTriggerContract_URIsEntry.decode(n, n.uint32());
        void 0 !== t2.value && (r.URIs[t2.key] = t2.value);
        break;
      case 8:
        r.Role = RolesInfo.decode(n, n.uint32());
        break;
      case 9:
        r.Staking = StakingInfo.decode(n, n.uint32());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ TriggerType: isSet$2(e2.TriggerType) ? assetTriggerContract_EnumTriggerTypeFromJSON(e2.TriggerType) : 0, AssetID: isSet$2(e2.AssetID) ? bytesFromBase64$2(e2.AssetID) : new Uint8Array(), ToAddress: isSet$2(e2.ToAddress) ? bytesFromBase64$2(e2.ToAddress) : new Uint8Array(), Amount: isSet$2(e2.Amount) ? Number(e2.Amount) : 0, MIME: isSet$2(e2.MIME) ? bytesFromBase64$2(e2.MIME) : new Uint8Array(), Logo: isSet$2(e2.Logo) ? String(e2.Logo) : "", URIs: isObject(e2.URIs) ? Object.entries(e2.URIs).reduce((e3, [t, n]) => (e3[t] = String(n), e3), {}) : {}, Role: isSet$2(e2.Role) ? RolesInfo.fromJSON(e2.Role) : void 0, Staking: isSet$2(e2.Staking) ? StakingInfo.fromJSON(e2.Staking) : void 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.TriggerType && (t.TriggerType = assetTriggerContract_EnumTriggerTypeToJSON(e2.TriggerType)), void 0 !== e2.AssetID && (t.AssetID = base64FromBytes$2(void 0 !== e2.AssetID ? e2.AssetID : new Uint8Array())), void 0 !== e2.ToAddress && (t.ToAddress = base64FromBytes$2(void 0 !== e2.ToAddress ? e2.ToAddress : new Uint8Array())), void 0 !== e2.Amount && (t.Amount = Math.round(e2.Amount)), void 0 !== e2.MIME && (t.MIME = base64FromBytes$2(void 0 !== e2.MIME ? e2.MIME : new Uint8Array())), void 0 !== e2.Logo && (t.Logo = e2.Logo), t.URIs = {}, e2.URIs && Object.entries(e2.URIs).forEach(([e3, n]) => {
    t.URIs[e3] = n;
  }), void 0 !== e2.Role && (t.Role = e2.Role ? RolesInfo.toJSON(e2.Role) : void 0), void 0 !== e2.Staking && (t.Staking = e2.Staking ? StakingInfo.toJSON(e2.Staking) : void 0), t;
}, fromPartial(e2) {
  var t, n, o, r, a, i, s;
  const c = createBaseAssetTriggerContract();
  return c.TriggerType = null !== (t = e2.TriggerType) && void 0 !== t ? t : 0, c.AssetID = null !== (n = e2.AssetID) && void 0 !== n ? n : new Uint8Array(), c.ToAddress = null !== (o = e2.ToAddress) && void 0 !== o ? o : new Uint8Array(), c.Amount = null !== (r = e2.Amount) && void 0 !== r ? r : 0, c.MIME = null !== (a = e2.MIME) && void 0 !== a ? a : new Uint8Array(), c.Logo = null !== (i = e2.Logo) && void 0 !== i ? i : "", c.URIs = Object.entries(null !== (s = e2.URIs) && void 0 !== s ? s : {}).reduce((e3, [t2, n2]) => (void 0 !== n2 && (e3[t2] = String(n2)), e3), {}), c.Role = void 0 !== e2.Role && null !== e2.Role ? RolesInfo.fromPartial(e2.Role) : void 0, c.Staking = void 0 !== e2.Staking && null !== e2.Staking ? StakingInfo.fromPartial(e2.Staking) : void 0, c;
} };
function createBaseAssetTriggerContract_URIsEntry() {
  return { key: "", value: "" };
}
var AssetTriggerContract_URIsEntry = { encode: (e2, t = minimal.Writer.create()) => ("" !== e2.key && t.uint32(10).string(e2.key), "" !== e2.value && t.uint32(18).string(e2.value), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseAssetTriggerContract_URIsEntry();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.key = n.string();
        break;
      case 2:
        r.value = n.string();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ key: isSet$2(e2.key) ? String(e2.key) : "", value: isSet$2(e2.value) ? String(e2.value) : "" }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.key && (t.key = e2.key), void 0 !== e2.value && (t.value = e2.value), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseAssetTriggerContract_URIsEntry();
  return o.key = null !== (t = e2.key) && void 0 !== t ? t : "", o.value = null !== (n = e2.value) && void 0 !== n ? n : "", o;
} };
function createBaseValidatorConfig() {
  return { BLSPublicKey: new Uint8Array(), RewardAddress: new Uint8Array(), CanDelegate: false, Commission: 0, MaxDelegationAmount: 0, Logo: "", URIs: {}, Name: "" };
}
var ValidatorConfig = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.BLSPublicKey && 0 !== e2.BLSPublicKey.length && t.uint32(10).bytes(e2.BLSPublicKey), void 0 !== e2.RewardAddress && 0 !== e2.RewardAddress.length && t.uint32(18).bytes(e2.RewardAddress), true === e2.CanDelegate && t.uint32(24).bool(e2.CanDelegate), void 0 !== e2.Commission && 0 !== e2.Commission && t.uint32(32).uint32(e2.Commission), void 0 !== e2.MaxDelegationAmount && 0 !== e2.MaxDelegationAmount && t.uint32(40).int64(e2.MaxDelegationAmount), void 0 !== e2.Logo && "" !== e2.Logo && t.uint32(50).string(e2.Logo), Object.entries(e2.URIs || {}).forEach(([e3, n]) => {
  ValidatorConfig_URIsEntry.encode({ key: e3, value: n }, t.uint32(58).fork()).ldelim();
}), void 0 !== e2.Name && "" !== e2.Name && t.uint32(66).string(e2.Name), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseValidatorConfig();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.BLSPublicKey = n.bytes();
        break;
      case 2:
        r.RewardAddress = n.bytes();
        break;
      case 3:
        r.CanDelegate = n.bool();
        break;
      case 4:
        r.Commission = n.uint32();
        break;
      case 5:
        r.MaxDelegationAmount = longToNumber$1(n.int64());
        break;
      case 6:
        r.Logo = n.string();
        break;
      case 7:
        const t2 = ValidatorConfig_URIsEntry.decode(n, n.uint32());
        void 0 !== t2.value && (r.URIs[t2.key] = t2.value);
        break;
      case 8:
        r.Name = n.string();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ BLSPublicKey: isSet$2(e2.BLSPublicKey) ? bytesFromBase64$2(e2.BLSPublicKey) : new Uint8Array(), RewardAddress: isSet$2(e2.RewardAddress) ? bytesFromBase64$2(e2.RewardAddress) : new Uint8Array(), CanDelegate: !!isSet$2(e2.CanDelegate) && Boolean(e2.CanDelegate), Commission: isSet$2(e2.Commission) ? Number(e2.Commission) : 0, MaxDelegationAmount: isSet$2(e2.MaxDelegationAmount) ? Number(e2.MaxDelegationAmount) : 0, Logo: isSet$2(e2.Logo) ? String(e2.Logo) : "", URIs: isObject(e2.URIs) ? Object.entries(e2.URIs).reduce((e3, [t, n]) => (e3[t] = String(n), e3), {}) : {}, Name: isSet$2(e2.Name) ? String(e2.Name) : "" }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.BLSPublicKey && (t.BLSPublicKey = base64FromBytes$2(void 0 !== e2.BLSPublicKey ? e2.BLSPublicKey : new Uint8Array())), void 0 !== e2.RewardAddress && (t.RewardAddress = base64FromBytes$2(void 0 !== e2.RewardAddress ? e2.RewardAddress : new Uint8Array())), void 0 !== e2.CanDelegate && (t.CanDelegate = e2.CanDelegate), void 0 !== e2.Commission && (t.Commission = Math.round(e2.Commission)), void 0 !== e2.MaxDelegationAmount && (t.MaxDelegationAmount = Math.round(e2.MaxDelegationAmount)), void 0 !== e2.Logo && (t.Logo = e2.Logo), t.URIs = {}, e2.URIs && Object.entries(e2.URIs).forEach(([e3, n]) => {
    t.URIs[e3] = n;
  }), void 0 !== e2.Name && (t.Name = e2.Name), t;
}, fromPartial(e2) {
  var t, n, o, r, a, i, s, c;
  const d = createBaseValidatorConfig();
  return d.BLSPublicKey = null !== (t = e2.BLSPublicKey) && void 0 !== t ? t : new Uint8Array(), d.RewardAddress = null !== (n = e2.RewardAddress) && void 0 !== n ? n : new Uint8Array(), d.CanDelegate = null !== (o = e2.CanDelegate) && void 0 !== o && o, d.Commission = null !== (r = e2.Commission) && void 0 !== r ? r : 0, d.MaxDelegationAmount = null !== (a = e2.MaxDelegationAmount) && void 0 !== a ? a : 0, d.Logo = null !== (i = e2.Logo) && void 0 !== i ? i : "", d.URIs = Object.entries(null !== (s = e2.URIs) && void 0 !== s ? s : {}).reduce((e3, [t2, n2]) => (void 0 !== n2 && (e3[t2] = String(n2)), e3), {}), d.Name = null !== (c = e2.Name) && void 0 !== c ? c : "", d;
} };
function createBaseValidatorConfig_URIsEntry() {
  return { key: "", value: "" };
}
var ValidatorConfig_URIsEntry = { encode: (e2, t = minimal.Writer.create()) => ("" !== e2.key && t.uint32(10).string(e2.key), "" !== e2.value && t.uint32(18).string(e2.value), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseValidatorConfig_URIsEntry();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.key = n.string();
        break;
      case 2:
        r.value = n.string();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ key: isSet$2(e2.key) ? String(e2.key) : "", value: isSet$2(e2.value) ? String(e2.value) : "" }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.key && (t.key = e2.key), void 0 !== e2.value && (t.value = e2.value), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseValidatorConfig_URIsEntry();
  return o.key = null !== (t = e2.key) && void 0 !== t ? t : "", o.value = null !== (n = e2.value) && void 0 !== n ? n : "", o;
} };
function createBaseCreateValidatorContract() {
  return { OwnerAddress: new Uint8Array(), Config: void 0 };
}
var CreateValidatorContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.OwnerAddress && 0 !== e2.OwnerAddress.length && t.uint32(10).bytes(e2.OwnerAddress), void 0 !== e2.Config && ValidatorConfig.encode(e2.Config, t.uint32(18).fork()).ldelim(), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseCreateValidatorContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.OwnerAddress = n.bytes();
        break;
      case 2:
        r.Config = ValidatorConfig.decode(n, n.uint32());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ OwnerAddress: isSet$2(e2.OwnerAddress) ? bytesFromBase64$2(e2.OwnerAddress) : new Uint8Array(), Config: isSet$2(e2.Config) ? ValidatorConfig.fromJSON(e2.Config) : void 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.OwnerAddress && (t.OwnerAddress = base64FromBytes$2(void 0 !== e2.OwnerAddress ? e2.OwnerAddress : new Uint8Array())), void 0 !== e2.Config && (t.Config = e2.Config ? ValidatorConfig.toJSON(e2.Config) : void 0), t;
}, fromPartial(e2) {
  var t;
  const n = createBaseCreateValidatorContract();
  return n.OwnerAddress = null !== (t = e2.OwnerAddress) && void 0 !== t ? t : new Uint8Array(), n.Config = void 0 !== e2.Config && null !== e2.Config ? ValidatorConfig.fromPartial(e2.Config) : void 0, n;
} };
function createBaseValidatorConfigContract() {
  return { Config: void 0 };
}
var ValidatorConfigContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.Config && ValidatorConfig.encode(e2.Config, t.uint32(10).fork()).ldelim(), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseValidatorConfigContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    if (e3 >>> 3 == 1)
      r.Config = ValidatorConfig.decode(n, n.uint32());
    else
      n.skipType(7 & e3);
  }
  return r;
}, fromJSON: (e2) => ({ Config: isSet$2(e2.Config) ? ValidatorConfig.fromJSON(e2.Config) : void 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.Config && (t.Config = e2.Config ? ValidatorConfig.toJSON(e2.Config) : void 0), t;
}, fromPartial(e2) {
  const t = createBaseValidatorConfigContract();
  return t.Config = void 0 !== e2.Config && null !== e2.Config ? ValidatorConfig.fromPartial(e2.Config) : void 0, t;
} };
function createBaseFreezeContract() {
  return { AssetID: new Uint8Array(), Amount: 0 };
}
var FreezeContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.AssetID && 0 !== e2.AssetID.length && t.uint32(10).bytes(e2.AssetID), void 0 !== e2.Amount && 0 !== e2.Amount && t.uint32(16).int64(e2.Amount), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseFreezeContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.AssetID = n.bytes();
        break;
      case 2:
        r.Amount = longToNumber$1(n.int64());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ AssetID: isSet$2(e2.AssetID) ? bytesFromBase64$2(e2.AssetID) : new Uint8Array(), Amount: isSet$2(e2.Amount) ? Number(e2.Amount) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.AssetID && (t.AssetID = base64FromBytes$2(void 0 !== e2.AssetID ? e2.AssetID : new Uint8Array())), void 0 !== e2.Amount && (t.Amount = Math.round(e2.Amount)), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseFreezeContract();
  return o.AssetID = null !== (t = e2.AssetID) && void 0 !== t ? t : new Uint8Array(), o.Amount = null !== (n = e2.Amount) && void 0 !== n ? n : 0, o;
} };
function createBaseUnfreezeContract() {
  return { AssetID: new Uint8Array(), BucketID: new Uint8Array() };
}
var UnfreezeContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.AssetID && 0 !== e2.AssetID.length && t.uint32(10).bytes(e2.AssetID), void 0 !== e2.BucketID && 0 !== e2.BucketID.length && t.uint32(18).bytes(e2.BucketID), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseUnfreezeContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.AssetID = n.bytes();
        break;
      case 2:
        r.BucketID = n.bytes();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ AssetID: isSet$2(e2.AssetID) ? bytesFromBase64$2(e2.AssetID) : new Uint8Array(), BucketID: isSet$2(e2.BucketID) ? bytesFromBase64$2(e2.BucketID) : new Uint8Array() }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.AssetID && (t.AssetID = base64FromBytes$2(void 0 !== e2.AssetID ? e2.AssetID : new Uint8Array())), void 0 !== e2.BucketID && (t.BucketID = base64FromBytes$2(void 0 !== e2.BucketID ? e2.BucketID : new Uint8Array())), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseUnfreezeContract();
  return o.AssetID = null !== (t = e2.AssetID) && void 0 !== t ? t : new Uint8Array(), o.BucketID = null !== (n = e2.BucketID) && void 0 !== n ? n : new Uint8Array(), o;
} };
function createBaseDelegateContract() {
  return { ToAddress: new Uint8Array(), BucketID: new Uint8Array() };
}
var DelegateContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.ToAddress && 0 !== e2.ToAddress.length && t.uint32(10).bytes(e2.ToAddress), void 0 !== e2.BucketID && 0 !== e2.BucketID.length && t.uint32(18).bytes(e2.BucketID), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseDelegateContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.ToAddress = n.bytes();
        break;
      case 2:
        r.BucketID = n.bytes();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ ToAddress: isSet$2(e2.ToAddress) ? bytesFromBase64$2(e2.ToAddress) : new Uint8Array(), BucketID: isSet$2(e2.BucketID) ? bytesFromBase64$2(e2.BucketID) : new Uint8Array() }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.ToAddress && (t.ToAddress = base64FromBytes$2(void 0 !== e2.ToAddress ? e2.ToAddress : new Uint8Array())), void 0 !== e2.BucketID && (t.BucketID = base64FromBytes$2(void 0 !== e2.BucketID ? e2.BucketID : new Uint8Array())), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseDelegateContract();
  return o.ToAddress = null !== (t = e2.ToAddress) && void 0 !== t ? t : new Uint8Array(), o.BucketID = null !== (n = e2.BucketID) && void 0 !== n ? n : new Uint8Array(), o;
} };
function createBaseUndelegateContract() {
  return { BucketID: new Uint8Array() };
}
var UndelegateContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.BucketID && 0 !== e2.BucketID.length && t.uint32(10).bytes(e2.BucketID), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseUndelegateContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    if (e3 >>> 3 == 1)
      r.BucketID = n.bytes();
    else
      n.skipType(7 & e3);
  }
  return r;
}, fromJSON: (e2) => ({ BucketID: isSet$2(e2.BucketID) ? bytesFromBase64$2(e2.BucketID) : new Uint8Array() }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.BucketID && (t.BucketID = base64FromBytes$2(void 0 !== e2.BucketID ? e2.BucketID : new Uint8Array())), t;
}, fromPartial(e2) {
  var t;
  const n = createBaseUndelegateContract();
  return n.BucketID = null !== (t = e2.BucketID) && void 0 !== t ? t : new Uint8Array(), n;
} };
function createBaseWithdrawContract() {
  return { AssetID: new Uint8Array() };
}
var WithdrawContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.AssetID && 0 !== e2.AssetID.length && t.uint32(10).bytes(e2.AssetID), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseWithdrawContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    if (e3 >>> 3 == 1)
      r.AssetID = n.bytes();
    else
      n.skipType(7 & e3);
  }
  return r;
}, fromJSON: (e2) => ({ AssetID: isSet$2(e2.AssetID) ? bytesFromBase64$2(e2.AssetID) : new Uint8Array() }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.AssetID && (t.AssetID = base64FromBytes$2(void 0 !== e2.AssetID ? e2.AssetID : new Uint8Array())), t;
}, fromPartial(e2) {
  var t;
  const n = createBaseWithdrawContract();
  return n.AssetID = null !== (t = e2.AssetID) && void 0 !== t ? t : new Uint8Array(), n;
} };
function createBaseClaimContract() {
  return { ClaimType: 0, ID: new Uint8Array() };
}
var ClaimContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.ClaimType && 0 !== e2.ClaimType && t.uint32(8).int32(e2.ClaimType), void 0 !== e2.ID && 0 !== e2.ID.length && t.uint32(18).bytes(e2.ID), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseClaimContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.ClaimType = n.int32();
        break;
      case 2:
        r.ID = n.bytes();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ ClaimType: isSet$2(e2.ClaimType) ? claimContract_EnumClaimTypeFromJSON(e2.ClaimType) : 0, ID: isSet$2(e2.ID) ? bytesFromBase64$2(e2.ID) : new Uint8Array() }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.ClaimType && (t.ClaimType = claimContract_EnumClaimTypeToJSON(e2.ClaimType)), void 0 !== e2.ID && (t.ID = base64FromBytes$2(void 0 !== e2.ID ? e2.ID : new Uint8Array())), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseClaimContract();
  return o.ClaimType = null !== (t = e2.ClaimType) && void 0 !== t ? t : 0, o.ID = null !== (n = e2.ID) && void 0 !== n ? n : new Uint8Array(), o;
} };
function createBaseUnjailContract() {
  return {};
}
var UnjailContract = { encode: (e2, t = minimal.Writer.create()) => t, decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseUnjailContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    n.skipType(7 & e3);
  }
  return r;
}, fromJSON: (e2) => ({}), toJSON: (e2) => ({}), fromPartial: (e2) => createBaseUnjailContract() };
function createBaseSetAccountNameContract() {
  return { Name: new Uint8Array() };
}
var SetAccountNameContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.Name && 0 !== e2.Name.length && t.uint32(10).bytes(e2.Name), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseSetAccountNameContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    if (e3 >>> 3 == 1)
      r.Name = n.bytes();
    else
      n.skipType(7 & e3);
  }
  return r;
}, fromJSON: (e2) => ({ Name: isSet$2(e2.Name) ? bytesFromBase64$2(e2.Name) : new Uint8Array() }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.Name && (t.Name = base64FromBytes$2(void 0 !== e2.Name ? e2.Name : new Uint8Array())), t;
}, fromPartial(e2) {
  var t;
  const n = createBaseSetAccountNameContract();
  return n.Name = null !== (t = e2.Name) && void 0 !== t ? t : new Uint8Array(), n;
} };
function createBaseProposalContract() {
  return { Parameters: {}, Description: new Uint8Array(), EpochsDuration: 0 };
}
var ProposalContract = { encode: (e2, t = minimal.Writer.create()) => (Object.entries(e2.Parameters || {}).forEach(([e3, n]) => {
  ProposalContract_ParametersEntry.encode({ key: e3, value: n }, t.uint32(10).fork()).ldelim();
}), void 0 !== e2.Description && 0 !== e2.Description.length && t.uint32(18).bytes(e2.Description), void 0 !== e2.EpochsDuration && 0 !== e2.EpochsDuration && t.uint32(24).uint32(e2.EpochsDuration), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseProposalContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        const t2 = ProposalContract_ParametersEntry.decode(n, n.uint32());
        void 0 !== t2.value && (r.Parameters[t2.key] = t2.value);
        break;
      case 2:
        r.Description = n.bytes();
        break;
      case 3:
        r.EpochsDuration = n.uint32();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ Parameters: isObject(e2.Parameters) ? Object.entries(e2.Parameters).reduce((e3, [t, n]) => (e3[Number(t)] = bytesFromBase64$2(n), e3), {}) : {}, Description: isSet$2(e2.Description) ? bytesFromBase64$2(e2.Description) : new Uint8Array(), EpochsDuration: isSet$2(e2.EpochsDuration) ? Number(e2.EpochsDuration) : 0 }), toJSON(e2) {
  const t = { Parameters: {} };
  return e2.Parameters && Object.entries(e2.Parameters).forEach(([e3, n]) => {
    t.Parameters[e3] = base64FromBytes$2(n);
  }), void 0 !== e2.Description && (t.Description = base64FromBytes$2(void 0 !== e2.Description ? e2.Description : new Uint8Array())), void 0 !== e2.EpochsDuration && (t.EpochsDuration = Math.round(e2.EpochsDuration)), t;
}, fromPartial(e2) {
  var t, n, o;
  const r = createBaseProposalContract();
  return r.Parameters = Object.entries(null !== (t = e2.Parameters) && void 0 !== t ? t : {}).reduce((e3, [t2, n2]) => (void 0 !== n2 && (e3[Number(t2)] = n2), e3), {}), r.Description = null !== (n = e2.Description) && void 0 !== n ? n : new Uint8Array(), r.EpochsDuration = null !== (o = e2.EpochsDuration) && void 0 !== o ? o : 0, r;
} };
function createBaseProposalContract_ParametersEntry() {
  return { key: 0, value: new Uint8Array() };
}
var ProposalContract_ParametersEntry = { encode: (e2, t = minimal.Writer.create()) => (0 !== e2.key && t.uint32(8).int32(e2.key), 0 !== e2.value.length && t.uint32(18).bytes(e2.value), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseProposalContract_ParametersEntry();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.key = n.int32();
        break;
      case 2:
        r.value = n.bytes();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ key: isSet$2(e2.key) ? Number(e2.key) : 0, value: isSet$2(e2.value) ? bytesFromBase64$2(e2.value) : new Uint8Array() }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.key && (t.key = Math.round(e2.key)), void 0 !== e2.value && (t.value = base64FromBytes$2(void 0 !== e2.value ? e2.value : new Uint8Array())), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseProposalContract_ParametersEntry();
  return o.key = null !== (t = e2.key) && void 0 !== t ? t : 0, o.value = null !== (n = e2.value) && void 0 !== n ? n : new Uint8Array(), o;
} };
function createBaseVoteContract() {
  return { ProposalID: 0, Amount: 0, Type: 0 };
}
var VoteContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.ProposalID && 0 !== e2.ProposalID && t.uint32(8).uint64(e2.ProposalID), void 0 !== e2.Amount && 0 !== e2.Amount && t.uint32(16).int64(e2.Amount), void 0 !== e2.Type && 0 !== e2.Type && t.uint32(24).int32(e2.Type), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseVoteContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.ProposalID = longToNumber$1(n.uint64());
        break;
      case 2:
        r.Amount = longToNumber$1(n.int64());
        break;
      case 3:
        r.Type = n.int32();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ ProposalID: isSet$2(e2.ProposalID) ? Number(e2.ProposalID) : 0, Amount: isSet$2(e2.Amount) ? Number(e2.Amount) : 0, Type: isSet$2(e2.Type) ? voteContract_EnumVoteTypeFromJSON(e2.Type) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.ProposalID && (t.ProposalID = Math.round(e2.ProposalID)), void 0 !== e2.Amount && (t.Amount = Math.round(e2.Amount)), void 0 !== e2.Type && (t.Type = voteContract_EnumVoteTypeToJSON(e2.Type)), t;
}, fromPartial(e2) {
  var t, n, o;
  const r = createBaseVoteContract();
  return r.ProposalID = null !== (t = e2.ProposalID) && void 0 !== t ? t : 0, r.Amount = null !== (n = e2.Amount) && void 0 !== n ? n : 0, r.Type = null !== (o = e2.Type) && void 0 !== o ? o : 0, r;
} };
function createBaseConfigITOContract() {
  return { AssetID: new Uint8Array(), ReceiverAddress: new Uint8Array(), Status: 0, MaxAmount: 0, PackInfo: {} };
}
var ConfigITOContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.AssetID && 0 !== e2.AssetID.length && t.uint32(10).bytes(e2.AssetID), void 0 !== e2.ReceiverAddress && 0 !== e2.ReceiverAddress.length && t.uint32(18).bytes(e2.ReceiverAddress), void 0 !== e2.Status && 0 !== e2.Status && t.uint32(24).int32(e2.Status), void 0 !== e2.MaxAmount && 0 !== e2.MaxAmount && t.uint32(32).int64(e2.MaxAmount), Object.entries(e2.PackInfo || {}).forEach(([e3, n]) => {
  ConfigITOContract_PackInfoEntry.encode({ key: e3, value: n }, t.uint32(42).fork()).ldelim();
}), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseConfigITOContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.AssetID = n.bytes();
        break;
      case 2:
        r.ReceiverAddress = n.bytes();
        break;
      case 3:
        r.Status = n.int32();
        break;
      case 4:
        r.MaxAmount = longToNumber$1(n.int64());
        break;
      case 5:
        const t2 = ConfigITOContract_PackInfoEntry.decode(n, n.uint32());
        void 0 !== t2.value && (r.PackInfo[t2.key] = t2.value);
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ AssetID: isSet$2(e2.AssetID) ? bytesFromBase64$2(e2.AssetID) : new Uint8Array(), ReceiverAddress: isSet$2(e2.ReceiverAddress) ? bytesFromBase64$2(e2.ReceiverAddress) : new Uint8Array(), Status: isSet$2(e2.Status) ? configITOContract_EnumITOStatusFromJSON(e2.Status) : 0, MaxAmount: isSet$2(e2.MaxAmount) ? Number(e2.MaxAmount) : 0, PackInfo: isObject(e2.PackInfo) ? Object.entries(e2.PackInfo).reduce((e3, [t, n]) => (e3[t] = PackInfo.fromJSON(n), e3), {}) : {} }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.AssetID && (t.AssetID = base64FromBytes$2(void 0 !== e2.AssetID ? e2.AssetID : new Uint8Array())), void 0 !== e2.ReceiverAddress && (t.ReceiverAddress = base64FromBytes$2(void 0 !== e2.ReceiverAddress ? e2.ReceiverAddress : new Uint8Array())), void 0 !== e2.Status && (t.Status = configITOContract_EnumITOStatusToJSON(e2.Status)), void 0 !== e2.MaxAmount && (t.MaxAmount = Math.round(e2.MaxAmount)), t.PackInfo = {}, e2.PackInfo && Object.entries(e2.PackInfo).forEach(([e3, n]) => {
    t.PackInfo[e3] = PackInfo.toJSON(n);
  }), t;
}, fromPartial(e2) {
  var t, n, o, r, a;
  const i = createBaseConfigITOContract();
  return i.AssetID = null !== (t = e2.AssetID) && void 0 !== t ? t : new Uint8Array(), i.ReceiverAddress = null !== (n = e2.ReceiverAddress) && void 0 !== n ? n : new Uint8Array(), i.Status = null !== (o = e2.Status) && void 0 !== o ? o : 0, i.MaxAmount = null !== (r = e2.MaxAmount) && void 0 !== r ? r : 0, i.PackInfo = Object.entries(null !== (a = e2.PackInfo) && void 0 !== a ? a : {}).reduce((e3, [t2, n2]) => (void 0 !== n2 && (e3[t2] = PackInfo.fromPartial(n2)), e3), {}), i;
} };
function createBaseConfigITOContract_PackInfoEntry() {
  return { key: "", value: void 0 };
}
var ConfigITOContract_PackInfoEntry = { encode: (e2, t = minimal.Writer.create()) => ("" !== e2.key && t.uint32(10).string(e2.key), void 0 !== e2.value && PackInfo.encode(e2.value, t.uint32(18).fork()).ldelim(), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseConfigITOContract_PackInfoEntry();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.key = n.string();
        break;
      case 2:
        r.value = PackInfo.decode(n, n.uint32());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ key: isSet$2(e2.key) ? String(e2.key) : "", value: isSet$2(e2.value) ? PackInfo.fromJSON(e2.value) : void 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.key && (t.key = e2.key), void 0 !== e2.value && (t.value = e2.value ? PackInfo.toJSON(e2.value) : void 0), t;
}, fromPartial(e2) {
  var t;
  const n = createBaseConfigITOContract_PackInfoEntry();
  return n.key = null !== (t = e2.key) && void 0 !== t ? t : "", n.value = void 0 !== e2.value && null !== e2.value ? PackInfo.fromPartial(e2.value) : void 0, n;
} };
function createBaseSetITOPricesContract() {
  return { AssetID: new Uint8Array(), PackInfo: {} };
}
var SetITOPricesContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.AssetID && 0 !== e2.AssetID.length && t.uint32(10).bytes(e2.AssetID), Object.entries(e2.PackInfo || {}).forEach(([e3, n]) => {
  SetITOPricesContract_PackInfoEntry.encode({ key: e3, value: n }, t.uint32(18).fork()).ldelim();
}), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseSetITOPricesContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.AssetID = n.bytes();
        break;
      case 2:
        const t2 = SetITOPricesContract_PackInfoEntry.decode(n, n.uint32());
        void 0 !== t2.value && (r.PackInfo[t2.key] = t2.value);
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ AssetID: isSet$2(e2.AssetID) ? bytesFromBase64$2(e2.AssetID) : new Uint8Array(), PackInfo: isObject(e2.PackInfo) ? Object.entries(e2.PackInfo).reduce((e3, [t, n]) => (e3[t] = PackInfo.fromJSON(n), e3), {}) : {} }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.AssetID && (t.AssetID = base64FromBytes$2(void 0 !== e2.AssetID ? e2.AssetID : new Uint8Array())), t.PackInfo = {}, e2.PackInfo && Object.entries(e2.PackInfo).forEach(([e3, n]) => {
    t.PackInfo[e3] = PackInfo.toJSON(n);
  }), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseSetITOPricesContract();
  return o.AssetID = null !== (t = e2.AssetID) && void 0 !== t ? t : new Uint8Array(), o.PackInfo = Object.entries(null !== (n = e2.PackInfo) && void 0 !== n ? n : {}).reduce((e3, [t2, n2]) => (void 0 !== n2 && (e3[t2] = PackInfo.fromPartial(n2)), e3), {}), o;
} };
function createBaseSetITOPricesContract_PackInfoEntry() {
  return { key: "", value: void 0 };
}
var SetITOPricesContract_PackInfoEntry = { encode: (e2, t = minimal.Writer.create()) => ("" !== e2.key && t.uint32(10).string(e2.key), void 0 !== e2.value && PackInfo.encode(e2.value, t.uint32(18).fork()).ldelim(), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseSetITOPricesContract_PackInfoEntry();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.key = n.string();
        break;
      case 2:
        r.value = PackInfo.decode(n, n.uint32());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ key: isSet$2(e2.key) ? String(e2.key) : "", value: isSet$2(e2.value) ? PackInfo.fromJSON(e2.value) : void 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.key && (t.key = e2.key), void 0 !== e2.value && (t.value = e2.value ? PackInfo.toJSON(e2.value) : void 0), t;
}, fromPartial(e2) {
  var t;
  const n = createBaseSetITOPricesContract_PackInfoEntry();
  return n.key = null !== (t = e2.key) && void 0 !== t ? t : "", n.value = void 0 !== e2.value && null !== e2.value ? PackInfo.fromPartial(e2.value) : void 0, n;
} };
function createBasePackInfo() {
  return { Packs: [] };
}
var PackInfo = { encode(e2, t = minimal.Writer.create()) {
  if (void 0 !== e2.Packs && 0 !== e2.Packs.length)
    for (const n of e2.Packs)
      PackItem.encode(n, t.uint32(10).fork()).ldelim();
  return t;
}, decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBasePackInfo();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    if (e3 >>> 3 == 1)
      r.Packs.push(PackItem.decode(n, n.uint32()));
    else
      n.skipType(7 & e3);
  }
  return r;
}, fromJSON: (e2) => ({ Packs: Array.isArray(null == e2 ? void 0 : e2.Packs) ? e2.Packs.map((e3) => PackItem.fromJSON(e3)) : [] }), toJSON(e2) {
  const t = {};
  return e2.Packs ? t.Packs = e2.Packs.map((e3) => e3 ? PackItem.toJSON(e3) : void 0) : t.Packs = [], t;
}, fromPartial(e2) {
  var t;
  const n = createBasePackInfo();
  return n.Packs = (null === (t = e2.Packs) || void 0 === t ? void 0 : t.map((e3) => PackItem.fromPartial(e3))) || [], n;
} };
function createBasePackItem() {
  return { Amount: 0, Price: 0 };
}
var PackItem = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.Amount && 0 !== e2.Amount && t.uint32(8).int64(e2.Amount), void 0 !== e2.Price && 0 !== e2.Price && t.uint32(16).int64(e2.Price), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBasePackItem();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.Amount = longToNumber$1(n.int64());
        break;
      case 2:
        r.Price = longToNumber$1(n.int64());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ Amount: isSet$2(e2.Amount) ? Number(e2.Amount) : 0, Price: isSet$2(e2.Price) ? Number(e2.Price) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.Amount && (t.Amount = Math.round(e2.Amount)), void 0 !== e2.Price && (t.Price = Math.round(e2.Price)), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBasePackItem();
  return o.Amount = null !== (t = e2.Amount) && void 0 !== t ? t : 0, o.Price = null !== (n = e2.Price) && void 0 !== n ? n : 0, o;
} };
function createBaseBuyContract() {
  return { BuyType: 0, ID: new Uint8Array(), CurrencyID: new Uint8Array(), Amount: 0 };
}
var BuyContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.BuyType && 0 !== e2.BuyType && t.uint32(8).int32(e2.BuyType), void 0 !== e2.ID && 0 !== e2.ID.length && t.uint32(18).bytes(e2.ID), void 0 !== e2.CurrencyID && 0 !== e2.CurrencyID.length && t.uint32(26).bytes(e2.CurrencyID), void 0 !== e2.Amount && 0 !== e2.Amount && t.uint32(32).int64(e2.Amount), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseBuyContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.BuyType = n.int32();
        break;
      case 2:
        r.ID = n.bytes();
        break;
      case 3:
        r.CurrencyID = n.bytes();
        break;
      case 4:
        r.Amount = longToNumber$1(n.int64());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ BuyType: isSet$2(e2.BuyType) ? buyContract_EnumBuyTypeFromJSON(e2.BuyType) : 0, ID: isSet$2(e2.ID) ? bytesFromBase64$2(e2.ID) : new Uint8Array(), CurrencyID: isSet$2(e2.CurrencyID) ? bytesFromBase64$2(e2.CurrencyID) : new Uint8Array(), Amount: isSet$2(e2.Amount) ? Number(e2.Amount) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.BuyType && (t.BuyType = buyContract_EnumBuyTypeToJSON(e2.BuyType)), void 0 !== e2.ID && (t.ID = base64FromBytes$2(void 0 !== e2.ID ? e2.ID : new Uint8Array())), void 0 !== e2.CurrencyID && (t.CurrencyID = base64FromBytes$2(void 0 !== e2.CurrencyID ? e2.CurrencyID : new Uint8Array())), void 0 !== e2.Amount && (t.Amount = Math.round(e2.Amount)), t;
}, fromPartial(e2) {
  var t, n, o, r;
  const a = createBaseBuyContract();
  return a.BuyType = null !== (t = e2.BuyType) && void 0 !== t ? t : 0, a.ID = null !== (n = e2.ID) && void 0 !== n ? n : new Uint8Array(), a.CurrencyID = null !== (o = e2.CurrencyID) && void 0 !== o ? o : new Uint8Array(), a.Amount = null !== (r = e2.Amount) && void 0 !== r ? r : 0, a;
} };
function createBaseSellContract() {
  return { MarketType: 0, MarketplaceID: new Uint8Array(), AssetID: new Uint8Array(), CurrencyID: new Uint8Array(), Price: 0, ReservePrice: 0, EndTime: 0 };
}
var SellContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.MarketType && 0 !== e2.MarketType && t.uint32(8).int32(e2.MarketType), void 0 !== e2.MarketplaceID && 0 !== e2.MarketplaceID.length && t.uint32(18).bytes(e2.MarketplaceID), void 0 !== e2.AssetID && 0 !== e2.AssetID.length && t.uint32(26).bytes(e2.AssetID), void 0 !== e2.CurrencyID && 0 !== e2.CurrencyID.length && t.uint32(34).bytes(e2.CurrencyID), void 0 !== e2.Price && 0 !== e2.Price && t.uint32(40).int64(e2.Price), void 0 !== e2.ReservePrice && 0 !== e2.ReservePrice && t.uint32(48).int64(e2.ReservePrice), void 0 !== e2.EndTime && 0 !== e2.EndTime && t.uint32(56).int64(e2.EndTime), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseSellContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.MarketType = n.int32();
        break;
      case 2:
        r.MarketplaceID = n.bytes();
        break;
      case 3:
        r.AssetID = n.bytes();
        break;
      case 4:
        r.CurrencyID = n.bytes();
        break;
      case 5:
        r.Price = longToNumber$1(n.int64());
        break;
      case 6:
        r.ReservePrice = longToNumber$1(n.int64());
        break;
      case 7:
        r.EndTime = longToNumber$1(n.int64());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ MarketType: isSet$2(e2.MarketType) ? sellContract_EnumMarketTypeFromJSON(e2.MarketType) : 0, MarketplaceID: isSet$2(e2.MarketplaceID) ? bytesFromBase64$2(e2.MarketplaceID) : new Uint8Array(), AssetID: isSet$2(e2.AssetID) ? bytesFromBase64$2(e2.AssetID) : new Uint8Array(), CurrencyID: isSet$2(e2.CurrencyID) ? bytesFromBase64$2(e2.CurrencyID) : new Uint8Array(), Price: isSet$2(e2.Price) ? Number(e2.Price) : 0, ReservePrice: isSet$2(e2.ReservePrice) ? Number(e2.ReservePrice) : 0, EndTime: isSet$2(e2.EndTime) ? Number(e2.EndTime) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.MarketType && (t.MarketType = sellContract_EnumMarketTypeToJSON(e2.MarketType)), void 0 !== e2.MarketplaceID && (t.MarketplaceID = base64FromBytes$2(void 0 !== e2.MarketplaceID ? e2.MarketplaceID : new Uint8Array())), void 0 !== e2.AssetID && (t.AssetID = base64FromBytes$2(void 0 !== e2.AssetID ? e2.AssetID : new Uint8Array())), void 0 !== e2.CurrencyID && (t.CurrencyID = base64FromBytes$2(void 0 !== e2.CurrencyID ? e2.CurrencyID : new Uint8Array())), void 0 !== e2.Price && (t.Price = Math.round(e2.Price)), void 0 !== e2.ReservePrice && (t.ReservePrice = Math.round(e2.ReservePrice)), void 0 !== e2.EndTime && (t.EndTime = Math.round(e2.EndTime)), t;
}, fromPartial(e2) {
  var t, n, o, r, a, i, s;
  const c = createBaseSellContract();
  return c.MarketType = null !== (t = e2.MarketType) && void 0 !== t ? t : 0, c.MarketplaceID = null !== (n = e2.MarketplaceID) && void 0 !== n ? n : new Uint8Array(), c.AssetID = null !== (o = e2.AssetID) && void 0 !== o ? o : new Uint8Array(), c.CurrencyID = null !== (r = e2.CurrencyID) && void 0 !== r ? r : new Uint8Array(), c.Price = null !== (a = e2.Price) && void 0 !== a ? a : 0, c.ReservePrice = null !== (i = e2.ReservePrice) && void 0 !== i ? i : 0, c.EndTime = null !== (s = e2.EndTime) && void 0 !== s ? s : 0, c;
} };
function createBaseCancelMarketOrderContract() {
  return { OrderID: new Uint8Array() };
}
var CancelMarketOrderContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.OrderID && 0 !== e2.OrderID.length && t.uint32(10).bytes(e2.OrderID), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseCancelMarketOrderContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    if (e3 >>> 3 == 1)
      r.OrderID = n.bytes();
    else
      n.skipType(7 & e3);
  }
  return r;
}, fromJSON: (e2) => ({ OrderID: isSet$2(e2.orderId) ? bytesFromBase64$2(e2.orderId) : new Uint8Array() }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.OrderID && (t.orderId = base64FromBytes$2(void 0 !== e2.OrderID ? e2.OrderID : new Uint8Array())), t;
}, fromPartial(e2) {
  var t;
  const n = createBaseCancelMarketOrderContract();
  return n.OrderID = null !== (t = e2.OrderID) && void 0 !== t ? t : new Uint8Array(), n;
} };
function createBaseCreateMarketplaceContract() {
  return { Name: new Uint8Array(), ReferralAddress: new Uint8Array(), ReferralPercentage: 0 };
}
var CreateMarketplaceContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.Name && 0 !== e2.Name.length && t.uint32(10).bytes(e2.Name), void 0 !== e2.ReferralAddress && 0 !== e2.ReferralAddress.length && t.uint32(18).bytes(e2.ReferralAddress), void 0 !== e2.ReferralPercentage && 0 !== e2.ReferralPercentage && t.uint32(24).uint32(e2.ReferralPercentage), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseCreateMarketplaceContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.Name = n.bytes();
        break;
      case 2:
        r.ReferralAddress = n.bytes();
        break;
      case 3:
        r.ReferralPercentage = n.uint32();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ Name: isSet$2(e2.Name) ? bytesFromBase64$2(e2.Name) : new Uint8Array(), ReferralAddress: isSet$2(e2.ReferralAddress) ? bytesFromBase64$2(e2.ReferralAddress) : new Uint8Array(), ReferralPercentage: isSet$2(e2.ReferralPercentage) ? Number(e2.ReferralPercentage) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.Name && (t.Name = base64FromBytes$2(void 0 !== e2.Name ? e2.Name : new Uint8Array())), void 0 !== e2.ReferralAddress && (t.ReferralAddress = base64FromBytes$2(void 0 !== e2.ReferralAddress ? e2.ReferralAddress : new Uint8Array())), void 0 !== e2.ReferralPercentage && (t.ReferralPercentage = Math.round(e2.ReferralPercentage)), t;
}, fromPartial(e2) {
  var t, n, o;
  const r = createBaseCreateMarketplaceContract();
  return r.Name = null !== (t = e2.Name) && void 0 !== t ? t : new Uint8Array(), r.ReferralAddress = null !== (n = e2.ReferralAddress) && void 0 !== n ? n : new Uint8Array(), r.ReferralPercentage = null !== (o = e2.ReferralPercentage) && void 0 !== o ? o : 0, r;
} };
function createBaseConfigMarketplaceContract() {
  return { MarketplaceID: new Uint8Array(), Name: new Uint8Array(), ReferralAddress: new Uint8Array(), ReferralPercentage: 0 };
}
var ConfigMarketplaceContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.MarketplaceID && 0 !== e2.MarketplaceID.length && t.uint32(10).bytes(e2.MarketplaceID), void 0 !== e2.Name && 0 !== e2.Name.length && t.uint32(18).bytes(e2.Name), void 0 !== e2.ReferralAddress && 0 !== e2.ReferralAddress.length && t.uint32(26).bytes(e2.ReferralAddress), void 0 !== e2.ReferralPercentage && 0 !== e2.ReferralPercentage && t.uint32(32).uint32(e2.ReferralPercentage), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseConfigMarketplaceContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.MarketplaceID = n.bytes();
        break;
      case 2:
        r.Name = n.bytes();
        break;
      case 3:
        r.ReferralAddress = n.bytes();
        break;
      case 4:
        r.ReferralPercentage = n.uint32();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ MarketplaceID: isSet$2(e2.MarketplaceID) ? bytesFromBase64$2(e2.MarketplaceID) : new Uint8Array(), Name: isSet$2(e2.Name) ? bytesFromBase64$2(e2.Name) : new Uint8Array(), ReferralAddress: isSet$2(e2.ReferralAddress) ? bytesFromBase64$2(e2.ReferralAddress) : new Uint8Array(), ReferralPercentage: isSet$2(e2.ReferralPercentage) ? Number(e2.ReferralPercentage) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.MarketplaceID && (t.MarketplaceID = base64FromBytes$2(void 0 !== e2.MarketplaceID ? e2.MarketplaceID : new Uint8Array())), void 0 !== e2.Name && (t.Name = base64FromBytes$2(void 0 !== e2.Name ? e2.Name : new Uint8Array())), void 0 !== e2.ReferralAddress && (t.ReferralAddress = base64FromBytes$2(void 0 !== e2.ReferralAddress ? e2.ReferralAddress : new Uint8Array())), void 0 !== e2.ReferralPercentage && (t.ReferralPercentage = Math.round(e2.ReferralPercentage)), t;
}, fromPartial(e2) {
  var t, n, o, r;
  const a = createBaseConfigMarketplaceContract();
  return a.MarketplaceID = null !== (t = e2.MarketplaceID) && void 0 !== t ? t : new Uint8Array(), a.Name = null !== (n = e2.Name) && void 0 !== n ? n : new Uint8Array(), a.ReferralAddress = null !== (o = e2.ReferralAddress) && void 0 !== o ? o : new Uint8Array(), a.ReferralPercentage = null !== (r = e2.ReferralPercentage) && void 0 !== r ? r : 0, a;
} };
function createBaseAccKey() {
  return { address: new Uint8Array(), weight: 0 };
}
var AccKey = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.address && 0 !== e2.address.length && t.uint32(10).bytes(e2.address), void 0 !== e2.weight && 0 !== e2.weight && t.uint32(16).int64(e2.weight), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseAccKey();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.address = n.bytes();
        break;
      case 2:
        r.weight = longToNumber$1(n.int64());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ address: isSet$2(e2.address) ? bytesFromBase64$2(e2.address) : new Uint8Array(), weight: isSet$2(e2.weight) ? Number(e2.weight) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.address && (t.address = base64FromBytes$2(void 0 !== e2.address ? e2.address : new Uint8Array())), void 0 !== e2.weight && (t.weight = Math.round(e2.weight)), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseAccKey();
  return o.address = null !== (t = e2.address) && void 0 !== t ? t : new Uint8Array(), o.weight = null !== (n = e2.weight) && void 0 !== n ? n : 0, o;
} };
function createBaseAccPermission() {
  return { Type: 0, PermissionName: "", Threshold: 0, Operations: new Uint8Array(), Signers: [] };
}
var AccPermission = { encode(e2, t = minimal.Writer.create()) {
  if (void 0 !== e2.Type && 0 !== e2.Type && t.uint32(16).int32(e2.Type), void 0 !== e2.PermissionName && "" !== e2.PermissionName && t.uint32(26).string(e2.PermissionName), void 0 !== e2.Threshold && 0 !== e2.Threshold && t.uint32(32).int64(e2.Threshold), void 0 !== e2.Operations && 0 !== e2.Operations.length && t.uint32(42).bytes(e2.Operations), void 0 !== e2.Signers && 0 !== e2.Signers.length)
    for (const n of e2.Signers)
      AccKey.encode(n, t.uint32(50).fork()).ldelim();
  return t;
}, decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseAccPermission();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 2:
        r.Type = n.int32();
        break;
      case 3:
        r.PermissionName = n.string();
        break;
      case 4:
        r.Threshold = longToNumber$1(n.int64());
        break;
      case 5:
        r.Operations = n.bytes();
        break;
      case 6:
        r.Signers.push(AccKey.decode(n, n.uint32()));
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ Type: isSet$2(e2.Type) ? accPermission_AccPermissionTypeFromJSON(e2.Type) : 0, PermissionName: isSet$2(e2.PermissionName) ? String(e2.PermissionName) : "", Threshold: isSet$2(e2.Threshold) ? Number(e2.Threshold) : 0, Operations: isSet$2(e2.Operations) ? bytesFromBase64$2(e2.Operations) : new Uint8Array(), Signers: Array.isArray(null == e2 ? void 0 : e2.Signers) ? e2.Signers.map((e3) => AccKey.fromJSON(e3)) : [] }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.Type && (t.Type = accPermission_AccPermissionTypeToJSON(e2.Type)), void 0 !== e2.PermissionName && (t.PermissionName = e2.PermissionName), void 0 !== e2.Threshold && (t.Threshold = Math.round(e2.Threshold)), void 0 !== e2.Operations && (t.Operations = base64FromBytes$2(void 0 !== e2.Operations ? e2.Operations : new Uint8Array())), e2.Signers ? t.Signers = e2.Signers.map((e3) => e3 ? AccKey.toJSON(e3) : void 0) : t.Signers = [], t;
}, fromPartial(e2) {
  var t, n, o, r, a;
  const i = createBaseAccPermission();
  return i.Type = null !== (t = e2.Type) && void 0 !== t ? t : 0, i.PermissionName = null !== (n = e2.PermissionName) && void 0 !== n ? n : "", i.Threshold = null !== (o = e2.Threshold) && void 0 !== o ? o : 0, i.Operations = null !== (r = e2.Operations) && void 0 !== r ? r : new Uint8Array(), i.Signers = (null === (a = e2.Signers) || void 0 === a ? void 0 : a.map((e3) => AccKey.fromPartial(e3))) || [], i;
} };
function createBaseUpdateAccountPermissionContract() {
  return { Permissions: [] };
}
var UpdateAccountPermissionContract = { encode(e2, t = minimal.Writer.create()) {
  if (void 0 !== e2.Permissions && 0 !== e2.Permissions.length)
    for (const n of e2.Permissions)
      AccPermission.encode(n, t.uint32(66).fork()).ldelim();
  return t;
}, decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseUpdateAccountPermissionContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    if (e3 >>> 3 == 8)
      r.Permissions.push(AccPermission.decode(n, n.uint32()));
    else
      n.skipType(7 & e3);
  }
  return r;
}, fromJSON: (e2) => ({ Permissions: Array.isArray(null == e2 ? void 0 : e2.Permissions) ? e2.Permissions.map((e3) => AccPermission.fromJSON(e3)) : [] }), toJSON(e2) {
  const t = {};
  return e2.Permissions ? t.Permissions = e2.Permissions.map((e3) => e3 ? AccPermission.toJSON(e3) : void 0) : t.Permissions = [], t;
}, fromPartial(e2) {
  var t;
  const n = createBaseUpdateAccountPermissionContract();
  return n.Permissions = (null === (t = e2.Permissions) || void 0 === t ? void 0 : t.map((e3) => AccPermission.fromPartial(e3))) || [], n;
} };
var protoMetadata$1 = { fileDescriptor: dist.FileDescriptorProto.fromPartial({ name: "lib/transaction/proto/contracts.proto", package: "proto", dependency: [], publicDependency: [], weakDependency: [], messageType: [{ name: "TransferContract", field: [{ name: "ToAddress", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ToAddress", options: void 0, proto3Optional: false }, { name: "AssetID", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "AssetID", options: void 0, proto3Optional: false }, { name: "Amount", number: 3, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Amount", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "CreateAssetContract", field: [{ name: "Type", number: 1, label: 1, type: 14, typeName: ".proto.CreateAssetContract.EnumAssetType", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Type", options: void 0, proto3Optional: false }, { name: "Name", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Name", options: void 0, proto3Optional: false }, { name: "Ticker", number: 3, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Ticker", options: void 0, proto3Optional: false }, { name: "OwnerAddress", number: 4, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "OwnerAddress", options: void 0, proto3Optional: false }, { name: "Logo", number: 5, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Logo", options: void 0, proto3Optional: false }, { name: "URIs", number: 6, label: 3, type: 11, typeName: ".proto.CreateAssetContract.URIsEntry", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "URIs", options: void 0, proto3Optional: false }, { name: "Precision", number: 7, label: 1, type: 13, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Precision", options: void 0, proto3Optional: false }, { name: "InitialSupply", number: 8, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "InitialSupply", options: void 0, proto3Optional: false }, { name: "MaxSupply", number: 9, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "MaxSupply", options: void 0, proto3Optional: false }, { name: "Royalties", number: 10, label: 1, type: 11, typeName: ".proto.RoyaltiesInfo", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Royalties", options: void 0, proto3Optional: false }, { name: "Properties", number: 11, label: 1, type: 11, typeName: ".proto.PropertiesInfo", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Properties", options: void 0, proto3Optional: false }, { name: "Attributes", number: 12, label: 1, type: 11, typeName: ".proto.AttributesInfo", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Attributes", options: void 0, proto3Optional: false }, { name: "Staking", number: 13, label: 1, type: 11, typeName: ".proto.StakingInfo", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Staking", options: void 0, proto3Optional: false }, { name: "Roles", number: 14, label: 3, type: 11, typeName: ".proto.RolesInfo", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Roles", options: void 0, proto3Optional: false }], extension: [], nestedType: [{ name: "URIsEntry", field: [{ name: "key", number: 1, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "key", options: void 0, proto3Optional: false }, { name: "value", number: 2, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "value", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: { messageSetWireFormat: false, noStandardDescriptorAccessor: false, deprecated: false, mapEntry: true, uninterpretedOption: [] }, reservedRange: [], reservedName: [] }], enumType: [{ name: "EnumAssetType", value: [{ name: "Fungible", number: 0, options: void 0 }, { name: "NonFungible", number: 1, options: void 0 }], options: void 0, reservedRange: [], reservedName: [] }], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "PropertiesInfo", field: [{ name: "CanFreeze", number: 1, label: 1, type: 8, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "CanFreeze", options: void 0, proto3Optional: false }, { name: "CanWipe", number: 2, label: 1, type: 8, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "CanWipe", options: void 0, proto3Optional: false }, { name: "CanPause", number: 3, label: 1, type: 8, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "CanPause", options: void 0, proto3Optional: false }, { name: "CanMint", number: 4, label: 1, type: 8, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "CanMint", options: void 0, proto3Optional: false }, { name: "CanBurn", number: 5, label: 1, type: 8, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "CanBurn", options: void 0, proto3Optional: false }, { name: "CanChangeOwner", number: 6, label: 1, type: 8, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "CanChangeOwner", options: void 0, proto3Optional: false }, { name: "CanAddRoles", number: 7, label: 1, type: 8, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "CanAddRoles", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "AttributesInfo", field: [{ name: "IsPaused", number: 1, label: 1, type: 8, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "IsPaused", options: void 0, proto3Optional: false }, { name: "IsNFTMintStopped", number: 2, label: 1, type: 8, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "IsNFTMintStopped", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "StakingInfo", field: [{ name: "Type", number: 1, label: 1, type: 14, typeName: ".proto.StakingInfo.InterestType", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Type", options: void 0, proto3Optional: false }, { name: "APR", number: 2, label: 1, type: 13, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "APR", options: void 0, proto3Optional: false }, { name: "MinEpochsToClaim", number: 3, label: 1, type: 13, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "MinEpochsToClaim", options: void 0, proto3Optional: false }, { name: "MinEpochsToUnstake", number: 4, label: 1, type: 13, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "MinEpochsToUnstake", options: void 0, proto3Optional: false }, { name: "MinEpochsToWithdraw", number: 5, label: 1, type: 13, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "MinEpochsToWithdraw", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [{ name: "InterestType", value: [{ name: "APRI", number: 0, options: void 0 }, { name: "FPRI", number: 1, options: void 0 }], options: void 0, reservedRange: [], reservedName: [] }], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "RolesInfo", field: [{ name: "Address", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Address", options: void 0, proto3Optional: false }, { name: "HasRoleMint", number: 2, label: 1, type: 8, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "HasRoleMint", options: void 0, proto3Optional: false }, { name: "HasRoleSetITOPrices", number: 3, label: 1, type: 8, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "HasRoleSetITOPrices", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "RoyaltiesInfo", field: [{ name: "Address", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Address", options: void 0, proto3Optional: false }, { name: "TransferPercentage", number: 2, label: 3, type: 11, typeName: ".proto.RoyaltyInfo", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "TransferPercentage", options: void 0, proto3Optional: false }, { name: "TransferFixed", number: 3, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "TransferFixed", options: void 0, proto3Optional: false }, { name: "MarketPercentage", number: 4, label: 1, type: 13, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "MarketPercentage", options: void 0, proto3Optional: false }, { name: "MarketFixed", number: 5, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "MarketFixed", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "RoyaltyInfo", field: [{ name: "Amount", number: 1, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "amount", options: void 0, proto3Optional: false }, { name: "Percentage", number: 2, label: 1, type: 13, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "percentage", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "AssetTriggerContract", field: [{ name: "TriggerType", number: 1, label: 1, type: 14, typeName: ".proto.AssetTriggerContract.EnumTriggerType", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "TriggerType", options: void 0, proto3Optional: false }, { name: "AssetID", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "AssetID", options: void 0, proto3Optional: false }, { name: "ToAddress", number: 3, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ToAddress", options: void 0, proto3Optional: false }, { name: "Amount", number: 4, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Amount", options: void 0, proto3Optional: false }, { name: "MIME", number: 5, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "MIME", options: void 0, proto3Optional: false }, { name: "Logo", number: 6, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Logo", options: void 0, proto3Optional: false }, { name: "URIs", number: 7, label: 3, type: 11, typeName: ".proto.AssetTriggerContract.URIsEntry", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "URIs", options: void 0, proto3Optional: false }, { name: "Role", number: 8, label: 1, type: 11, typeName: ".proto.RolesInfo", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Role", options: void 0, proto3Optional: false }, { name: "Staking", number: 9, label: 1, type: 11, typeName: ".proto.StakingInfo", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Staking", options: void 0, proto3Optional: false }], extension: [], nestedType: [{ name: "URIsEntry", field: [{ name: "key", number: 1, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "key", options: void 0, proto3Optional: false }, { name: "value", number: 2, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "value", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: { messageSetWireFormat: false, noStandardDescriptorAccessor: false, deprecated: false, mapEntry: true, uninterpretedOption: [] }, reservedRange: [], reservedName: [] }], enumType: [{ name: "EnumTriggerType", value: [{ name: "Mint", number: 0, options: void 0 }, { name: "Burn", number: 1, options: void 0 }, { name: "Wipe", number: 2, options: void 0 }, { name: "Pause", number: 3, options: void 0 }, { name: "Resume", number: 4, options: void 0 }, { name: "ChangeOwner", number: 5, options: void 0 }, { name: "AddRole", number: 6, options: void 0 }, { name: "RemoveRole", number: 7, options: void 0 }, { name: "UpdateMetadata", number: 8, options: void 0 }, { name: "StopNFTMint", number: 9, options: void 0 }, { name: "UpdateLogo", number: 10, options: void 0 }, { name: "UpdateURIs", number: 11, options: void 0 }, { name: "ChangeRoyaltiesReceiver", number: 12, options: void 0 }, { name: "UpdateStaking", number: 13, options: void 0 }], options: void 0, reservedRange: [], reservedName: [] }], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "ValidatorConfig", field: [{ name: "BLSPublicKey", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "BLSPublicKey", options: void 0, proto3Optional: false }, { name: "RewardAddress", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "RewardAddress", options: void 0, proto3Optional: false }, { name: "CanDelegate", number: 3, label: 1, type: 8, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "CanDelegate", options: void 0, proto3Optional: false }, { name: "Commission", number: 4, label: 1, type: 13, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Commission", options: void 0, proto3Optional: false }, { name: "MaxDelegationAmount", number: 5, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "MaxDelegationAmount", options: void 0, proto3Optional: false }, { name: "Logo", number: 6, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Logo", options: void 0, proto3Optional: false }, { name: "URIs", number: 7, label: 3, type: 11, typeName: ".proto.ValidatorConfig.URIsEntry", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "URIs", options: void 0, proto3Optional: false }, { name: "Name", number: 8, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Name", options: void 0, proto3Optional: false }], extension: [], nestedType: [{ name: "URIsEntry", field: [{ name: "key", number: 1, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "key", options: void 0, proto3Optional: false }, { name: "value", number: 2, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "value", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: { messageSetWireFormat: false, noStandardDescriptorAccessor: false, deprecated: false, mapEntry: true, uninterpretedOption: [] }, reservedRange: [], reservedName: [] }], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "CreateValidatorContract", field: [{ name: "OwnerAddress", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "OwnerAddress", options: void 0, proto3Optional: false }, { name: "Config", number: 2, label: 1, type: 11, typeName: ".proto.ValidatorConfig", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Config", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "ValidatorConfigContract", field: [{ name: "Config", number: 1, label: 1, type: 11, typeName: ".proto.ValidatorConfig", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Config", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "FreezeContract", field: [{ name: "AssetID", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "AssetID", options: void 0, proto3Optional: false }, { name: "Amount", number: 2, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Amount", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "UnfreezeContract", field: [{ name: "AssetID", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "AssetID", options: void 0, proto3Optional: false }, { name: "BucketID", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "BucketID", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "DelegateContract", field: [{ name: "ToAddress", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ToAddress", options: void 0, proto3Optional: false }, { name: "BucketID", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "BucketID", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "UndelegateContract", field: [{ name: "BucketID", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "BucketID", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "WithdrawContract", field: [{ name: "AssetID", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "AssetID", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "ClaimContract", field: [{ name: "ClaimType", number: 1, label: 1, type: 14, typeName: ".proto.ClaimContract.EnumClaimType", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ClaimType", options: void 0, proto3Optional: false }, { name: "ID", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ID", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [{ name: "EnumClaimType", value: [{ name: "StakingClaim", number: 0, options: void 0 }, { name: "AllowanceClaim", number: 1, options: void 0 }, { name: "MarketClaim", number: 2, options: void 0 }], options: void 0, reservedRange: [], reservedName: [] }], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "UnjailContract", field: [], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "SetAccountNameContract", field: [{ name: "Name", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Name", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "ProposalContract", field: [{ name: "Parameters", number: 1, label: 3, type: 11, typeName: ".proto.ProposalContract.ParametersEntry", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Parameters", options: void 0, proto3Optional: false }, { name: "Description", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Description", options: void 0, proto3Optional: false }, { name: "EpochsDuration", number: 3, label: 1, type: 13, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "EpochsDuration", options: void 0, proto3Optional: false }], extension: [], nestedType: [{ name: "ParametersEntry", field: [{ name: "key", number: 1, label: 1, type: 5, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "key", options: void 0, proto3Optional: false }, { name: "value", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "value", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: { messageSetWireFormat: false, noStandardDescriptorAccessor: false, deprecated: false, mapEntry: true, uninterpretedOption: [] }, reservedRange: [], reservedName: [] }], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "VoteContract", field: [{ name: "ProposalID", number: 1, label: 1, type: 4, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ProposalID", options: void 0, proto3Optional: false }, { name: "Amount", number: 2, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Amount", options: void 0, proto3Optional: false }, { name: "Type", number: 3, label: 1, type: 14, typeName: ".proto.VoteContract.EnumVoteType", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Type", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [{ name: "EnumVoteType", value: [{ name: "Yes", number: 0, options: void 0 }, { name: "No", number: 1, options: void 0 }], options: void 0, reservedRange: [], reservedName: [] }], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "ConfigITOContract", field: [{ name: "AssetID", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "AssetID", options: void 0, proto3Optional: false }, { name: "ReceiverAddress", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ReceiverAddress", options: void 0, proto3Optional: false }, { name: "Status", number: 3, label: 1, type: 14, typeName: ".proto.ConfigITOContract.EnumITOStatus", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Status", options: void 0, proto3Optional: false }, { name: "MaxAmount", number: 4, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "MaxAmount", options: void 0, proto3Optional: false }, { name: "PackInfo", number: 5, label: 3, type: 11, typeName: ".proto.ConfigITOContract.PackInfoEntry", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "PackInfo", options: void 0, proto3Optional: false }], extension: [], nestedType: [{ name: "PackInfoEntry", field: [{ name: "key", number: 1, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "key", options: void 0, proto3Optional: false }, { name: "value", number: 2, label: 1, type: 11, typeName: ".proto.PackInfo", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "value", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: { messageSetWireFormat: false, noStandardDescriptorAccessor: false, deprecated: false, mapEntry: true, uninterpretedOption: [] }, reservedRange: [], reservedName: [] }], enumType: [{ name: "EnumITOStatus", value: [{ name: "DefaultITO", number: 0, options: void 0 }, { name: "ActiveITO", number: 1, options: void 0 }, { name: "PausedITO", number: 2, options: void 0 }], options: void 0, reservedRange: [], reservedName: [] }], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "SetITOPricesContract", field: [{ name: "AssetID", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "AssetID", options: void 0, proto3Optional: false }, { name: "PackInfo", number: 2, label: 3, type: 11, typeName: ".proto.SetITOPricesContract.PackInfoEntry", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "PackInfo", options: void 0, proto3Optional: false }], extension: [], nestedType: [{ name: "PackInfoEntry", field: [{ name: "key", number: 1, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "key", options: void 0, proto3Optional: false }, { name: "value", number: 2, label: 1, type: 11, typeName: ".proto.PackInfo", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "value", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: { messageSetWireFormat: false, noStandardDescriptorAccessor: false, deprecated: false, mapEntry: true, uninterpretedOption: [] }, reservedRange: [], reservedName: [] }], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "PackInfo", field: [{ name: "Packs", number: 1, label: 3, type: 11, typeName: ".proto.PackItem", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Packs", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "PackItem", field: [{ name: "Amount", number: 1, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Amount", options: void 0, proto3Optional: false }, { name: "Price", number: 2, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Price", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "BuyContract", field: [{ name: "BuyType", number: 1, label: 1, type: 14, typeName: ".proto.BuyContract.EnumBuyType", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "BuyType", options: void 0, proto3Optional: false }, { name: "ID", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ID", options: void 0, proto3Optional: false }, { name: "CurrencyID", number: 3, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "CurrencyID", options: void 0, proto3Optional: false }, { name: "Amount", number: 4, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Amount", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [{ name: "EnumBuyType", value: [{ name: "ITOBuy", number: 0, options: void 0 }, { name: "MarketBuy", number: 1, options: void 0 }], options: void 0, reservedRange: [], reservedName: [] }], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "SellContract", field: [{ name: "MarketType", number: 1, label: 1, type: 14, typeName: ".proto.SellContract.EnumMarketType", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "MarketType", options: void 0, proto3Optional: false }, { name: "MarketplaceID", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "MarketplaceID", options: void 0, proto3Optional: false }, { name: "AssetID", number: 3, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "AssetID", options: void 0, proto3Optional: false }, { name: "CurrencyID", number: 4, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "CurrencyID", options: void 0, proto3Optional: false }, { name: "Price", number: 5, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Price", options: void 0, proto3Optional: false }, { name: "ReservePrice", number: 6, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ReservePrice", options: void 0, proto3Optional: false }, { name: "EndTime", number: 7, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "EndTime", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [{ name: "EnumMarketType", value: [{ name: "BuyItNowMarket", number: 0, options: void 0 }, { name: "AuctionMarket", number: 1, options: void 0 }], options: void 0, reservedRange: [], reservedName: [] }], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "CancelMarketOrderContract", field: [{ name: "OrderID", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "orderId", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "CreateMarketplaceContract", field: [{ name: "Name", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Name", options: void 0, proto3Optional: false }, { name: "ReferralAddress", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ReferralAddress", options: void 0, proto3Optional: false }, { name: "ReferralPercentage", number: 3, label: 1, type: 13, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ReferralPercentage", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "ConfigMarketplaceContract", field: [{ name: "MarketplaceID", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "MarketplaceID", options: void 0, proto3Optional: false }, { name: "Name", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Name", options: void 0, proto3Optional: false }, { name: "ReferralAddress", number: 3, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ReferralAddress", options: void 0, proto3Optional: false }, { name: "ReferralPercentage", number: 4, label: 1, type: 13, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ReferralPercentage", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "AccKey", field: [{ name: "address", number: 1, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "address", options: void 0, proto3Optional: false }, { name: "weight", number: 2, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "weight", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "AccPermission", field: [{ name: "Type", number: 2, label: 1, type: 14, typeName: ".proto.AccPermission.AccPermissionType", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Type", options: void 0, proto3Optional: false }, { name: "PermissionName", number: 3, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "PermissionName", options: void 0, proto3Optional: false }, { name: "Threshold", number: 4, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Threshold", options: void 0, proto3Optional: false }, { name: "Operations", number: 5, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Operations", options: void 0, proto3Optional: false }, { name: "Signers", number: 6, label: 3, type: 11, typeName: ".proto.AccKey", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Signers", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [{ name: "AccPermissionType", value: [{ name: "Owner", number: 0, options: void 0 }, { name: "User", number: 1, options: void 0 }], options: void 0, reservedRange: [], reservedName: [] }], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "UpdateAccountPermissionContract", field: [{ name: "Permissions", number: 8, label: 3, type: 11, typeName: ".proto.AccPermission", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Permissions", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }], enumType: [], service: [], extension: [], options: { javaPackage: "", javaOuterClassname: "", javaMultipleFiles: false, javaGenerateEqualsAndHash: false, javaStringCheckUtf8: false, optimizeFor: 1, goPackage: "./;transaction", ccGenericServices: false, javaGenericServices: false, pyGenericServices: false, phpGenericServices: false, deprecated: false, ccEnableArenas: false, objcClassPrefix: "", csharpNamespace: "", swiftPrefix: "", phpClassPrefix: "", phpNamespace: "", phpMetadataNamespace: "", rubyPackage: "", uninterpretedOption: [] }, sourceCodeInfo: { location: [{ path: [4, 0], span: [7, 0, 11, 1], leadingComments: " TXContract available\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 1], span: [14, 0, 33, 1], leadingComments: " CreateAssetContract holds the data for a Klever digital asset\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 2], span: [36, 0, 44, 1], leadingComments: " PropertiesInfo hold the properties structure for the KDA asset\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 3], span: [47, 0, 50, 1], leadingComments: " AttributesInfo hold the attributes structure for the KDA asset\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 4], span: [53, 0, 63, 1], leadingComments: " StakingInfo hold the staking structure for the KDA asset\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 5], span: [66, 0, 70, 1], leadingComments: " RolesInfo holds the roles for a given asset and the given address\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 6], span: [73, 0, 79, 1], leadingComments: " RoyaltiesInfo holds the royalties for a given asset\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 7], span: [82, 0, 85, 1], leadingComments: " RoyaltyInfo holds the royalty threshold\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 8], span: [88, 0, 114, 1], leadingComments: " AssetTriggerContract triggers assets functions\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 9], span: [117, 0, 126, 1], leadingComments: " ValidatorConfig holds the data for a validator configuration\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 10], span: [129, 0, 132, 1], leadingComments: " CreateValidatorContract holds the data for create a validator\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 11], span: [135, 0, 137, 1], leadingComments: " ValidatorConfigContract holds the data for a validator configuration transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 12], span: [140, 0, 143, 1], leadingComments: " FreezeContract holds the data for a freeze transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 13], span: [146, 0, 149, 1], leadingComments: " UnfreezeContract holds the data for a unfreeze transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 14], span: [152, 0, 155, 1], leadingComments: " DelegateContract holds the data for a delegate transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 15], span: [158, 0, 160, 1], leadingComments: " UndelegateContract holds the data for a undelegate transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 16], span: [163, 0, 165, 1], leadingComments: " WithdrawContract holds the data for a withdraw transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 17], span: [168, 0, 176, 1], leadingComments: " ClaimContract holds the data for a claim transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 18], span: [179, 0, 25], leadingComments: " UnjailContract holds the data for a unjail transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 19], span: [182, 0, 184, 1], leadingComments: " SetAccountNameContract holds the data for a setAccountName transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 20], span: [187, 0, 191, 1], leadingComments: " ProposalContract holds the data for a proposal transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 21], span: [194, 0, 202, 1], leadingComments: " VoteContract holds the data for a vote transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 22], span: [205, 0, 216, 1], leadingComments: " ConfigITOContract holds the data for a ConfigITO transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 23], span: [219, 0, 222, 1], leadingComments: " SetITOPrices holds the data for a ConfigITO transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 24], span: [225, 0, 227, 1], leadingComments: " PackInfo holds the pack list structure for the ITO contract\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 25], span: [230, 0, 233, 1], leadingComments: " PackItem hold the pack structure for the ITO contract\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 26], span: [236, 0, 245, 1], leadingComments: " BuyContract holds the data for a buy transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 27], span: [248, 0, 260, 1], leadingComments: " SellContract holds the data for a sell transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 28], span: [263, 0, 265, 1], leadingComments: " CancelMarketOrderContract holds the data for a cancel market transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 29], span: [268, 0, 272, 1], leadingComments: " CreateMarketplaceContract holds the data for a create marketplace transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 30], span: [275, 0, 280, 1], leadingComments: " ConfigMarketplaceContract holds the data for a config marketplace transaction\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 31], span: [283, 0, 286, 1], leadingComments: " TODO: Reuse from account\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 33], span: [301, 0, 303, 1], leadingComments: " UpdateAccountPermissionContract holds the data for update account permission transaction\n", trailingComments: "", leadingDetachedComments: [] }] }, syntax: "proto3" }), references: { ".proto.TransferContract": TransferContract, ".proto.CreateAssetContract": CreateAssetContract, ".proto.CreateAssetContract.EnumAssetType": CreateAssetContract_EnumAssetType, ".proto.CreateAssetContract.URIsEntry": CreateAssetContract_URIsEntry, ".proto.PropertiesInfo": PropertiesInfo, ".proto.AttributesInfo": AttributesInfo, ".proto.StakingInfo": StakingInfo, ".proto.StakingInfo.InterestType": StakingInfo_InterestType, ".proto.RolesInfo": RolesInfo, ".proto.RoyaltiesInfo": RoyaltiesInfo, ".proto.RoyaltyInfo": RoyaltyInfo, ".proto.AssetTriggerContract": AssetTriggerContract, ".proto.AssetTriggerContract.EnumTriggerType": AssetTriggerContract_EnumTriggerType, ".proto.AssetTriggerContract.URIsEntry": AssetTriggerContract_URIsEntry, ".proto.ValidatorConfig": ValidatorConfig, ".proto.ValidatorConfig.URIsEntry": ValidatorConfig_URIsEntry, ".proto.CreateValidatorContract": CreateValidatorContract, ".proto.ValidatorConfigContract": ValidatorConfigContract, ".proto.FreezeContract": FreezeContract, ".proto.UnfreezeContract": UnfreezeContract, ".proto.DelegateContract": DelegateContract, ".proto.UndelegateContract": UndelegateContract, ".proto.WithdrawContract": WithdrawContract, ".proto.ClaimContract": ClaimContract, ".proto.ClaimContract.EnumClaimType": ClaimContract_EnumClaimType, ".proto.UnjailContract": UnjailContract, ".proto.SetAccountNameContract": SetAccountNameContract, ".proto.ProposalContract": ProposalContract, ".proto.ProposalContract.ParametersEntry": ProposalContract_ParametersEntry, ".proto.VoteContract": VoteContract, ".proto.VoteContract.EnumVoteType": VoteContract_EnumVoteType, ".proto.ConfigITOContract": ConfigITOContract, ".proto.ConfigITOContract.EnumITOStatus": ConfigITOContract_EnumITOStatus, ".proto.ConfigITOContract.PackInfoEntry": ConfigITOContract_PackInfoEntry, ".proto.SetITOPricesContract": SetITOPricesContract, ".proto.SetITOPricesContract.PackInfoEntry": SetITOPricesContract_PackInfoEntry, ".proto.PackInfo": PackInfo, ".proto.PackItem": PackItem, ".proto.BuyContract": BuyContract, ".proto.BuyContract.EnumBuyType": BuyContract_EnumBuyType, ".proto.SellContract": SellContract, ".proto.SellContract.EnumMarketType": SellContract_EnumMarketType, ".proto.CancelMarketOrderContract": CancelMarketOrderContract, ".proto.CreateMarketplaceContract": CreateMarketplaceContract, ".proto.ConfigMarketplaceContract": ConfigMarketplaceContract, ".proto.AccKey": AccKey, ".proto.AccPermission": AccPermission, ".proto.AccPermission.AccPermissionType": AccPermission_AccPermissionType, ".proto.UpdateAccountPermissionContract": UpdateAccountPermissionContract }, dependencies: [] };
var globalThis$3 = (() => {
  if (void 0 !== globalThis$3)
    return globalThis$3;
  if ("undefined" != typeof self)
    return self;
  if ("undefined" != typeof window)
    return window;
  if ("undefined" != typeof global)
    return global;
  throw "Unable to locate global object";
})();
function bytesFromBase64$2(e2) {
  if (globalThis$3.Buffer)
    return Uint8Array.from(globalThis$3.Buffer.from(e2, "base64"));
  {
    const t = globalThis$3.atob(e2), n = new Uint8Array(t.length);
    for (let e3 = 0; e3 < t.length; ++e3)
      n[e3] = t.charCodeAt(e3);
    return n;
  }
}
function base64FromBytes$2(e2) {
  if (globalThis$3.Buffer)
    return globalThis$3.Buffer.from(e2).toString("base64");
  {
    const t = [];
    return e2.forEach((e3) => {
      t.push(String.fromCharCode(e3));
    }), globalThis$3.btoa(t.join(""));
  }
}
function longToNumber$1(e2) {
  if (e2.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$3.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return e2.toNumber();
}
function isObject(e2) {
  return "object" == typeof e2 && null !== e2;
}
function isSet$2(e2) {
  return null != e2;
}
minimal.util.Long !== long && (minimal.util.Long = long, minimal.configure());
var contracts = Object.freeze({ __proto__: null, protobufPackage: protobufPackage$1, get CreateAssetContract_EnumAssetType() {
  return CreateAssetContract_EnumAssetType;
}, createAssetContract_EnumAssetTypeFromJSON, createAssetContract_EnumAssetTypeToJSON, get StakingInfo_InterestType() {
  return StakingInfo_InterestType;
}, stakingInfo_InterestTypeFromJSON, stakingInfo_InterestTypeToJSON, get AssetTriggerContract_EnumTriggerType() {
  return AssetTriggerContract_EnumTriggerType;
}, assetTriggerContract_EnumTriggerTypeFromJSON, assetTriggerContract_EnumTriggerTypeToJSON, get ClaimContract_EnumClaimType() {
  return ClaimContract_EnumClaimType;
}, claimContract_EnumClaimTypeFromJSON, claimContract_EnumClaimTypeToJSON, get VoteContract_EnumVoteType() {
  return VoteContract_EnumVoteType;
}, voteContract_EnumVoteTypeFromJSON, voteContract_EnumVoteTypeToJSON, get ConfigITOContract_EnumITOStatus() {
  return ConfigITOContract_EnumITOStatus;
}, configITOContract_EnumITOStatusFromJSON, configITOContract_EnumITOStatusToJSON, get BuyContract_EnumBuyType() {
  return BuyContract_EnumBuyType;
}, buyContract_EnumBuyTypeFromJSON, buyContract_EnumBuyTypeToJSON, get SellContract_EnumMarketType() {
  return SellContract_EnumMarketType;
}, sellContract_EnumMarketTypeFromJSON, sellContract_EnumMarketTypeToJSON, get AccPermission_AccPermissionType() {
  return AccPermission_AccPermissionType;
}, accPermission_AccPermissionTypeFromJSON, accPermission_AccPermissionTypeToJSON, TransferContract, CreateAssetContract, CreateAssetContract_URIsEntry, PropertiesInfo, AttributesInfo, StakingInfo, RolesInfo, RoyaltiesInfo, RoyaltyInfo, AssetTriggerContract, AssetTriggerContract_URIsEntry, ValidatorConfig, ValidatorConfig_URIsEntry, CreateValidatorContract, ValidatorConfigContract, FreezeContract, UnfreezeContract, DelegateContract, UndelegateContract, WithdrawContract, ClaimContract, UnjailContract, SetAccountNameContract, ProposalContract, ProposalContract_ParametersEntry, VoteContract, ConfigITOContract, ConfigITOContract_PackInfoEntry, SetITOPricesContract, SetITOPricesContract_PackInfoEntry, PackInfo, PackItem, BuyContract, SellContract, CancelMarketOrderContract, CreateMarketplaceContract, ConfigMarketplaceContract, AccKey, AccPermission, UpdateAccountPermissionContract, protoMetadata: protoMetadata$1 });
var protobufPackage = "google.protobuf";
function createBaseAny() {
  return { type_url: "", value: new Uint8Array() };
}
var Any = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.type_url && "" !== e2.type_url && t.uint32(10).string(e2.type_url), void 0 !== e2.value && 0 !== e2.value.length && t.uint32(18).bytes(e2.value), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseAny();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.type_url = n.string();
        break;
      case 2:
        r.value = n.bytes();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ type_url: isSet$1(e2.type_url) ? String(e2.type_url) : "", value: isSet$1(e2.value) ? bytesFromBase64$1(e2.value) : new Uint8Array() }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.type_url && (t.type_url = e2.type_url), void 0 !== e2.value && (t.value = base64FromBytes$1(void 0 !== e2.value ? e2.value : new Uint8Array())), t;
}, fromPartial(e2) {
  var t, n;
  const o = createBaseAny();
  return o.type_url = null !== (t = e2.type_url) && void 0 !== t ? t : "", o.value = null !== (n = e2.value) && void 0 !== n ? n : new Uint8Array(), o;
} };
var protoMetadata = { fileDescriptor: dist.FileDescriptorProto.fromPartial({ name: "google/protobuf/any.proto", package: "google.protobuf", dependency: [], publicDependency: [], weakDependency: [], messageType: [{ name: "Any", field: [{ name: "type_url", number: 1, label: 1, type: 9, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "type_url", options: void 0, proto3Optional: false }, { name: "value", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "value", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }], enumType: [], service: [], extension: [], options: { javaPackage: "com.google.protobuf", javaOuterClassname: "AnyProto", javaMultipleFiles: true, javaGenerateEqualsAndHash: false, javaStringCheckUtf8: false, optimizeFor: 1, goPackage: "google.golang.org/protobuf/types/known/anypb", ccGenericServices: false, javaGenericServices: false, pyGenericServices: false, phpGenericServices: false, deprecated: false, ccEnableArenas: false, objcClassPrefix: "GPB", csharpNamespace: "Google.Protobuf.WellKnownTypes", swiftPrefix: "", phpClassPrefix: "", phpNamespace: "", phpMetadataNamespace: "", rubyPackage: "", uninterpretedOption: [] }, sourceCodeInfo: { location: [{ path: [4, 0], span: [124, 0, 157, 1], leadingComments: ' `Any` contains an arbitrary serialized protocol buffer message along with a\n URL that describes the type of the serialized message.\n\n Protobuf library provides support to pack/unpack Any values in the form\n of utility functions or additional generated methods of the Any type.\n\n Example 1: Pack and unpack a message in C++.\n\n     Foo foo = ...;\n     Any any;\n     any.PackFrom(foo);\n     ...\n     if (any.UnpackTo(&foo)) {\n       ...\n     }\n\n Example 2: Pack and unpack a message in Java.\n\n     Foo foo = ...;\n     Any any = Any.pack(foo);\n     ...\n     if (any.is(Foo.class)) {\n       foo = any.unpack(Foo.class);\n     }\n\n  Example 3: Pack and unpack a message in Python.\n\n     foo = Foo(...)\n     any = Any()\n     any.Pack(foo)\n     ...\n     if any.Is(Foo.DESCRIPTOR):\n       any.Unpack(foo)\n       ...\n\n  Example 4: Pack and unpack a message in Go\n\n      foo := &pb.Foo{...}\n      any, err := anypb.New(foo)\n      if err != nil {\n        ...\n      }\n      ...\n      foo := &pb.Foo{}\n      if err := any.UnmarshalTo(foo); err != nil {\n        ...\n      }\n\n The pack methods provided by protobuf library will by default use\n \'type.googleapis.com/full.type.name\' as the type URL and the unpack\n methods only use the fully qualified type name after the last \'/\'\n in the type URL, for example "foo.bar.com/x/y.z" will yield type\n name "y.z".\n\n\n JSON\n ====\n The JSON representation of an `Any` value uses the regular\n representation of the deserialized, embedded message, with an\n additional field `@type` which contains the type URL. Example:\n\n     package google.profile;\n     message Person {\n       string first_name = 1;\n       string last_name = 2;\n     }\n\n     {\n       "@type": "type.googleapis.com/google.profile.Person",\n       "firstName": <string>,\n       "lastName": <string>\n     }\n\n If the embedded message type is well-known and has a custom JSON\n representation, that representation will be embedded adding a field\n `value` which holds the custom JSON in addition to the `@type`\n field. Example (for message [google.protobuf.Duration][]):\n\n     {\n       "@type": "type.googleapis.com/google.protobuf.Duration",\n       "value": "1.212s"\n     }\n\n', trailingComments: "", leadingDetachedComments: [] }, { path: [4, 0, 2, 0], span: [153, 2, 22], leadingComments: ' A URL/resource name that uniquely identifies the type of the serialized\n protocol buffer message. This string must contain at least\n one "/" character. The last segment of the URL\'s path must represent\n the fully qualified name of the type (as in\n `path/google.protobuf.Duration`). The name should be in a canonical form\n (e.g., leading "." is not accepted).\n\n In practice, teams usually precompile into the binary all types that they\n expect it to use in the context of Any. However, for URLs which use the\n scheme `http`, `https`, or no scheme, one can optionally set up a type\n server that maps type URLs to message definitions as follows:\n\n * If no scheme is provided, `https` is assumed.\n * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   value in binary format, or produce an error.\n * Applications are allowed to cache lookup results based on the\n   URL, or have them precompiled into a binary to avoid any\n   lookup. Therefore, binary compatibility needs to be preserved\n   on changes to types. (Use versioned type names to manage\n   breaking changes.)\n\n Note: this functionality is not currently available in the official\n protobuf release, and it is not used for type URLs beginning with\n type.googleapis.com.\n\n Schemes other than `http`, `https` (or the empty scheme) might be\n used with implementation specific semantics.\n\n', trailingComments: "", leadingDetachedComments: [] }, { path: [4, 0, 2, 1], span: [156, 2, 18], leadingComments: " Must be a valid serialized protocol buffer of the above specified type.\n", trailingComments: "", leadingDetachedComments: [] }] }, syntax: "proto3" }), references: { ".google.protobuf.Any": Any }, dependencies: [] };
var globalThis$2 = (() => {
  if (void 0 !== globalThis$2)
    return globalThis$2;
  if ("undefined" != typeof self)
    return self;
  if ("undefined" != typeof window)
    return window;
  if ("undefined" != typeof global)
    return global;
  throw "Unable to locate global object";
})();
function bytesFromBase64$1(e2) {
  if (globalThis$2.Buffer)
    return Uint8Array.from(globalThis$2.Buffer.from(e2, "base64"));
  {
    const t = globalThis$2.atob(e2), n = new Uint8Array(t.length);
    for (let e3 = 0; e3 < t.length; ++e3)
      n[e3] = t.charCodeAt(e3);
    return n;
  }
}
function base64FromBytes$1(e2) {
  if (globalThis$2.Buffer)
    return globalThis$2.Buffer.from(e2).toString("base64");
  {
    const t = [];
    return e2.forEach((e3) => {
      t.push(String.fromCharCode(e3));
    }), globalThis$2.btoa(t.join(""));
  }
}
function isSet$1(e2) {
  return null != e2;
}
var any = Object.freeze({ __proto__: null, protobufPackage, Any, protoMetadata });
var TXContract_ContractType;
var Transaction_TXResult;
var Transaction_TXResultCode;
function tXContract_ContractTypeFromJSON(e2) {
  switch (e2) {
    case 0:
    case "TransferContractType":
      return TXContract_ContractType.TransferContractType;
    case 1:
    case "CreateAssetContractType":
      return TXContract_ContractType.CreateAssetContractType;
    case 2:
    case "CreateValidatorContractType":
      return TXContract_ContractType.CreateValidatorContractType;
    case 3:
    case "ValidatorConfigContractType":
      return TXContract_ContractType.ValidatorConfigContractType;
    case 4:
    case "FreezeContractType":
      return TXContract_ContractType.FreezeContractType;
    case 5:
    case "UnfreezeContractType":
      return TXContract_ContractType.UnfreezeContractType;
    case 6:
    case "DelegateContractType":
      return TXContract_ContractType.DelegateContractType;
    case 7:
    case "UndelegateContractType":
      return TXContract_ContractType.UndelegateContractType;
    case 8:
    case "WithdrawContractType":
      return TXContract_ContractType.WithdrawContractType;
    case 9:
    case "ClaimContractType":
      return TXContract_ContractType.ClaimContractType;
    case 10:
    case "UnjailContractType":
      return TXContract_ContractType.UnjailContractType;
    case 11:
    case "AssetTriggerContractType":
      return TXContract_ContractType.AssetTriggerContractType;
    case 12:
    case "SetAccountNameContractType":
      return TXContract_ContractType.SetAccountNameContractType;
    case 13:
    case "ProposalContractType":
      return TXContract_ContractType.ProposalContractType;
    case 14:
    case "VoteContractType":
      return TXContract_ContractType.VoteContractType;
    case 15:
    case "ConfigITOContractType":
      return TXContract_ContractType.ConfigITOContractType;
    case 16:
    case "SetITOPricesContractType":
      return TXContract_ContractType.SetITOPricesContractType;
    case 17:
    case "BuyContractType":
      return TXContract_ContractType.BuyContractType;
    case 18:
    case "SellContractType":
      return TXContract_ContractType.SellContractType;
    case 19:
    case "CancelMarketOrderContractType":
      return TXContract_ContractType.CancelMarketOrderContractType;
    case 20:
    case "CreateMarketplaceContractType":
      return TXContract_ContractType.CreateMarketplaceContractType;
    case 21:
    case "ConfigMarketplaceContractType":
      return TXContract_ContractType.ConfigMarketplaceContractType;
    case 22:
    case "UpdateAccountPermissionContractType":
      return TXContract_ContractType.UpdateAccountPermissionContractType;
    default:
      return TXContract_ContractType.UNRECOGNIZED;
  }
}
function tXContract_ContractTypeToJSON(e2) {
  switch (e2) {
    case TXContract_ContractType.TransferContractType:
      return 0;
    case TXContract_ContractType.CreateAssetContractType:
      return 1;
    case TXContract_ContractType.CreateValidatorContractType:
      return 2;
    case TXContract_ContractType.ValidatorConfigContractType:
      return 3;
    case TXContract_ContractType.FreezeContractType:
      return 4;
    case TXContract_ContractType.UnfreezeContractType:
      return 5;
    case TXContract_ContractType.DelegateContractType:
      return 6;
    case TXContract_ContractType.UndelegateContractType:
      return 7;
    case TXContract_ContractType.WithdrawContractType:
      return 8;
    case TXContract_ContractType.ClaimContractType:
      return 9;
    case TXContract_ContractType.UnjailContractType:
      return 10;
    case TXContract_ContractType.AssetTriggerContractType:
      return 11;
    case TXContract_ContractType.SetAccountNameContractType:
      return 12;
    case TXContract_ContractType.ProposalContractType:
      return 13;
    case TXContract_ContractType.VoteContractType:
      return 14;
    case TXContract_ContractType.ConfigITOContractType:
      return 15;
    case TXContract_ContractType.SetITOPricesContractType:
      return 16;
    case TXContract_ContractType.BuyContractType:
      return 17;
    case TXContract_ContractType.SellContractType:
      return 18;
    case TXContract_ContractType.CancelMarketOrderContractType:
      return 19;
    case TXContract_ContractType.CreateMarketplaceContractType:
      return 20;
    case TXContract_ContractType.ConfigMarketplaceContractType:
      return 21;
    case TXContract_ContractType.UpdateAccountPermissionContractType:
      return 22;
    case TXContract_ContractType.UNRECOGNIZED:
    default:
      return -1;
  }
}
function transaction_TXResultFromJSON(e2) {
  switch (e2) {
    case 0:
    case "SUCCESS":
      return Transaction_TXResult.SUCCESS;
    case 1:
    case "FAILED":
      return Transaction_TXResult.FAILED;
    default:
      return Transaction_TXResult.UNRECOGNIZED;
  }
}
function transaction_TXResultToJSON(e2) {
  switch (e2) {
    case Transaction_TXResult.SUCCESS:
      return 0;
    case Transaction_TXResult.FAILED:
      return 1;
    case Transaction_TXResult.UNRECOGNIZED:
    default:
      return -1;
  }
}
function transaction_TXResultCodeFromJSON(e2) {
  switch (e2) {
    case 0:
    case "Ok":
      return Transaction_TXResultCode.Ok;
    case 1:
    case "OutOfFunds":
      return Transaction_TXResultCode.OutOfFunds;
    case 2:
    case "AccountError":
      return Transaction_TXResultCode.AccountError;
    case 3:
    case "AssetError":
      return Transaction_TXResultCode.AssetError;
    case 4:
    case "ContractInvalid":
      return Transaction_TXResultCode.ContractInvalid;
    case 5:
    case "ContractNotFound":
      return Transaction_TXResultCode.ContractNotFound;
    case 6:
    case "FeeInvalid":
      return Transaction_TXResultCode.FeeInvalid;
    case 7:
    case "ParameterInvalid":
      return Transaction_TXResultCode.ParameterInvalid;
    case 8:
    case "APRInvalid":
      return Transaction_TXResultCode.APRInvalid;
    case 9:
    case "AssetIDInvalid":
      return Transaction_TXResultCode.AssetIDInvalid;
    case 10:
    case "AssetTypeInvalid":
      return Transaction_TXResultCode.AssetTypeInvalid;
    case 11:
    case "AssetCantBeMinted":
      return Transaction_TXResultCode.AssetCantBeMinted;
    case 12:
    case "AssetCantBeBurned":
      return Transaction_TXResultCode.AssetCantBeBurned;
    case 13:
    case "AssetCantBePaused":
      return Transaction_TXResultCode.AssetCantBePaused;
    case 14:
    case "AssetCantBeDelegated":
      return Transaction_TXResultCode.AssetCantBeDelegated;
    case 15:
    case "AssetOwnerCantBeChanged":
      return Transaction_TXResultCode.AssetOwnerCantBeChanged;
    case 16:
    case "AccountNotOwner":
      return Transaction_TXResultCode.AccountNotOwner;
    case 17:
    case "CommissionTooHigh":
      return Transaction_TXResultCode.CommissionTooHigh;
    case 18:
    case "DelegationAmountInvalid":
      return Transaction_TXResultCode.DelegationAmountInvalid;
    case 19:
    case "ProposalNotActive":
      return Transaction_TXResultCode.ProposalNotActive;
    case 20:
    case "ValueInvalid":
      return Transaction_TXResultCode.ValueInvalid;
    case 21:
    case "AmountInvalid":
      return Transaction_TXResultCode.AmountInvalid;
    case 22:
    case "BucketIDInvalid":
      return Transaction_TXResultCode.BucketIDInvalid;
    case 23:
    case "KeyConflict":
      return Transaction_TXResultCode.KeyConflict;
    case 24:
    case "MaxDelegationAmount":
      return Transaction_TXResultCode.MaxDelegationAmount;
    case 25:
    case "InvalidPeerKey":
      return Transaction_TXResultCode.InvalidPeerKey;
    case 26:
    case "MinKFIStakedUnreached":
      return Transaction_TXResultCode.MinKFIStakedUnreached;
    case 27:
    case "MaxSupplyExeeced":
      return Transaction_TXResultCode.MaxSupplyExeeced;
    case 28:
    case "SaveAccountError":
      return Transaction_TXResultCode.SaveAccountError;
    case 29:
    case "LoadAccountError":
      return Transaction_TXResultCode.LoadAccountError;
    case 30:
    case "SameAccountError":
      return Transaction_TXResultCode.SameAccountError;
    case 31:
    case "AssetPaused":
      return Transaction_TXResultCode.AssetPaused;
    case 32:
    case "DeletegateError":
      return Transaction_TXResultCode.DeletegateError;
    case 33:
    case "WithdrawNotAvailable":
      return Transaction_TXResultCode.WithdrawNotAvailable;
    case 34:
    case "ErrOverflow":
      return Transaction_TXResultCode.ErrOverflow;
    case 35:
    case "SetStakingErr":
      return Transaction_TXResultCode.SetStakingErr;
    case 36:
    case "SetMarketOrderErr":
      return Transaction_TXResultCode.SetMarketOrderErr;
    case 37:
    case "BalanceError":
      return Transaction_TXResultCode.BalanceError;
    case 38:
    case "KAPPError":
      return Transaction_TXResultCode.KAPPError;
    case 39:
    case "UnfreezeError":
      return Transaction_TXResultCode.UnfreezeError;
    case 40:
    case "UndeletegateError":
      return Transaction_TXResultCode.UndeletegateError;
    case 41:
    case "WithdrawError":
      return Transaction_TXResultCode.WithdrawError;
    case 42:
    case "ClaimError":
      return Transaction_TXResultCode.ClaimError;
    case 43:
    case "BucketsExceded":
      return Transaction_TXResultCode.BucketsExceded;
    case 44:
    case "AssetCantBeWiped":
      return Transaction_TXResultCode.AssetCantBeWiped;
    case 45:
    case "AssetCantAddRoles":
      return Transaction_TXResultCode.AssetCantAddRoles;
    case 46:
    case "FreezeError":
      return Transaction_TXResultCode.FreezeError;
    case 99:
    case "Fail":
      return Transaction_TXResultCode.Fail;
    default:
      return Transaction_TXResultCode.UNRECOGNIZED;
  }
}
function transaction_TXResultCodeToJSON(e2) {
  switch (e2) {
    case Transaction_TXResultCode.Ok:
      return 0;
    case Transaction_TXResultCode.OutOfFunds:
      return 1;
    case Transaction_TXResultCode.AccountError:
      return 2;
    case Transaction_TXResultCode.AssetError:
      return 3;
    case Transaction_TXResultCode.ContractInvalid:
      return 4;
    case Transaction_TXResultCode.ContractNotFound:
      return 5;
    case Transaction_TXResultCode.FeeInvalid:
      return 6;
    case Transaction_TXResultCode.ParameterInvalid:
      return 7;
    case Transaction_TXResultCode.APRInvalid:
      return 8;
    case Transaction_TXResultCode.AssetIDInvalid:
      return 9;
    case Transaction_TXResultCode.AssetTypeInvalid:
      return 10;
    case Transaction_TXResultCode.AssetCantBeMinted:
      return 11;
    case Transaction_TXResultCode.AssetCantBeBurned:
      return 12;
    case Transaction_TXResultCode.AssetCantBePaused:
      return 13;
    case Transaction_TXResultCode.AssetCantBeDelegated:
      return 14;
    case Transaction_TXResultCode.AssetOwnerCantBeChanged:
      return 15;
    case Transaction_TXResultCode.AccountNotOwner:
      return 16;
    case Transaction_TXResultCode.CommissionTooHigh:
      return 17;
    case Transaction_TXResultCode.DelegationAmountInvalid:
      return 18;
    case Transaction_TXResultCode.ProposalNotActive:
      return 19;
    case Transaction_TXResultCode.ValueInvalid:
      return 20;
    case Transaction_TXResultCode.AmountInvalid:
      return 21;
    case Transaction_TXResultCode.BucketIDInvalid:
      return 22;
    case Transaction_TXResultCode.KeyConflict:
      return 23;
    case Transaction_TXResultCode.MaxDelegationAmount:
      return 24;
    case Transaction_TXResultCode.InvalidPeerKey:
      return 25;
    case Transaction_TXResultCode.MinKFIStakedUnreached:
      return 26;
    case Transaction_TXResultCode.MaxSupplyExeeced:
      return 27;
    case Transaction_TXResultCode.SaveAccountError:
      return 28;
    case Transaction_TXResultCode.LoadAccountError:
      return 29;
    case Transaction_TXResultCode.SameAccountError:
      return 30;
    case Transaction_TXResultCode.AssetPaused:
      return 31;
    case Transaction_TXResultCode.DeletegateError:
      return 32;
    case Transaction_TXResultCode.WithdrawNotAvailable:
      return 33;
    case Transaction_TXResultCode.ErrOverflow:
      return 34;
    case Transaction_TXResultCode.SetStakingErr:
      return 35;
    case Transaction_TXResultCode.SetMarketOrderErr:
      return 36;
    case Transaction_TXResultCode.BalanceError:
      return 37;
    case Transaction_TXResultCode.KAPPError:
      return 38;
    case Transaction_TXResultCode.UnfreezeError:
      return 39;
    case Transaction_TXResultCode.UndeletegateError:
      return 40;
    case Transaction_TXResultCode.WithdrawError:
      return 41;
    case Transaction_TXResultCode.ClaimError:
      return 42;
    case Transaction_TXResultCode.BucketsExceded:
      return 43;
    case Transaction_TXResultCode.AssetCantBeWiped:
      return 44;
    case Transaction_TXResultCode.AssetCantAddRoles:
      return 45;
    case Transaction_TXResultCode.FreezeError:
      return 46;
    case Transaction_TXResultCode.Fail:
      return 99;
    case Transaction_TXResultCode.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseTXContract() {
  return { Type: 0, Parameter: void 0 };
}
!function(e2) {
  e2[e2.TransferContractType = 0] = "TransferContractType", e2[e2.CreateAssetContractType = 1] = "CreateAssetContractType", e2[e2.CreateValidatorContractType = 2] = "CreateValidatorContractType", e2[e2.ValidatorConfigContractType = 3] = "ValidatorConfigContractType", e2[e2.FreezeContractType = 4] = "FreezeContractType", e2[e2.UnfreezeContractType = 5] = "UnfreezeContractType", e2[e2.DelegateContractType = 6] = "DelegateContractType", e2[e2.UndelegateContractType = 7] = "UndelegateContractType", e2[e2.WithdrawContractType = 8] = "WithdrawContractType", e2[e2.ClaimContractType = 9] = "ClaimContractType", e2[e2.UnjailContractType = 10] = "UnjailContractType", e2[e2.AssetTriggerContractType = 11] = "AssetTriggerContractType", e2[e2.SetAccountNameContractType = 12] = "SetAccountNameContractType", e2[e2.ProposalContractType = 13] = "ProposalContractType", e2[e2.VoteContractType = 14] = "VoteContractType", e2[e2.ConfigITOContractType = 15] = "ConfigITOContractType", e2[e2.SetITOPricesContractType = 16] = "SetITOPricesContractType", e2[e2.BuyContractType = 17] = "BuyContractType", e2[e2.SellContractType = 18] = "SellContractType", e2[e2.CancelMarketOrderContractType = 19] = "CancelMarketOrderContractType", e2[e2.CreateMarketplaceContractType = 20] = "CreateMarketplaceContractType", e2[e2.ConfigMarketplaceContractType = 21] = "ConfigMarketplaceContractType", e2[e2.UpdateAccountPermissionContractType = 22] = "UpdateAccountPermissionContractType", e2[e2.UNRECOGNIZED = -1] = "UNRECOGNIZED";
}(TXContract_ContractType || (TXContract_ContractType = {})), function(e2) {
  e2[e2.SUCCESS = 0] = "SUCCESS", e2[e2.FAILED = 1] = "FAILED", e2[e2.UNRECOGNIZED = -1] = "UNRECOGNIZED";
}(Transaction_TXResult || (Transaction_TXResult = {})), function(e2) {
  e2[e2.Ok = 0] = "Ok", e2[e2.OutOfFunds = 1] = "OutOfFunds", e2[e2.AccountError = 2] = "AccountError", e2[e2.AssetError = 3] = "AssetError", e2[e2.ContractInvalid = 4] = "ContractInvalid", e2[e2.ContractNotFound = 5] = "ContractNotFound", e2[e2.FeeInvalid = 6] = "FeeInvalid", e2[e2.ParameterInvalid = 7] = "ParameterInvalid", e2[e2.APRInvalid = 8] = "APRInvalid", e2[e2.AssetIDInvalid = 9] = "AssetIDInvalid", e2[e2.AssetTypeInvalid = 10] = "AssetTypeInvalid", e2[e2.AssetCantBeMinted = 11] = "AssetCantBeMinted", e2[e2.AssetCantBeBurned = 12] = "AssetCantBeBurned", e2[e2.AssetCantBePaused = 13] = "AssetCantBePaused", e2[e2.AssetCantBeDelegated = 14] = "AssetCantBeDelegated", e2[e2.AssetOwnerCantBeChanged = 15] = "AssetOwnerCantBeChanged", e2[e2.AccountNotOwner = 16] = "AccountNotOwner", e2[e2.CommissionTooHigh = 17] = "CommissionTooHigh", e2[e2.DelegationAmountInvalid = 18] = "DelegationAmountInvalid", e2[e2.ProposalNotActive = 19] = "ProposalNotActive", e2[e2.ValueInvalid = 20] = "ValueInvalid", e2[e2.AmountInvalid = 21] = "AmountInvalid", e2[e2.BucketIDInvalid = 22] = "BucketIDInvalid", e2[e2.KeyConflict = 23] = "KeyConflict", e2[e2.MaxDelegationAmount = 24] = "MaxDelegationAmount", e2[e2.InvalidPeerKey = 25] = "InvalidPeerKey", e2[e2.MinKFIStakedUnreached = 26] = "MinKFIStakedUnreached", e2[e2.MaxSupplyExeeced = 27] = "MaxSupplyExeeced", e2[e2.SaveAccountError = 28] = "SaveAccountError", e2[e2.LoadAccountError = 29] = "LoadAccountError", e2[e2.SameAccountError = 30] = "SameAccountError", e2[e2.AssetPaused = 31] = "AssetPaused", e2[e2.DeletegateError = 32] = "DeletegateError", e2[e2.WithdrawNotAvailable = 33] = "WithdrawNotAvailable", e2[e2.ErrOverflow = 34] = "ErrOverflow", e2[e2.SetStakingErr = 35] = "SetStakingErr", e2[e2.SetMarketOrderErr = 36] = "SetMarketOrderErr", e2[e2.BalanceError = 37] = "BalanceError", e2[e2.KAPPError = 38] = "KAPPError", e2[e2.UnfreezeError = 39] = "UnfreezeError", e2[e2.UndeletegateError = 40] = "UndeletegateError", e2[e2.WithdrawError = 41] = "WithdrawError", e2[e2.ClaimError = 42] = "ClaimError", e2[e2.BucketsExceded = 43] = "BucketsExceded", e2[e2.AssetCantBeWiped = 44] = "AssetCantBeWiped", e2[e2.AssetCantAddRoles = 45] = "AssetCantAddRoles", e2[e2.FreezeError = 46] = "FreezeError", e2[e2.Fail = 99] = "Fail", e2[e2.UNRECOGNIZED = -1] = "UNRECOGNIZED";
}(Transaction_TXResultCode || (Transaction_TXResultCode = {}));
var TXContract = { encode: (e2, t = minimal.Writer.create()) => (void 0 !== e2.Type && 0 !== e2.Type && t.uint32(8).int32(e2.Type), void 0 !== e2.Parameter && Any.encode(e2.Parameter, t.uint32(18).fork()).ldelim(), t), decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseTXContract();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.Type = n.int32();
        break;
      case 2:
        r.Parameter = Any.decode(n, n.uint32());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ Type: isSet(e2.Type) ? tXContract_ContractTypeFromJSON(e2.Type) : 0, Parameter: isSet(e2.Parameter) ? Any.fromJSON(e2.Parameter) : void 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.Type && (t.Type = tXContract_ContractTypeToJSON(e2.Type)), void 0 !== e2.Parameter && (t.Parameter = e2.Parameter ? Any.toJSON(e2.Parameter) : void 0), t;
}, fromPartial(e2) {
  var t;
  const n = createBaseTXContract();
  return n.Type = null !== (t = e2.Type) && void 0 !== t ? t : 0, n.Parameter = void 0 !== e2.Parameter && null !== e2.Parameter ? Any.fromPartial(e2.Parameter) : void 0, n;
} };
function createBaseTransaction() {
  return { RawData: void 0, Signature: [], Result: 0, ResultCode: 0, Receipts: [], Block: 0 };
}
var Transaction$1 = { encode(e2, t = minimal.Writer.create()) {
  if (void 0 !== e2.RawData && Transaction_Raw.encode(e2.RawData, t.uint32(10).fork()).ldelim(), void 0 !== e2.Signature && 0 !== e2.Signature.length)
    for (const n of e2.Signature)
      t.uint32(18).bytes(n);
  if (void 0 !== e2.Result && 0 !== e2.Result && t.uint32(24).int32(e2.Result), void 0 !== e2.ResultCode && 0 !== e2.ResultCode && t.uint32(32).int32(e2.ResultCode), void 0 !== e2.Receipts && 0 !== e2.Receipts.length)
    for (const n of e2.Receipts)
      Transaction_Receipt.encode(n, t.uint32(42).fork()).ldelim();
  return void 0 !== e2.Block && 0 !== e2.Block && t.uint32(48).uint64(e2.Block), t;
}, decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseTransaction();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.RawData = Transaction_Raw.decode(n, n.uint32());
        break;
      case 2:
        r.Signature.push(n.bytes());
        break;
      case 3:
        r.Result = n.int32();
        break;
      case 4:
        r.ResultCode = n.int32();
        break;
      case 5:
        r.Receipts.push(Transaction_Receipt.decode(n, n.uint32()));
        break;
      case 6:
        r.Block = longToNumber(n.uint64());
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ RawData: isSet(e2.RawData) ? Transaction_Raw.fromJSON(e2.RawData) : void 0, Signature: Array.isArray(null == e2 ? void 0 : e2.Signature) ? e2.Signature.map((e3) => bytesFromBase64(e3)) : [], Result: isSet(e2.Result) ? transaction_TXResultFromJSON(e2.Result) : 0, ResultCode: isSet(e2.ResultCode) ? transaction_TXResultCodeFromJSON(e2.ResultCode) : 0, Receipts: Array.isArray(null == e2 ? void 0 : e2.Receipts) ? e2.Receipts.map((e3) => Transaction_Receipt.fromJSON(e3)) : [], Block: isSet(e2.Block) ? Number(e2.Block) : 0 }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.RawData && (t.RawData = e2.RawData ? Transaction_Raw.toJSON(e2.RawData) : void 0), e2.Signature ? t.Signature = e2.Signature.map((e3) => base64FromBytes(void 0 !== e3 ? e3 : new Uint8Array())) : t.Signature = [], void 0 !== e2.Result && (t.Result = transaction_TXResultToJSON(e2.Result)), void 0 !== e2.ResultCode && (t.ResultCode = transaction_TXResultCodeToJSON(e2.ResultCode)), e2.Receipts ? t.Receipts = e2.Receipts.map((e3) => e3 ? Transaction_Receipt.toJSON(e3) : void 0) : t.Receipts = [], void 0 !== e2.Block && (t.Block = Math.round(e2.Block)), t;
}, fromPartial(e2) {
  var t, n, o, r, a;
  const i = createBaseTransaction();
  return i.RawData = void 0 !== e2.RawData && null !== e2.RawData ? Transaction_Raw.fromPartial(e2.RawData) : void 0, i.Signature = (null === (t = e2.Signature) || void 0 === t ? void 0 : t.map((e3) => e3)) || [], i.Result = null !== (n = e2.Result) && void 0 !== n ? n : 0, i.ResultCode = null !== (o = e2.ResultCode) && void 0 !== o ? o : 0, i.Receipts = (null === (r = e2.Receipts) || void 0 === r ? void 0 : r.map((e3) => Transaction_Receipt.fromPartial(e3))) || [], i.Block = null !== (a = e2.Block) && void 0 !== a ? a : 0, i;
} };
function createBaseTransaction_Raw() {
  return { Nonce: 0, Sender: new Uint8Array(), Contract: [], PermissionID: 0, Data: [], KAppFee: 0, BandwidthFee: 0, Version: 0, ChainID: new Uint8Array() };
}
var Transaction_Raw = { encode(e2, t = minimal.Writer.create()) {
  if (void 0 !== e2.Nonce && 0 !== e2.Nonce && t.uint32(8).uint64(e2.Nonce), void 0 !== e2.Sender && 0 !== e2.Sender.length && t.uint32(18).bytes(e2.Sender), void 0 !== e2.Contract && 0 !== e2.Contract.length)
    for (const n of e2.Contract)
      TXContract.encode(n, t.uint32(50).fork()).ldelim();
  if (void 0 !== e2.PermissionID && 0 !== e2.PermissionID && t.uint32(56).int32(e2.PermissionID), void 0 !== e2.Data && 0 !== e2.Data.length)
    for (const n of e2.Data)
      t.uint32(82).bytes(n);
  return void 0 !== e2.KAppFee && 0 !== e2.KAppFee && t.uint32(104).int64(e2.KAppFee), void 0 !== e2.BandwidthFee && 0 !== e2.BandwidthFee && t.uint32(112).int64(e2.BandwidthFee), void 0 !== e2.Version && 0 !== e2.Version && t.uint32(120).uint32(e2.Version), void 0 !== e2.ChainID && 0 !== e2.ChainID.length && t.uint32(130).bytes(e2.ChainID), t;
}, decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseTransaction_Raw();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    switch (e3 >>> 3) {
      case 1:
        r.Nonce = longToNumber(n.uint64());
        break;
      case 2:
        r.Sender = n.bytes();
        break;
      case 6:
        r.Contract.push(TXContract.decode(n, n.uint32()));
        break;
      case 7:
        r.PermissionID = n.int32();
        break;
      case 10:
        r.Data.push(n.bytes());
        break;
      case 13:
        r.KAppFee = longToNumber(n.int64());
        break;
      case 14:
        r.BandwidthFee = longToNumber(n.int64());
        break;
      case 15:
        r.Version = n.uint32();
        break;
      case 16:
        r.ChainID = n.bytes();
        break;
      default:
        n.skipType(7 & e3);
    }
  }
  return r;
}, fromJSON: (e2) => ({ Nonce: isSet(e2.Nonce) ? Number(e2.Nonce) : 0, Sender: isSet(e2.Sender) ? bytesFromBase64(e2.Sender) : new Uint8Array(), Contract: Array.isArray(null == e2 ? void 0 : e2.Contract) ? e2.Contract.map((e3) => TXContract.fromJSON(e3)) : [], PermissionID: isSet(e2.PermissionID) ? Number(e2.PermissionID) : 0, Data: Array.isArray(null == e2 ? void 0 : e2.Data) ? e2.Data.map((e3) => bytesFromBase64(e3)) : [], KAppFee: isSet(e2.KAppFee) ? Number(e2.KAppFee) : 0, BandwidthFee: isSet(e2.BandwidthFee) ? Number(e2.BandwidthFee) : 0, Version: isSet(e2.Version) ? Number(e2.Version) : 0, ChainID: isSet(e2.ChainID) ? bytesFromBase64(e2.ChainID) : new Uint8Array() }), toJSON(e2) {
  const t = {};
  return void 0 !== e2.Nonce && (t.Nonce = Math.round(e2.Nonce)), void 0 !== e2.Sender && (t.Sender = base64FromBytes(void 0 !== e2.Sender ? e2.Sender : new Uint8Array())), e2.Contract ? t.Contract = e2.Contract.map((e3) => e3 ? TXContract.toJSON(e3) : void 0) : t.Contract = [], void 0 !== e2.PermissionID && (t.PermissionID = Math.round(e2.PermissionID)), e2.Data ? t.Data = e2.Data.map((e3) => base64FromBytes(void 0 !== e3 ? e3 : new Uint8Array())) : t.Data = [], void 0 !== e2.KAppFee && (t.KAppFee = Math.round(e2.KAppFee)), void 0 !== e2.BandwidthFee && (t.BandwidthFee = Math.round(e2.BandwidthFee)), void 0 !== e2.Version && (t.Version = Math.round(e2.Version)), void 0 !== e2.ChainID && (t.ChainID = base64FromBytes(void 0 !== e2.ChainID ? e2.ChainID : new Uint8Array())), t;
}, fromPartial(e2) {
  var t, n, o, r, a, i, s, c, d;
  const l = createBaseTransaction_Raw();
  return l.Nonce = null !== (t = e2.Nonce) && void 0 !== t ? t : 0, l.Sender = null !== (n = e2.Sender) && void 0 !== n ? n : new Uint8Array(), l.Contract = (null === (o = e2.Contract) || void 0 === o ? void 0 : o.map((e3) => TXContract.fromPartial(e3))) || [], l.PermissionID = null !== (r = e2.PermissionID) && void 0 !== r ? r : 0, l.Data = (null === (a = e2.Data) || void 0 === a ? void 0 : a.map((e3) => e3)) || [], l.KAppFee = null !== (i = e2.KAppFee) && void 0 !== i ? i : 0, l.BandwidthFee = null !== (s = e2.BandwidthFee) && void 0 !== s ? s : 0, l.Version = null !== (c = e2.Version) && void 0 !== c ? c : 0, l.ChainID = null !== (d = e2.ChainID) && void 0 !== d ? d : new Uint8Array(), l;
} };
function createBaseTransaction_Receipt() {
  return { Data: [] };
}
var Transaction_Receipt = { encode(e2, t = minimal.Writer.create()) {
  if (void 0 !== e2.Data && 0 !== e2.Data.length)
    for (const n of e2.Data)
      t.uint32(10).bytes(n);
  return t;
}, decode(e2, t) {
  const n = e2 instanceof minimal.Reader ? e2 : new minimal.Reader(e2);
  let o = void 0 === t ? n.len : n.pos + t;
  const r = createBaseTransaction_Receipt();
  for (; n.pos < o; ) {
    const e3 = n.uint32();
    if (e3 >>> 3 == 1)
      r.Data.push(n.bytes());
    else
      n.skipType(7 & e3);
  }
  return r;
}, fromJSON: (e2) => ({ Data: Array.isArray(null == e2 ? void 0 : e2.data) ? e2.data.map((e3) => bytesFromBase64(e3)) : [] }), toJSON(e2) {
  const t = {};
  return e2.Data ? t.data = e2.Data.map((e3) => base64FromBytes(void 0 !== e3 ? e3 : new Uint8Array())) : t.data = [], t;
}, fromPartial(e2) {
  var t;
  const n = createBaseTransaction_Receipt();
  return n.Data = (null === (t = e2.Data) || void 0 === t ? void 0 : t.map((e3) => e3)) || [], n;
} };
dist.FileDescriptorProto.fromPartial({ name: "lib/transaction/proto/transaction.proto", package: "proto", dependency: ["google/protobuf/any.proto"], publicDependency: [], weakDependency: [], messageType: [{ name: "TXContract", field: [{ name: "Type", number: 1, label: 1, type: 14, typeName: ".proto.TXContract.ContractType", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Type", options: void 0, proto3Optional: false }, { name: "Parameter", number: 2, label: 1, type: 11, typeName: ".google.protobuf.Any", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Parameter", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [{ name: "ContractType", value: [{ name: "TransferContractType", number: 0, options: void 0 }, { name: "CreateAssetContractType", number: 1, options: void 0 }, { name: "CreateValidatorContractType", number: 2, options: void 0 }, { name: "ValidatorConfigContractType", number: 3, options: void 0 }, { name: "FreezeContractType", number: 4, options: void 0 }, { name: "UnfreezeContractType", number: 5, options: void 0 }, { name: "DelegateContractType", number: 6, options: void 0 }, { name: "UndelegateContractType", number: 7, options: void 0 }, { name: "WithdrawContractType", number: 8, options: void 0 }, { name: "ClaimContractType", number: 9, options: void 0 }, { name: "UnjailContractType", number: 10, options: void 0 }, { name: "AssetTriggerContractType", number: 11, options: void 0 }, { name: "SetAccountNameContractType", number: 12, options: void 0 }, { name: "ProposalContractType", number: 13, options: void 0 }, { name: "VoteContractType", number: 14, options: void 0 }, { name: "ConfigITOContractType", number: 15, options: void 0 }, { name: "SetITOPricesContractType", number: 16, options: void 0 }, { name: "BuyContractType", number: 17, options: void 0 }, { name: "SellContractType", number: 18, options: void 0 }, { name: "CancelMarketOrderContractType", number: 19, options: void 0 }, { name: "CreateMarketplaceContractType", number: 20, options: void 0 }, { name: "ConfigMarketplaceContractType", number: 21, options: void 0 }, { name: "UpdateAccountPermissionContractType", number: 22, options: void 0 }], options: void 0, reservedRange: [], reservedName: [] }], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "Transaction", field: [{ name: "RawData", number: 1, label: 1, type: 11, typeName: ".proto.Transaction.Raw", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "RawData", options: void 0, proto3Optional: false }, { name: "Signature", number: 2, label: 3, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Signature", options: void 0, proto3Optional: false }, { name: "Result", number: 3, label: 1, type: 14, typeName: ".proto.Transaction.TXResult", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Result", options: void 0, proto3Optional: false }, { name: "ResultCode", number: 4, label: 1, type: 14, typeName: ".proto.Transaction.TXResultCode", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ResultCode", options: void 0, proto3Optional: false }, { name: "Receipts", number: 5, label: 3, type: 11, typeName: ".proto.Transaction.Receipt", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Receipts", options: void 0, proto3Optional: false }, { name: "Block", number: 6, label: 1, type: 4, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Block", options: void 0, proto3Optional: false }], extension: [], nestedType: [{ name: "Raw", field: [{ name: "Nonce", number: 1, label: 1, type: 4, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Nonce", options: void 0, proto3Optional: false }, { name: "Sender", number: 2, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Sender", options: void 0, proto3Optional: false }, { name: "Contract", number: 6, label: 3, type: 11, typeName: ".proto.TXContract", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Contract", options: void 0, proto3Optional: false }, { name: "PermissionID", number: 7, label: 1, type: 5, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "PermissionID", options: void 0, proto3Optional: false }, { name: "Data", number: 10, label: 3, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Data", options: void 0, proto3Optional: false }, { name: "KAppFee", number: 13, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "KAppFee", options: void 0, proto3Optional: false }, { name: "BandwidthFee", number: 14, label: 1, type: 3, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "BandwidthFee", options: void 0, proto3Optional: false }, { name: "Version", number: 15, label: 1, type: 13, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "Version", options: void 0, proto3Optional: false }, { name: "ChainID", number: 16, label: 1, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "ChainID", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }, { name: "Receipt", field: [{ name: "Data", number: 1, label: 3, type: 12, typeName: "", extendee: "", defaultValue: "", oneofIndex: 0, jsonName: "data", options: void 0, proto3Optional: false }], extension: [], nestedType: [], enumType: [], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }], enumType: [{ name: "TXResult", value: [{ name: "SUCCESS", number: 0, options: void 0 }, { name: "FAILED", number: 1, options: void 0 }], options: void 0, reservedRange: [], reservedName: [] }, { name: "TXResultCode", value: [{ name: "Ok", number: 0, options: void 0 }, { name: "OutOfFunds", number: 1, options: void 0 }, { name: "AccountError", number: 2, options: void 0 }, { name: "AssetError", number: 3, options: void 0 }, { name: "ContractInvalid", number: 4, options: void 0 }, { name: "ContractNotFound", number: 5, options: void 0 }, { name: "FeeInvalid", number: 6, options: void 0 }, { name: "ParameterInvalid", number: 7, options: void 0 }, { name: "APRInvalid", number: 8, options: void 0 }, { name: "AssetIDInvalid", number: 9, options: void 0 }, { name: "AssetTypeInvalid", number: 10, options: void 0 }, { name: "AssetCantBeMinted", number: 11, options: void 0 }, { name: "AssetCantBeBurned", number: 12, options: void 0 }, { name: "AssetCantBePaused", number: 13, options: void 0 }, { name: "AssetCantBeDelegated", number: 14, options: void 0 }, { name: "AssetOwnerCantBeChanged", number: 15, options: void 0 }, { name: "AccountNotOwner", number: 16, options: void 0 }, { name: "CommissionTooHigh", number: 17, options: void 0 }, { name: "DelegationAmountInvalid", number: 18, options: void 0 }, { name: "ProposalNotActive", number: 19, options: void 0 }, { name: "ValueInvalid", number: 20, options: void 0 }, { name: "AmountInvalid", number: 21, options: void 0 }, { name: "BucketIDInvalid", number: 22, options: void 0 }, { name: "KeyConflict", number: 23, options: void 0 }, { name: "MaxDelegationAmount", number: 24, options: void 0 }, { name: "InvalidPeerKey", number: 25, options: void 0 }, { name: "MinKFIStakedUnreached", number: 26, options: void 0 }, { name: "MaxSupplyExeeced", number: 27, options: void 0 }, { name: "SaveAccountError", number: 28, options: void 0 }, { name: "LoadAccountError", number: 29, options: void 0 }, { name: "SameAccountError", number: 30, options: void 0 }, { name: "AssetPaused", number: 31, options: void 0 }, { name: "DeletegateError", number: 32, options: void 0 }, { name: "WithdrawNotAvailable", number: 33, options: void 0 }, { name: "ErrOverflow", number: 34, options: void 0 }, { name: "SetStakingErr", number: 35, options: void 0 }, { name: "SetMarketOrderErr", number: 36, options: void 0 }, { name: "BalanceError", number: 37, options: void 0 }, { name: "KAPPError", number: 38, options: void 0 }, { name: "UnfreezeError", number: 39, options: void 0 }, { name: "UndeletegateError", number: 40, options: void 0 }, { name: "WithdrawError", number: 41, options: void 0 }, { name: "ClaimError", number: 42, options: void 0 }, { name: "BucketsExceded", number: 43, options: void 0 }, { name: "AssetCantBeWiped", number: 44, options: void 0 }, { name: "AssetCantAddRoles", number: 45, options: void 0 }, { name: "FreezeError", number: 46, options: void 0 }, { name: "Fail", number: 99, options: void 0 }], options: void 0, reservedRange: [], reservedName: [] }], extensionRange: [], oneofDecl: [], options: void 0, reservedRange: [], reservedName: [] }], enumType: [], service: [], extension: [], options: { javaPackage: "", javaOuterClassname: "", javaMultipleFiles: false, javaGenerateEqualsAndHash: false, javaStringCheckUtf8: false, optimizeFor: 1, goPackage: "./;transaction", ccGenericServices: false, javaGenericServices: false, pyGenericServices: false, phpGenericServices: false, deprecated: false, ccEnableArenas: false, objcClassPrefix: "", csharpNamespace: "", swiftPrefix: "", phpClassPrefix: "", phpNamespace: "", phpMetadataNamespace: "", rubyPackage: "", uninterpretedOption: [] }, sourceCodeInfo: { location: [{ path: [4, 0], span: [9, 0, 37, 1], leadingComments: " TXContract available\n", trailingComments: "", leadingDetachedComments: [] }, { path: [4, 1], span: [40, 0, 119, 1], leadingComments: " Transaction holds all the data needed for a value transfer\n", trailingComments: "", leadingDetachedComments: [] }] }, syntax: "proto3" });
var globalThis$1 = (() => {
  if (void 0 !== globalThis$1)
    return globalThis$1;
  if ("undefined" != typeof self)
    return self;
  if ("undefined" != typeof window)
    return window;
  if ("undefined" != typeof global)
    return global;
  throw "Unable to locate global object";
})();
function bytesFromBase64(e2) {
  if (globalThis$1.Buffer)
    return Uint8Array.from(globalThis$1.Buffer.from(e2, "base64"));
  {
    const t = globalThis$1.atob(e2), n = new Uint8Array(t.length);
    for (let e3 = 0; e3 < t.length; ++e3)
      n[e3] = t.charCodeAt(e3);
    return n;
  }
}
function base64FromBytes(e2) {
  if (globalThis$1.Buffer)
    return globalThis$1.Buffer.from(e2).toString("base64");
  {
    const t = [];
    return e2.forEach((e3) => {
      t.push(String.fromCharCode(e3));
    }), globalThis$1.btoa(t.join(""));
  }
}
function longToNumber(e2) {
  if (e2.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$1.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return e2.toNumber();
}
function isSet(e2) {
  return null != e2;
}
minimal.util.Long !== long && (minimal.util.Long = long, minimal.configure());
var enc = new TextDecoder();
var decodeTransferContract = (e2) => {
  var t;
  const n = TransferContract.decode(e2);
  return { ToAddress: utils.encodeAddress(n.ToAddress), AssetID: (null === (t = n.AssetID) || void 0 === t ? void 0 : t.length) ? enc.decode(n.AssetID) : "KLV", Amount: n.Amount };
};
var decodeCreateAssetContract = (e2) => {
  var t, n, o, r, a, i;
  const s = CreateAssetContract.decode(e2);
  return { Type: s.Type, Name: enc.decode(s.Name), Ticker: enc.decode(s.Ticker), OwnerAddress: utils.encodeAddress(s.OwnerAddress), Logo: s.Logo, URIs: s.URIs, Precision: s.Precision, InitialSupply: s.InitialSupply, MaxSupply: s.MaxSupply, Royalties: { Address: (null === (t = s.Royalties) || void 0 === t ? void 0 : t.Address) ? utils.encodeAddress(s.Royalties.Address) : "", TransferPercentage: null === (n = s.Royalties) || void 0 === n ? void 0 : n.TransferPercentage, TransferFixed: null === (o = s.Royalties) || void 0 === o ? void 0 : o.TransferFixed, MarketPercentage: null === (r = s.Royalties) || void 0 === r ? void 0 : r.MarketPercentage, MarketFixed: null === (a = s.Royalties) || void 0 === a ? void 0 : a.MarketFixed }, Properties: s.Properties, Attributes: s.Attributes, Staking: s.Staking, Roles: null === (i = s.Roles) || void 0 === i ? void 0 : i.forEach((e3) => ({ Address: utils.encodeAddress(e3.Address), HasRoleMint: e3.HasRoleMint, HasRoleSetITOPrices: e3.HasRoleSetITOPrices })) };
};
var decodeCreateValidatorContract = (e2) => {
  var t, n, o, r, a, i, s, c;
  const d = CreateValidatorContract.decode(e2);
  return { OwnerAddress: utils.encodeAddress(d.OwnerAddress), Config: { BLSPublicKey: utils.toHex(null === (t = d.Config) || void 0 === t ? void 0 : t.BLSPublicKey), RewardAddress: utils.encodeAddress(null === (n = d.Config) || void 0 === n ? void 0 : n.RewardAddress), CanDelegate: null === (o = d.Config) || void 0 === o ? void 0 : o.CanDelegate, Commission: null === (r = d.Config) || void 0 === r ? void 0 : r.Commission, MaxDelegationAmount: null === (a = d.Config) || void 0 === a ? void 0 : a.MaxDelegationAmount, Logo: null === (i = d.Config) || void 0 === i ? void 0 : i.Logo, URIs: null === (s = d.Config) || void 0 === s ? void 0 : s.URIs, Name: null === (c = d.Config) || void 0 === c ? void 0 : c.Name } };
};
var decodeValidatorConfigContract = (e2) => {
  var t, n, o, r, a, i, s, c;
  const d = ValidatorConfigContract.decode(e2);
  return { Config: { BLSPublicKey: utils.toHex(null === (t = d.Config) || void 0 === t ? void 0 : t.BLSPublicKey), RewardAddress: utils.encodeAddress(null === (n = d.Config) || void 0 === n ? void 0 : n.RewardAddress), CanDelegate: null === (o = d.Config) || void 0 === o ? void 0 : o.CanDelegate, Commission: null === (r = d.Config) || void 0 === r ? void 0 : r.Commission, MaxDelegationAmount: null === (a = d.Config) || void 0 === a ? void 0 : a.MaxDelegationAmount, Logo: null === (i = d.Config) || void 0 === i ? void 0 : i.Logo, URIs: null === (s = d.Config) || void 0 === s ? void 0 : s.URIs, Name: null === (c = d.Config) || void 0 === c ? void 0 : c.Name } };
};
var decodeFreezeContract = (e2) => {
  var t;
  const n = FreezeContract.decode(e2);
  return { AssetID: (null === (t = n.AssetID) || void 0 === t ? void 0 : t.length) ? enc.decode(n.AssetID) : "KLV", Amount: n.Amount };
};
var decodeUnfreezeContractType = (e2) => {
  var t;
  const n = UnfreezeContract.decode(e2);
  return { AssetID: (null === (t = n.AssetID) || void 0 === t ? void 0 : t.length) ? enc.decode(n.AssetID) : "KLV", BucketID: enc.decode(n.BucketID) };
};
var decodeDelegateContract = (e2) => {
  const t = DelegateContract.decode(e2);
  return { ToAddress: utils.encodeAddress(t.ToAddress), BucketID: enc.decode(t.BucketID) };
};
var decodeUndelegateContract = (e2) => {
  const t = UndelegateContract.decode(e2);
  return { BucketID: enc.decode(t.BucketID) };
};
var decodeWithdrawContractType = (e2) => {
  var t;
  const n = WithdrawContract.decode(e2);
  return { AssetID: (null === (t = n.AssetID) || void 0 === t ? void 0 : t.length) ? enc.decode(n.AssetID) : "KLV" };
};
var decodeClaimContract = (e2) => {
  const t = ClaimContract.decode(e2);
  return { ClaimType: t.ClaimType, ID: enc.decode(t.ID) };
};
var decodeUnjailContract = (e2) => (UnjailContract.decode(e2), {});
var decodeAssetTriggerContract = (e2) => {
  var t, n, o;
  const r = AssetTriggerContract.decode(e2);
  return { TriggerType: r.TriggerType, AssetID: (null === (t = r.AssetID) || void 0 === t ? void 0 : t.length) ? enc.decode(r.AssetID) : "KLV", ToAddress: utils.encodeAddress(r.ToAddress), Amount: r.Amount, MIME: enc.decode(r.MIME), Logo: r.Logo, URIs: r.URIs, Role: { Address: r.Role ? utils.encodeAddress(r.Role.Address) : "", HasRoleMint: null === (n = r.Role) || void 0 === n ? void 0 : n.HasRoleMint, HasRoleSetITOPrices: null === (o = r.Role) || void 0 === o ? void 0 : o.HasRoleSetITOPrices }, Staking: r.Staking };
};
var decodeSetAccountNameContract = (e2) => {
  const t = SetAccountNameContract.decode(e2);
  return { Name: enc.decode(t.Name) };
};
var decodeProposalContract = (e2) => {
  const t = ProposalContract.decode(e2), n = {};
  for (var o in t.Parameters)
    n.a = enc.decode(t.Parameters[parseInt(o)]);
  return { Parameters: n, Description: enc.decode(t.Description), EpochsDuration: t.EpochsDuration };
};
var decodeVoteContract = (e2) => {
  const t = VoteContract.decode(e2);
  return { ProposalID: t.ProposalID, Amount: t.Amount, Type: t.Type };
};
var decodeConfigITOContract = (e2) => {
  var t;
  const n = ConfigITOContract.decode(e2);
  return { AssetID: (null === (t = n.AssetID) || void 0 === t ? void 0 : t.length) ? enc.decode(n.AssetID) : "KLV", ReceiverAddress: utils.encodeAddress(n.ReceiverAddress), Status: n.Status, MaxAmount: n.MaxAmount, PackInfo: n.PackInfo };
};
var decodeSetITOPricesContract = (e2) => {
  var t;
  const n = SetITOPricesContract.decode(e2);
  return { AssetID: (null === (t = n.AssetID) || void 0 === t ? void 0 : t.length) ? enc.decode(n.AssetID) : "KLV", PackInfo: n.PackInfo };
};
var decodeBuyContract = (e2) => {
  const t = BuyContract.decode(e2);
  return { BuyType: t.BuyType, ID: enc.decode(t.ID), CurrencyID: enc.decode(t.CurrencyID), Amount: t.Amount };
};
var decodeSellContract = (e2) => {
  var t;
  const n = SellContract.decode(e2);
  return { MarketType: n.MarketType, MarketplaceID: enc.decode(n.MarketplaceID), AssetID: (null === (t = n.AssetID) || void 0 === t ? void 0 : t.length) ? enc.decode(n.AssetID) : "KLV", CurrencyID: enc.decode(n.CurrencyID), Price: n.Price, ReservePrice: n.ReservePrice, EndTime: n.EndTime };
};
var decodeCancelMarketOrderContract = (e2) => {
  const t = CancelMarketOrderContract.decode(e2);
  return { OrderID: enc.decode(t.OrderID) };
};
var decodeCreateMarketplaceContract = (e2) => {
  const t = CreateMarketplaceContract.decode(e2);
  return { Name: enc.decode(t.Name), ReferralAddress: utils.encodeAddress(t.ReferralAddress), ReferralPercentage: t.ReferralPercentage };
};
var decodeConfigMarketplaceContract = (e2) => {
  const t = ConfigMarketplaceContract.decode(e2);
  return { MarketplaceID: enc.decode(t.MarketplaceID), Name: enc.decode(t.Name), ReferralAddress: utils.encodeAddress(t.ReferralAddress), ReferralPercentage: t.ReferralPercentage };
};
var decodeUpdateAccountPermissionContract = (e2) => {
  var t;
  return { Permissions: null === (t = UpdateAccountPermissionContract.decode(e2).Permissions) || void 0 === t ? void 0 : t.forEach((e3) => {
    var t2;
    return { Type: e3.Type, PermissionName: e3.PermissionName, Threshold: e3.Threshold, Operations: utils.toHex(e3.Operations), Signers: null === (t2 = e3.Signers) || void 0 === t2 ? void 0 : t2.forEach((e4) => ({ address: utils.encodeAddress(e4.address), weight: e4.weight })) };
  }) };
};
var decodeContract = (e2, t) => {
  switch (e2) {
    case TXContract_ContractType.TransferContractType:
      return decodeTransferContract(t.value);
    case TXContract_ContractType.CreateAssetContractType:
      return decodeCreateAssetContract(t.value);
    case TXContract_ContractType.CreateValidatorContractType:
      return decodeCreateValidatorContract(t.value);
    case TXContract_ContractType.ValidatorConfigContractType:
      return decodeValidatorConfigContract(t.value);
    case TXContract_ContractType.FreezeContractType:
      return decodeFreezeContract(t.value);
    case TXContract_ContractType.UnfreezeContractType:
      return decodeUnfreezeContractType(t.value);
    case TXContract_ContractType.DelegateContractType:
      return decodeDelegateContract(t.value);
    case TXContract_ContractType.UndelegateContractType:
      return decodeUndelegateContract(t.value);
    case TXContract_ContractType.WithdrawContractType:
      return decodeWithdrawContractType(t.value);
    case TXContract_ContractType.ClaimContractType:
      return decodeClaimContract(t.value);
    case TXContract_ContractType.UnjailContractType:
      return decodeUnjailContract(t.value);
    case TXContract_ContractType.AssetTriggerContractType:
      return decodeAssetTriggerContract(t.value);
    case TXContract_ContractType.SetAccountNameContractType:
      return decodeSetAccountNameContract(t.value);
    case TXContract_ContractType.ProposalContractType:
      return decodeProposalContract(t.value);
    case TXContract_ContractType.VoteContractType:
      return decodeVoteContract(t.value);
    case TXContract_ContractType.ConfigITOContractType:
      return decodeConfigITOContract(t.value);
    case TXContract_ContractType.SetITOPricesContractType:
      return decodeSetITOPricesContract(t.value);
    case TXContract_ContractType.BuyContractType:
      return decodeBuyContract(t.value);
    case TXContract_ContractType.SellContractType:
      return decodeSellContract(t.value);
    case TXContract_ContractType.CancelMarketOrderContractType:
      return decodeCancelMarketOrderContract(t.value);
    case TXContract_ContractType.CreateMarketplaceContractType:
      return decodeCreateMarketplaceContract(t.value);
    case TXContract_ContractType.ConfigMarketplaceContractType:
      return decodeConfigMarketplaceContract(t.value);
    case TXContract_ContractType.UpdateAccountPermissionContractType:
      return decodeUpdateAccountPermissionContract(t.value);
    default:
      throw "invalid transaction type";
  }
};
var Transaction = class {
  constructor(e2) {
    this.addContract = (e3, t) => __awaiter(this, void 0, void 0, function* () {
      var n, o;
      const r = anyMarshal(e3, t), a = TXContract.fromPartial({ Type: e3, Parameter: r });
      null === (o = null === (n = this.data.RawData) || void 0 === n ? void 0 : n.Contract) || void 0 === o || o.push(a);
    }), this.signMessage = (e3, t) => __awaiter(this, void 0, void 0, function* () {
      const n = yield sign(e3, t);
      return Buffer.from(n);
    }), this.computeHash = () => {
      try {
        const e3 = Transaction_Raw.encode(this.data.RawData).finish(), t = (utils.toHex(e3), blakejs.blake2b(e3, void 0, 32));
        return utils.toHex(t);
      } catch (e3) {
        throw e3;
      }
    }, this.sign = (e3) => __awaiter(this, void 0, void 0, function* () {
      var t;
      let n;
      try {
        n = this.computeHash();
      } catch (e4) {
        return console.log(e4), false;
      }
      const o = yield this.signMessage(n, e3);
      return null === (t = this.data.Signature) || void 0 === t || t.push(o), true;
    }), this.hex = () => {
      const e3 = Transaction$1.encode(this.data).finish();
      return utils.toHex(e3);
    }, this.toJSON = () => {
      const e3 = Transaction$1.toJSON(this.data);
      return JSON.stringify(e3);
    }, this.decode = () => {
      var e3, t, n;
      const o = new TextDecoder(), r = this.data.RawData, a = { Hash: this.computeHash(), BlockNum: this.data.Block, Sender: utils.encodeAddress(r.Sender), Nonce: r.Nonce, PermissionID: r.PermissionID, Data: [], KAppFee: r.KAppFee, BandwidthFee: r.BandwidthFee, Status: this.data.Block ? "on-chain" : "pending", Result: this.data.Result, ResultCode: this.data.ResultCode, Version: r.Version, ChainID: o.decode(r.ChainID), Signature: [], Contracts: [] };
      return null === (e3 = r.Data) || void 0 === e3 || e3.forEach((e4) => {
        a.Data.push(o.decode(e4));
      }), null === (t = this.data.Signature) || void 0 === t || t.forEach((e4) => {
        a.Signature.push(utils.toHex(e4));
      }), null === (n = r.Contract) || void 0 === n || n.forEach((e4) => {
        a.Contracts.push({ Type: e4.Type, Contract: decodeContract(e4.Type, e4.Parameter) });
      }), JSON.stringify(a);
    }, this.toBroadcast = () => Transaction$1.toJSON(this.data), this.data = Transaction$1.fromPartial({ RawData: e2 });
  }
};
var anyMarshal = (e2, t) => {
  var n, o = "type.googleapis.com/proto.";
  switch (e2) {
    case TXContract_ContractType.TransferContractType:
      n = TransferContract.encode(t).finish(), o += "TransferContract";
      break;
    case TXContract_ContractType.CreateAssetContractType:
      n = CreateAssetContract.encode(t).finish(), o += "CreateAssetContract";
      break;
    case TXContract_ContractType.CreateValidatorContractType:
      n = CreateValidatorContract.encode(t).finish(), o += "CreateValidatorContract";
      break;
    case TXContract_ContractType.ValidatorConfigContractType:
      n = ValidatorConfigContract.encode(t).finish(), o += "ValidatorConfigContract";
      break;
    case TXContract_ContractType.FreezeContractType:
      n = FreezeContract.encode(t).finish(), o += "FreezeContract";
      break;
    case TXContract_ContractType.UnfreezeContractType:
      n = UnfreezeContract.encode(t).finish(), o += "UnfreezeContract";
      break;
    case TXContract_ContractType.DelegateContractType:
      n = DelegateContract.encode(t).finish(), o += "DelegateContract";
      break;
    case TXContract_ContractType.UndelegateContractType:
      n = UndelegateContract.encode(t).finish(), o += "UndelegateContract";
      break;
    case TXContract_ContractType.WithdrawContractType:
      n = WithdrawContract.encode(t).finish(), o += "WithdrawContract";
      break;
    case TXContract_ContractType.ClaimContractType:
      n = ClaimContract.encode(t).finish(), o += "ClaimContract";
      break;
    case TXContract_ContractType.UnjailContractType:
      n = UnjailContract.encode(t).finish(), o += "UnjailContract";
      break;
    case TXContract_ContractType.AssetTriggerContractType:
      n = AssetTriggerContract.encode(t).finish(), o += "AssetTriggerContract";
      break;
    case TXContract_ContractType.SetAccountNameContractType:
      n = SetAccountNameContract.encode(t).finish(), o += "SetAccountNameContract";
      break;
    case TXContract_ContractType.ProposalContractType:
      n = ProposalContract.encode(t).finish(), o += "ProposalContract";
      break;
    case TXContract_ContractType.VoteContractType:
      n = VoteContract.encode(t).finish(), o += "VoteContract";
      break;
    case TXContract_ContractType.ConfigITOContractType:
      n = ConfigITOContract.encode(t).finish(), o += "ConfigITOContract";
      break;
    case TXContract_ContractType.SetITOPricesContractType:
      n = SetITOPricesContract.encode(t).finish(), o += "SetITOPricesContract";
      break;
    case TXContract_ContractType.BuyContractType:
      n = BuyContract.encode(t).finish(), o += "BuyContract";
      break;
    case TXContract_ContractType.SellContractType:
      n = SellContract.encode(t).finish(), o += "SellContract";
      break;
    case TXContract_ContractType.CancelMarketOrderContractType:
      n = CancelMarketOrderContract.encode(t).finish(), o += "CancelMarketOrderContract";
      break;
    case TXContract_ContractType.CreateMarketplaceContractType:
      n = CreateMarketplaceContract.encode(t).finish(), o += "CreateMarketplaceContract";
      break;
    case TXContract_ContractType.ConfigMarketplaceContractType:
      n = ConfigMarketplaceContract.encode(t).finish(), o += "ConfigMarketplaceContract";
      break;
    case TXContract_ContractType.UpdateAccountPermissionContractType:
      n = UpdateAccountPermissionContract.encode(t).finish(), o += "UpdateAccountPermissionContract";
      break;
    default:
      throw "invalid transaction type";
  }
  return Any.fromPartial({ type_url: o, value: n });
};
export {
  Account,
  contracts as Contracts,
  TXContract_ContractType,
  Transaction,
  TransactionType,
  TriggerType,
  any as proto,
  utils,
  web
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
//# sourceMappingURL=@klever_sdk.js.map
